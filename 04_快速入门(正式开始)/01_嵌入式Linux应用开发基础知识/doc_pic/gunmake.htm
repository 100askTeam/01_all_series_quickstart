<html xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:w="urn:schemas-microsoft-com:office:word" xmlns="http://www.w3.org/TR/REC-html40"><head>
<meta http-equiv="Content-Type" content="text/html; charset=GB2312">
<meta name="ProgId" content="Word.Document">
<meta name="Generator" content="Microsoft Word 9">
<meta name="Originator" content="Microsoft Word 9">
<link rel="File-List" href="http://blog.chinaunix.net/GNU%20Make%20.....files/filelist.xml">
<link rel="Edit-Time-Data" href="http://blog.chinaunix.net/GNU%20Make%20.....files/editdata.mso">
<!--[if !mso]>
<style>
v\:* {behavior:url(#default#VML);}
o\:* {behavior:url(#default#VML);}
w\:* {behavior:url(#default#VML);}
.shape {behavior:url(#default#VML);}
</style>
<![endif]--><title>GNU Make 使用手册（中译版）</title>

<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>yfc</o:Author>
  <o:Template>Normal</o:Template>
  <o:LastAuthor>yfc</o:LastAuthor>
  <o:Revision>2</o:Revision>
  <o:TotalTime>13398</o:TotalTime>
  <o:Created>2003-02-12T02:28:00Z</o:Created>
  <o:LastSaved>2003-02-12T02:28:00Z</o:LastSaved>
  <o:Pages>108</o:Pages>
  <o:Words>28350</o:Words>
  <o:Characters>39691</o:Characters>
  <o:Company>Microsoft</o:Company>
  <o:Lines>1470</o:Lines>
  <o:Paragraphs>882</o:Paragraphs>
  <o:CharactersWithSpaces>198455</o:CharactersWithSpaces>
  <o:Version>9.2812</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:HideSpellingErrors/>
  <w:HideGrammaticalErrors/>
  <w:ActiveWritingStyle Lang="ZH-CN" VendorID="64" DLLVersion="131077"
   NLCheck="1">1</w:ActiveWritingStyle>
  <w:ActiveWritingStyle Lang="EN-US" VendorID="64" DLLVersion="131077"
   NLCheck="1">1</w:ActiveWritingStyle>
  <w:PunctuationKerning/>
  <w:DrawingGridHorizontalSpacing>5.25 磅</w:DrawingGridHorizontalSpacing>
  <w:DrawingGridVerticalSpacing>7.8 磅</w:DrawingGridVerticalSpacing>
  <w:DisplayHorizontalDrawingGridEvery>0</w:DisplayHorizontalDrawingGridEvery>
  <w:DisplayVerticalDrawingGridEvery>2</w:DisplayVerticalDrawingGridEvery>
  <w:Compatibility>
   <w:SpaceForUL/>
   <w:BalanceSingleByteDoubleByteWidth/>
   <w:DoNotLeaveBackslashAlone/>
   <w:ULTrailSpace/>
   <w:DoNotExpandShiftReturn/>
   <w:FootnoteLayoutLikeWW8/>
   <w:ShapeLayoutLikeWW8/>
   <w:AlignTablesRowByRow/>
   <w:ForgetLastTabAlignment/>
   <w:LayoutRawTableWidth/>
   <w:LayoutTableRowsApart/>
   <w:UseFELayout/>
  </w:Compatibility>
 </w:WordDocument>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
@font-face
	{font-family:Times;
	panose-1:0 0 0 0 0 0 0 0 0 0;
	mso-font-charset:0;
	mso-generic-font-family:roman;
	mso-font-format:other;
	mso-font-pitch:variable;
	mso-font-signature:3 0 0 0 1 0;}
@font-face
	{font-family:Helvetica;
	panose-1:0 0 0 0 0 0 0 0 0 0;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-format:other;
	mso-font-pitch:variable;
	mso-font-signature:3 0 0 0 1 0;}
@font-face
	{font-family:Courier;
	panose-1:0 0 0 0 0 0 0 0 0 0;
	mso-font-charset:0;
	mso-generic-font-family:modern;
	mso-font-format:other;
	mso-font-pitch:fixed;
	mso-font-signature:3 0 0 0 1 0;}
@font-face
	{font-family:Geneva;
	panose-1:0 0 0 0 0 0 0 0 0 0;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-format:other;
	mso-font-pitch:variable;
	mso-font-signature:3 0 0 0 1 0;}
@font-face
	{font-family:"Tms Rmn";
	panose-1:0 0 0 0 0 0 0 0 0 0;
	mso-font-charset:0;
	mso-generic-font-family:roman;
	mso-font-format:other;
	mso-font-pitch:variable;
	mso-font-signature:3 0 0 0 1 0;}
@font-face
	{font-family:Helv;
	panose-1:0 0 0 0 0 0 0 0 0 0;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-format:other;
	mso-font-pitch:variable;
	mso-font-signature:3 0 0 0 1 0;}
@font-face
	{font-family:"MS Serif";
	panose-1:0 0 0 0 0 0 0 0 0 0;
	mso-font-charset:0;
	mso-generic-font-family:roman;
	mso-font-format:other;
	mso-font-pitch:variable;
	mso-font-signature:3 0 0 0 1 0;}
@font-face
	{font-family:"MS Sans Serif";
	panose-1:0 0 0 0 0 0 0 0 0 0;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-format:other;
	mso-font-pitch:variable;
	mso-font-signature:3 0 0 0 1 0;}
@font-face
	{font-family:"New York";
	panose-1:0 0 0 0 0 0 0 0 0 0;
	mso-font-charset:0;
	mso-generic-font-family:roman;
	mso-font-format:other;
	mso-font-pitch:variable;
	mso-font-signature:3 0 0 0 1 0;}
@font-face
	{font-family:System;
	panose-1:0 0 0 0 0 0 0 0 0 0;
	mso-font-charset:134;
	mso-generic-font-family:auto;
	mso-font-format:other;
	mso-font-pitch:auto;
	mso-font-signature:1 135135232 16 0 262144 0;}
@font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;
	mso-font-charset:2;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:0 268435456 0 0 -2147483648 0;}
@font-face
	{font-family:Mincho;
	panose-1:0 0 0 0 0 0 0 0 0 0;
	mso-font-alt:明朝;
	mso-font-charset:128;
	mso-generic-font-family:roman;
	mso-font-format:other;
	mso-font-pitch:fixed;
	mso-font-signature:1 134676480 16 0 131072 0;}
@font-face
	{font-family:Batang;
	panose-1:0 0 0 0 0 0 0 0 0 0;
	mso-font-alt:\BC14\D0D5;
	mso-font-charset:129;
	mso-generic-font-family:auto;
	mso-font-format:other;
	mso-font-pitch:fixed;
	mso-font-signature:1 151388160 16 0 524288 0;}
@font-face
	{font-family:宋体;
	panose-1:2 1 6 0 3 1 1 1 1 1;
	mso-font-alt:SimSun;
	mso-font-charset:134;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:3 135135232 16 0 262145 0;}
@font-face
	{font-family:PMingLiU;
	panose-1:2 2 3 0 0 0 0 0 0 0;
	mso-font-alt:新明w;
	mso-font-charset:136;
	mso-generic-font-family:auto;
	mso-font-format:other;
	mso-font-pitch:variable;
	mso-font-signature:1 134742016 16 0 1048576 0;}
@font-face
	{font-family:Gothic;
	panose-1:0 0 0 0 0 0 0 0 0 0;
	mso-font-alt:\FF7B\FF9E\FF7C\FF6F\FF78;
	mso-font-charset:128;
	mso-generic-font-family:modern;
	mso-font-format:other;
	mso-font-pitch:fixed;
	mso-font-signature:1 134676480 16 0 131072 0;}
@font-face
	{font-family:Dotum;
	panose-1:0 0 0 0 0 0 0 0 0 0;
	mso-font-alt:\B3CB\C6C0;
	mso-font-charset:129;
	mso-generic-font-family:modern;
	mso-font-format:other;
	mso-font-pitch:fixed;
	mso-font-signature:1 151388160 16 0 524288 0;}
@font-face
	{font-family:黑体;
	panose-1:2 1 6 0 3 1 1 1 1 1;
	mso-font-alt:SimHei;
	mso-font-charset:134;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:1 135135232 16 0 262144 0;}
@font-face
	{font-family:MingLiU;
	panose-1:2 2 3 9 0 0 0 0 0 0;
	mso-font-alt:明w;
	mso-font-charset:136;
	mso-generic-font-family:modern;
	mso-font-format:other;
	mso-font-pitch:fixed;
	mso-font-signature:1 134742016 16 0 1048576 0;}
@font-face
	{font-family:"MS Mincho";
	panose-1:0 0 0 0 0 0 0 0 0 0;
	mso-font-alt:"ＭＳ 明朝";
	mso-font-charset:128;
	mso-generic-font-family:roman;
	mso-font-format:other;
	mso-font-pitch:fixed;
	mso-font-signature:1 134676480 16 0 131072 0;}
@font-face
	{font-family:Gulim;
	panose-1:0 0 0 0 0 0 0 0 0 0;
	mso-font-alt:\AD74\B9BC;
	mso-font-charset:129;
	mso-generic-font-family:roman;
	mso-font-format:other;
	mso-font-pitch:fixed;
	mso-font-signature:1 151388160 16 0 524288 0;}
@font-face
	{font-family:"MS Gothic";
	panose-1:0 0 0 0 0 0 0 0 0 0;
	mso-font-alt:"ＭＳ ゴシック";
	mso-font-charset:128;
	mso-generic-font-family:modern;
	mso-font-format:other;
	mso-font-pitch:fixed;
	mso-font-signature:1 134676480 16 0 131072 0;}
@font-face
	{font-family:Century;
	panose-1:0 0 0 0 0 0 0 0 0 0;
	mso-font-charset:0;
	mso-generic-font-family:roman;
	mso-font-format:other;
	mso-font-pitch:variable;
	mso-font-signature:3 0 0 0 1 0;}
@font-face
	{font-family:"\@宋体";
	panose-1:2 1 6 0 3 1 1 1 1 1;
	mso-font-charset:134;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:1 135135232 16 0 262144 0;}
@font-face
	{font-family:"\@黑体";
	panose-1:2 1 6 0 3 1 1 1 1 1;
	mso-font-charset:134;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:1 135135232 16 0 262144 0;}
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	mso-pagination:none;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:宋体;
	mso-font-kerning:1.0pt;}
h1
	{mso-style-next:正文;
	margin-top:17.0pt;
	margin-right:0cm;
	margin-bottom:16.5pt;
	margin-left:0cm;
	text-align:justify;
	text-justify:inter-ideograph;
	line-height:240%;
	mso-pagination:lines-together;
	page-break-after:avoid;
	mso-outline-level:1;
	font-size:22.0pt;
	font-family:"Times New Roman";
	mso-font-kerning:22.0pt;
	font-weight:bold;}
h2
	{mso-style-update:auto;
	margin-right:0cm;
	mso-margin-top-alt:auto;
	mso-margin-bottom-alt:auto;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	mso-outline-level:2;
	font-size:15.0pt;
	mso-bidi-font-size:18.0pt;
	font-family:"Times New Roman";
	font-weight:bold;}
h3
	{mso-style-next:正文;
	margin-top:13.0pt;
	margin-right:0cm;
	margin-bottom:13.0pt;
	margin-left:0cm;
	text-align:justify;
	text-justify:inter-ideograph;
	line-height:173%;
	mso-pagination:lines-together;
	page-break-after:avoid;
	mso-outline-level:3;
	font-size:16.0pt;
	font-family:"Times New Roman";
	mso-font-kerning:1.0pt;
	font-weight:bold;}
p.MsoHeader, li.MsoHeader, div.MsoHeader
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:center;
	mso-pagination:none;
	tab-stops:center 207.65pt right 415.3pt;
	layout-grid-mode:char;
	border:none;
	mso-border-bottom-alt:solid windowtext .75pt;
	padding:0cm;
	mso-padding-alt:0cm 0cm 1.0pt 0cm;
	font-size:9.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:宋体;
	mso-font-kerning:1.0pt;}
p.MsoFooter, li.MsoFooter, div.MsoFooter
	{margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:none;
	tab-stops:center 207.65pt right 415.3pt;
	layout-grid-mode:char;
	font-size:9.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:宋体;
	mso-font-kerning:1.0pt;}
p.MsoBodyTextIndent, li.MsoBodyTextIndent, div.MsoBodyTextIndent
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	text-indent:21.0pt;
	mso-char-indent-count:2.0;
	mso-char-indent-size:10.5pt;
	mso-pagination:none;
	font-size:10.5pt;
	mso-bidi-font-size:10.0pt;
	font-family:宋体;
	mso-bidi-font-family:"Times New Roman";
	mso-font-kerning:1.0pt;}
a:link, span.MsoHyperlink
	{color:blue;
	text-decoration:underline;
	text-underline:single;}
a:visited, span.MsoHyperlinkFollowed
	{color:purple;
	text-decoration:underline;
	text-underline:single;}
p
	{margin-right:0cm;
	mso-margin-top-alt:auto;
	mso-margin-bottom-alt:auto;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:宋体;
	mso-bidi-font-family:"Times New Roman";}
code
	{mso-ascii-font-family:黑体;
	mso-fareast-font-family:黑体;
	mso-hansi-font-family:"Courier New";
	mso-bidi-font-family:Century;}
pre
	{margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt;
	font-size:10.0pt;
	font-family:黑体;
	mso-hansi-font-family:"Courier New";
	mso-bidi-font-family:"Times New Roman";}
samp
	{mso-ascii-font-family:黑体;
	mso-fareast-font-family:黑体;
	mso-hansi-font-family:"Courier New";
	mso-bidi-font-family:黑体;}
tt
	{mso-ascii-font-family:黑体;
	mso-fareast-font-family:黑体;
	mso-hansi-font-family:"Courier New";
	mso-bidi-font-family:黑体;}
span.t41
	{mso-style-name:t41;
	mso-ansi-font-size:10.5pt;
	mso-bidi-font-size:10.5pt;}
span.msoIns
	{mso-style-type:export-only;
	mso-style-name:"";
	text-decoration:underline;
	text-underline:single;
	color:teal;}
span.msoDel
	{mso-style-type:export-only;
	mso-style-name:"";
	text-decoration:line-through;
	color:red;}
span.msoChangeProp
	{mso-style-type:export-only;
	mso-style-name:"";
	color:black;}
 /* Page Definitions */
@page
	{mso-page-border-surround-header:no;
	mso-page-border-surround-footer:no;}
@page Section1
	{size:595.3pt 841.9pt;
	margin:72.0pt 89.85pt 72.0pt 89.85pt;
	mso-header-margin:42.55pt;
	mso-footer-margin:49.6pt;
	mso-even-footer:url("./GNU%20Make%20使用手册.files/header.htm") ef1;
	mso-footer:url("./GNU%20Make%20使用手册.files/header.htm") f1;
	mso-paper-source:0;
	layout-grid:15.6pt;}
div.Section1
	{page:Section1;}
 /* List Definitions */
@list l0
	{mso-list-id:156775538;
	mso-list-type:hybrid;
	mso-list-template-ids:257348904 -45598944 67698713 67698715 67698703 67698713 67698715 67698703 67698713 67698715;}
@list l0:level1
	{mso-level-start-at:6;
	mso-level-text:%1;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l1
	{mso-list-id:310868316;
	mso-list-type:hybrid;
	mso-list-template-ids:958547240 -1 -1 -1 -1 -1 -1 -1 -1 -1;}
@list l1:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l1:level2
	{mso-level-number-format:bullet;
	mso-level-text:o;
	mso-level-tab-stop:72.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:"Courier New";
	mso-bidi-font-family:"Times New Roman";}
@list l2
	{mso-list-id:417556871;
	mso-list-type:hybrid;
	mso-list-template-ids:1278144384 359331692 -1817305338 -1855933988 -1292737508 -14673120 149718674 347233018 -1250647236 -1119041634;}
@list l2:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l2:level2
	{mso-level-tab-stop:72.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l2:level3
	{mso-level-tab-stop:108.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l2:level4
	{mso-level-tab-stop:144.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l2:level5
	{mso-level-tab-stop:180.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l2:level6
	{mso-level-tab-stop:216.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l2:level7
	{mso-level-tab-stop:252.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l2:level8
	{mso-level-tab-stop:288.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l2:level9
	{mso-level-tab-stop:324.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l3
	{mso-list-id:427702250;
	mso-list-type:hybrid;
	mso-list-template-ids:-1972580280 -1 -1 -1 -1 -1 -1 -1 -1 -1;}
@list l3:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l4
	{mso-list-id:481628529;
	mso-list-template-ids:1471477012;}
@list l4:level1
	{mso-level-start-at:4;
	mso-level-text:%1;
	mso-level-tab-stop:24.0pt;
	mso-level-number-position:left;
	margin-left:24.0pt;
	text-indent:-24.0pt;}
@list l4:level2
	{mso-level-legal-format:yes;
	mso-level-text:"%1\.%2";
	mso-level-tab-stop:27.75pt;
	mso-level-number-position:left;
	margin-left:27.75pt;
	text-indent:-27.75pt;}
@list l4:level3
	{mso-level-legal-format:yes;
	mso-level-text:"%1\.%2\.%3";
	mso-level-tab-stop:27.75pt;
	mso-level-number-position:left;
	margin-left:27.75pt;
	text-indent:-27.75pt;}
@list l4:level4
	{mso-level-legal-format:yes;
	mso-level-text:"%1\.%2\.%3\.%4";
	mso-level-tab-stop:27.75pt;
	mso-level-number-position:left;
	margin-left:27.75pt;
	text-indent:-27.75pt;}
@list l4:level5
	{mso-level-legal-format:yes;
	mso-level-text:"%1\.%2\.%3\.%4\.%5";
	mso-level-tab-stop:27.75pt;
	mso-level-number-position:left;
	margin-left:27.75pt;
	text-indent:-27.75pt;}
@list l4:level6
	{mso-level-legal-format:yes;
	mso-level-text:"%1\.%2\.%3\.%4\.%5\.%6";
	mso-level-tab-stop:27.75pt;
	mso-level-number-position:left;
	margin-left:27.75pt;
	text-indent:-27.75pt;}
@list l4:level7
	{mso-level-legal-format:yes;
	mso-level-text:"%1\.%2\.%3\.%4\.%5\.%6\.%7";
	mso-level-tab-stop:27.75pt;
	mso-level-number-position:left;
	margin-left:27.75pt;
	text-indent:-27.75pt;}
@list l4:level8
	{mso-level-legal-format:yes;
	mso-level-text:"%1\.%2\.%3\.%4\.%5\.%6\.%7\.%8";
	mso-level-tab-stop:27.75pt;
	mso-level-number-position:left;
	margin-left:27.75pt;
	text-indent:-27.75pt;}
@list l4:level9
	{mso-level-legal-format:yes;
	mso-level-text:"%1\.%2\.%3\.%4\.%5\.%6\.%7\.%8\.%9";
	mso-level-tab-stop:27.75pt;
	mso-level-number-position:left;
	margin-left:27.75pt;
	text-indent:-27.75pt;}
@list l5
	{mso-list-id:508444743;
	mso-list-type:hybrid;
	mso-list-template-ids:1706691576 -1 -1 -1 -1 -1 -1 -1 -1 -1;}
@list l5:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l6
	{mso-list-id:602803046;
	mso-list-type:hybrid;
	mso-list-template-ids:248785638 -1 -1 -1 -1 -1 -1 -1 -1 -1;}
@list l6:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l6:level2
	{mso-level-number-format:bullet;
	mso-level-text:o;
	mso-level-tab-stop:72.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:"Courier New";
	mso-bidi-font-family:"Times New Roman";}
@list l6:level3
	{mso-level-number-format:bullet;
	mso-level-text:\F0A7;
	mso-level-tab-stop:108.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Wingdings;}
@list l7
	{mso-list-id:748966305;
	mso-list-type:hybrid;
	mso-list-template-ids:-1989222106 -1 -1 -1 -1 -1 -1 -1 -1 -1;}
@list l7:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l8
	{mso-list-id:788427435;
	mso-list-type:hybrid;
	mso-list-template-ids:-1256714312 -1 -1 -1 -1 -1 -1 -1 -1 -1;}
@list l8:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l9
	{mso-list-id:1022240282;
	mso-list-type:simple;
	mso-list-template-ids:-857422602;}
@list l9:level1
	{mso-level-text:%1、;
	mso-level-tab-stop:15.75pt;
	mso-level-number-position:left;
	margin-left:15.75pt;
	text-indent:-15.75pt;}
@list l10
	{mso-list-id:1031345421;
	mso-list-type:hybrid;
	mso-list-template-ids:-1416078524;}
@list l10:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F06C;
	mso-level-tab-stop:42.25pt;
	mso-level-number-position:left;
	margin-left:42.25pt;
	text-indent:-21.0pt;
	font-family:Wingdings;}
@list l10:level2
	{mso-level-number-format:bullet;
	mso-level-text:\F06E;
	mso-level-tab-stop:63.25pt;
	mso-level-number-position:left;
	margin-left:63.25pt;
	text-indent:-21.0pt;
	font-family:Wingdings;}
@list l11
	{mso-list-id:1189833830;
	mso-list-type:hybrid;
	mso-list-template-ids:695131754 166999814 153655782 67698715 67698703 67698713 67698715 67698703 67698713 67698715;}
@list l11:level1
	{mso-level-text:%1、;
	mso-level-tab-stop:54.0pt;
	mso-level-number-position:left;
	margin-left:54.0pt;
	text-indent:-33.0pt;}
@list l11:level2
	{mso-level-text:%2、;
	mso-level-tab-stop:60.0pt;
	mso-level-number-position:left;
	margin-left:60.0pt;
	text-indent:-18.0pt;}
@list l12
	{mso-list-id:1196046488;
	mso-list-type:hybrid;
	mso-list-template-ids:-1655117982 -1 -1 -1 -1 -1 -1 -1 -1 -1;}
@list l12:level1
	{mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l13
	{mso-list-id:1275211376;
	mso-list-type:hybrid;
	mso-list-template-ids:-2129220224 -1 -1 -1 -1 -1 -1 -1 -1 -1;}
@list l13:level1
	{mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l13:level2
	{mso-level-tab-stop:72.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l14
	{mso-list-id:1349328728;
	mso-list-type:simple;
	mso-list-template-ids:1911059832;}
@list l14:level1
	{mso-level-text:%1、;
	mso-level-tab-stop:31.5pt;
	mso-level-number-position:left;
	margin-left:31.5pt;
	text-indent:-15.75pt;}
@list l15
	{mso-list-id:1373579972;
	mso-list-type:hybrid;
	mso-list-template-ids:-1618584138 -1 -1 -1 -1 -1 -1 -1 -1 -1;}
@list l15:level1
	{mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l16
	{mso-list-id:1483237466;
	mso-list-type:hybrid;
	mso-list-template-ids:913593618 -1 -1 -1 -1 -1 -1 -1 -1 -1;}
@list l16:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l17
	{mso-list-id:1500119179;
	mso-list-type:hybrid;
	mso-list-template-ids:-34414638 96623498 887390942 -78881008 2118267300 -1469421232 -1248321528 455924454 787108810 -358192488;}
@list l17:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l17:level2
	{mso-level-number-format:bullet;
	mso-level-text:o;
	mso-level-tab-stop:72.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:"Courier New";
	mso-bidi-font-family:"Times New Roman";}
@list l17:level3
	{mso-level-number-format:bullet;
	mso-level-text:\F0A7;
	mso-level-tab-stop:108.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Wingdings;}
@list l18
	{mso-list-id:1513033926;
	mso-list-type:hybrid;
	mso-list-template-ids:1718397362 -1 -1 -1 -1 -1 -1 -1 -1 -1;}
@list l18:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l19
	{mso-list-id:1548444934;
	mso-list-type:hybrid;
	mso-list-template-ids:-1450690172 67698689 67698691 67698693 67698689 67698691 67698693 67698689 67698691 67698693;}
@list l19:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F06C;
	mso-level-tab-stop:57.0pt;
	mso-level-number-position:left;
	margin-left:57.0pt;
	text-indent:-21.0pt;
	font-family:Wingdings;}
@list l20
	{mso-list-id:1556967004;
	mso-list-type:hybrid;
	mso-list-template-ids:785697040 -1 -1 -1 -1 -1 -1 -1 -1 -1;}
@list l20:level1
	{mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l20:level2
	{mso-level-tab-stop:72.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l21
	{mso-list-id:1652903880;
	mso-list-type:hybrid;
	mso-list-template-ids:-909846348 67698689 67698691 67698693 67698689 67698691 67698693 67698689 67698691 67698693;}
@list l21:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F06C;
	mso-level-tab-stop:42.0pt;
	mso-level-number-position:left;
	margin-left:42.0pt;
	text-indent:-21.0pt;
	font-family:Wingdings;}
@list l22
	{mso-list-id:1734622424;
	mso-list-type:hybrid;
	mso-list-template-ids:-951392404 -1 -1 -1 -1 -1 -1 -1 -1 -1;}
@list l22:level1
	{mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l23
	{mso-list-id:1836920527;
	mso-list-type:hybrid;
	mso-list-template-ids:1730284364 577417942 67698713 67698715 67698703 67698713 67698715 67698703 67698713 67698715;}
@list l23:level1
	{mso-level-start-at:9;
	mso-level-text:%1;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l24
	{mso-list-id:1949775779;
	mso-list-type:hybrid;
	mso-list-template-ids:1333965310 -786638080 67698713 67698715 67698703 67698713 67698715 67698703 67698713 67698715;}
@list l24:level1
	{mso-level-start-at:3;
	mso-level-text:%1;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l25
	{mso-list-id:2008753349;
	mso-list-type:hybrid;
	mso-list-template-ids:-1952918990 -1 -1 -1 -1 -1 -1 -1 -1 -1;}
@list l25:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l26
	{mso-list-id:2080396334;
	mso-list-type:hybrid;
	mso-list-template-ids:2140554694 67698689 67698691 67698693 67698689 67698691 67698693 67698689 67698691 67698693;}
@list l26:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F06C;
	mso-level-tab-stop:21.0pt;
	mso-level-number-position:left;
	margin-left:21.0pt;
	text-indent:-21.0pt;
	font-family:Wingdings;}
@list l27
	{mso-list-id:2110544005;
	mso-list-type:hybrid;
	mso-list-template-ids:1751013086 -1 -1 -1 -1 -1 -1 -1 -1 -1;}
@list l27:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l28
	{mso-list-id:2118519092;
	mso-list-type:hybrid;
	mso-list-template-ids:1571715596 67698689 67698691 67698693 67698689 67698691 67698693 67698689 67698691 67698693;}
@list l28:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F06C;
	mso-level-tab-stop:21.0pt;
	mso-level-number-position:left;
	margin-left:21.0pt;
	text-indent:-21.0pt;
	font-family:Wingdings;}
@list l29
	{mso-list-id:2123529353;
	mso-list-type:hybrid;
	mso-list-template-ids:-961093682 67698689 67698691 67698693 67698689 67698691 67698693 67698689 67698691 67698693;}
@list l29:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F06C;
	mso-level-tab-stop:57.0pt;
	mso-level-number-position:left;
	margin-left:57.0pt;
	text-indent:-21.0pt;
	font-family:Wingdings;}
@list l30
	{mso-list-id:2141999295;
	mso-list-type:hybrid;
	mso-list-template-ids:-296046676 1916971872 67698713 67698715 67698703 67698713 67698715 67698703 67698713 67698715;}
@list l30:level1
	{mso-level-text:%1、;
	mso-level-tab-stop:60.0pt;
	mso-level-number-position:left;
	margin-left:60.0pt;
	text-indent:-18.0pt;}
ol
	{margin-bottom:0cm;}
ul
	{margin-bottom:0cm;}
-->
</style></head>

<body lang="ZH-CN" link="blue" vlink="purple" style="">

<div class="Section1" style="">

<h1 align="center" style="text-align: center;"><span lang="EN-US" style="font-family: 宋体;">GNU Make 使用手册（中译版）<o:p></o:p></span></h1>

<p class="MsoNormal"><span style="font-family: 宋体;">翻译：于凤昌<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><span style="font-family: 宋体;">译者注：本人在阅读<span lang="EN-US">Linux源代码过程中发现如果要全面了解Linux的结构、理解Linux的编程总体设计及思想必须首先全部读通Linux源代码中各级的Makefile文件。目前，在网上虽然有一些著作，但都不能全面的解释Linux源代码中各级的Makefile文件，因此本人认真阅读了GNU
Make 使用手册（3.79）版原文，在此基础上翻译了该手册，以满足对Linux源代码有兴趣或者希望采用GCC编写程序但对缺乏GNU
Make全面了解之人士的需要。本人是业余爱好不是专业翻译人士，如果有问题请通过电子信箱与我联系共同商讨，本人的E-mail为：<a href="mailto:yfc70@public2.lyptt.ha.cn">yfc70@public2.lyptt.ha.cn</a> 。</span></span><b><span style="font-size: 12pt; font-family: 宋体;">注意在文章中出现的斜体加粗字表示章节。</span></b><span lang="EN-US" style="font-family: 宋体;"><o:p></o:p></span></p>

<h1 align="center" style="text-align: center;"><span lang="EN-US" style="font-family: 宋体;">GNU </span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">make</span></code><span lang="EN-US" style="font-family: 宋体;"> Version 3.79<o:p></o:p></span></h1>

<h2><span lang="EN-US" style="font-family: 宋体;">April 2000<o:p></o:p></span></h2>

<p class="MsoNormal" align="center" style="text-align: center;"><span lang="EN-US" style="font-family: 宋体;">Richard M. Stallman and Roland McGrath<o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 18pt;"><b><span lang="EN-US" style="font-size: 18pt; font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></b></p>

<h1><span style="font-family: 宋体;">目录<span lang="EN-US"><o:p></o:p></span></span></h1>

<p class="MsoNormal" style="margin-left: 18pt;"><span lang="EN-US" style="font-family: 宋体;">1 <a href="#_1_Make_%B8%C5%CA%F6"><code><span style="">make概述</span></code></a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">1.1 <a href="#_1.1%D4%F5%D1%F9%D4%C4%B6%C1%B1%BE%CA%D6%B2%E1">怎样阅读本手册</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">1.2 <a href="#_1.2%CE%CA%CC%E2%BA%CDBUG">问题和BUG</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 18pt;"><span lang="EN-US" style="font-family: 宋体;">2 <a href="#_2_Makefile%CE%C4%BC%FE%BD%E9%C9%DC">Makefile文件介绍</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">2.1 <a href="#_2.1_%B9%E6%D4%F2%B5%C4%D1%F9%CA%BD">规则的格式</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">2.2<a href="#_2.2%D2%BB%B8%F6%BC%F2%B5%A5%B5%C4Makefile%CE%C4%BC%FE">一个简单的Makefile文件</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">2.3<a href="#_2.3_make%CA%C7%B4%A6%C0%EDmakefile%CE%C4%BC%FE%B5%C4%B9%FD%B3%CC">make处理Makefile文件的过程</a>
<o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">2.4<a href="#_2.4%CA%B9%D3%C3%B1%E4%C1%BF%BC%F2%BB%AFmakefile%CE%C4%BC%FE">使用变量简化Makefile文件</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">2.5<a href="#_2.5_%C8%C3make%CD%C6%B6%CF%C3%FC%C1%EE">让make推断命令</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">2.6<a href="#_2.6_%C1%ED%D2%BB%D6%D6%B7%E7%B8%F1%B5%C4makefile%CE%C4%BC%FE">另一种风格的Makefile文件</a>
<o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">2.7<a href="#_2.7_%D4%DA%C4%BF%C2%BC%D6%D0%C9%BE%B3%FD%CE%C4%BC%FE%B5%C4%B9%E6%D4%F2">在目录中删除文件的规则</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt; text-indent: -18pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: 宋体;">3<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><!--[endif]--><span lang="EN-US" style="font-family: 宋体;"><a href="#_3_%B1%E0%D0%B4makefile%CE%C4%BC%FE">编写Makefile文件</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">3.1<a href="#_3.1_makefile%CE%C4%BC%FE%B5%C4%C4%DA%C8%DD">Makefile文件的内容</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">3.2<a href="#_3.2_makfile%CE%C4%BC%FE%C3%FB%D7%D6%B5%C4%B9%E6%B6%A8">Makefile文件的命名</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">3.3<a href="#_3.3_%B0%FC%BA%AC%C6%E4%CB%FC%B5%C4makefile%CE%C4%BC%FE">包含其它的Makefile文件</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">3.4<a href="#_3.4_%BB%B7%BE%B3%B1%E4%C1%BFmakefiles"><code><span style="">变量MAKEFILES</span></code></a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">3.5<a href="#_3.5_makefile%CE%C4%BC%FE%D6%D8%D0%C2%C9%FA%B3%C9%B5%C4%B9%FD%B3%CC">Makefile文件重新生成的过程</a>
<o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">3.6<a href="#_3.6_%BD%E2%BE%F6%C6%E4%CB%FCmakefile%CE%C4%BC%FE%D6%D0%B5%C4%B3%E5%CD%BB">重载其它Makefile文件</a>
<o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">3.7<a href="#_3.7_make%B6%C1%C8%A1makefile%CE%C4%BC%FE%B5%C4%B9%FD%B3%CC">make读取Makefile文件的过程</a>
<o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 18pt;"><span lang="EN-US" style="font-family: 宋体;">4 <a href="#_4%B1%E0%D0%B4%B9%E6%D4%F2">编写规则</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">4.1<a href="#_4.1%B9%E6%D4%F2%B5%C4%D3%EF%B7%A8">规则的语法</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">4.2<a href="#_4.2_%D4%DA%CE%C4%BC%FE%C3%FB%D6%D0%CA%B9%D3%C3%CD%A8%C5%E4%B7%FB">在文件名中使用通配符</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 90pt;"><span lang="EN-US" style="font-family: 宋体;">4.2.1<a href="#_4.2.1%CD%A8%C5%E4%B7%FB%B5%C4%C0%FD%D7%D3">通配符例子</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 90pt;"><span lang="EN-US" style="font-family: 宋体;">4.2.2<a href="#_4.2.2%CA%B9%D3%C3%CD%A8%C5%E4%B7%FB%B5%C4%B3%A3%BC%FB%B4%ED%CE%F3">使用通配符的常见错误</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 90pt;"><span lang="EN-US" style="font-family: 宋体;">4.2.3<a href="#_4.2.3%CD%A8%C5%E4%B7%FB%BA%AF%CA%FD"><code><span style="">函数wildcard</span></code></a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">4.3<a href="#_4.3%D4%DA%B2%BB%CD%AC%CE%C4%BC%FE%BC%D0%D6%D0%CB%D1%D1%B0%D2%C0%C0%B5">在目录中搜寻依赖</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 90pt;"><span lang="EN-US" style="font-family: 宋体;">4.3.1<a href="#_4.3.1_VPATH%A3%BA%CB%F9%D3%D0%D2%C0%C0%B5%B5%C4%CB%D1%D1%B0%C2%B7%BE%B6">VPATH:所有依赖的搜寻路径</a>
<o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 90pt;"><span lang="EN-US" style="font-family: 宋体;">4.3.2<a href="#_4.3.2_vpath%D6%B8%C1%EE">vpath指令</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 90pt;"><span lang="EN-US" style="font-family: 宋体;">4.3.3<a href="#_4.3.3%CE%C4%BC%FE%BC%D0%B5%C4%CB%D1%D1%B0%B9%FD%B3%CC">目录搜寻过程</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 90pt;"><span lang="EN-US" style="font-family: 宋体;">4.3.4<a href="#_4.3.4_%CE%AA%CE%C4%BC%FE%BC%D0%CB%D1%D1%B0%B1%E0%D0%B4shell%C3%FC%C1%EE">编写搜寻目录的shell命令</a>
<o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 90pt;"><span lang="EN-US" style="font-family: 宋体;">4.3.5<a href="#_4.3.5_%CE%C4%BC%FE%BC%D0%CB%D1%D1%B0%BA%CD%D2%FE%BA%AC%B9%E6%D4%F2">目录搜寻和隐含规则</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 90pt;"><span lang="EN-US" style="font-family: 宋体;">4.3.6<a href="#_4.3.6_%C1%AC%BD%D3%BF%E2%B5%C4%CE%C4%BC%FE%BC%D0%CB%D1%D1%B0">连接库的搜寻目录</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">4.4<a href="#_4.4%BC%D9%CF%EB%C4%BF%B1%EA">假想目标</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">4.5<a href="#_4.5_%C3%BB%D3%D0%C3%FC%C1%EE%BB%F2%D2%C0%C0%B5%B5%C4%B9%E6%D4%F2">没有命令或依赖的规则</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">4.6<a href="#_4.6%CA%B9%D3%C3%BF%D5%C4%BF%B1%EA%CE%C4%BC%FE%BC%C7%C2%BC%CA%C2%BC%FE">使用空目录文件记录事件</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">4.7<a href="#_4.7_%C4%DA%B2%BF%CA%B9%D3%C3%B5%C4%D2%BB%D0%A9%CC%D8%CA%E2%C4%BF%B1%EA%C3%FB">内建的特殊目标名</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">4.8<a href="#_4.8_%BE%DF%D3%D0%B6%E0%B8%F6%C4%BF%B1%EA%B5%C4%B9%E6%D4%F2">具有多个目标的规则</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">4.9<a href="#_4.9_%BE%DF%D3%D0%B6%E0%CC%F5%B9%E6%D4%F2%B5%C4%C4%BF%B1%EA">具有多条规则的目标</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">4.10<a href="#_4.10_%BE%B2%CC%AC%B8%F1%CA%BD%B9%E6%D4%F2">静态格式规则</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 90pt;"><span lang="EN-US" style="font-family: 宋体;">4.10.1<a href="#_4.10.1_%BE%B2%CC%AC%B8%F1%CA%BD%B9%E6%D4%F2%B5%C4%D3%EF%B7%A8">静态格式规则的语法</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 90pt;"><span lang="EN-US" style="font-family: 宋体;">4.10.2<a href="#_4.10.2%BE%B2%CC%AC%B8%F1%CA%BD%B9%E6%D4%F2%BA%CD%D2%FE%BA%AC%B9%E6%D4%F2">静态格式规则和隐含规则</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">4.11<a href="#_4.11%CB%AB%C3%B0%BA%C5%B9%E6%D4%F2">双冒号规则</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">4.12<a href="#_4.12_%D7%D4%B6%AF%C9%FA%B3%C9%D2%C0%C0%B5">自动生成依赖</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 18pt;"><span lang="EN-US" style="font-family: 宋体;">5 <a href="#_5%D4%DA%B9%E6%D4%F2%D6%D0%CA%B9%D3%C3%C3%FC%C1%EE">在规则中使用命令</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">5.1<a href="#_5.1_%C3%FC%C1%EE%BB%D8%CF%D4">命令回显</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">5.2<a href="#_5.2%C3%FC%C1%EE%B5%C4%D6%B4%D0%D0">执行命令</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">5.3<a href="#_5.3_%B2%A2%D0%D0%D6%B4%D0%D0">并行执行</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">5.4<a href="#_5.4%C3%FC%C1%EE%B4%ED%CE%F3">命令错误</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">5.5<a href="#_5.5%D6%D0%B6%CF%BB%F2%B9%D8%B1%D5make"><code><span style="">中断或关闭make</span></code></a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">5.6<a href="#_5.6_make%B5%C4%B5%DD%B9%E9%B5%F7%D3%C3"><code><span style="">递归调用make</span></code></a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 90pt;"><span lang="EN-US" style="font-family: 宋体;">5.6.1<a href="#_5.6.1_%B1%E4%C1%BFMAKE%B5%C4%B9%A4%D7%F7%B7%BD%CA%BD">变量MAKE的工作方式</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 90pt;"><span lang="EN-US" style="font-family: 宋体;">5.6.2<a href="#_5.6.2%D3%EB%D7%D3make%B5%C4%CD%A8%D1%B6%B1%E4%C1%BF"><code><span style="">与子make通讯的变量</span></code></a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 90pt;"><span lang="EN-US" style="font-family: 宋体;">5.6.3<a href="#_5.6.3%D3%EB%D7%D3make%B5%C4%CD%A8%D1%B6%D1%A1%CF%EE"><code><span style="">与子make通讯的选项</span></code></a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 90pt;"><span lang="EN-US" style="font-family: 宋体;">5.6.4<a href="#_5.6.4_%A1%AE--print-directory%A1%AF%D1%A1%CF%EE">`--print-directory'选项</a>
<o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">5.7<a href="#_5.7%B6%A8%D2%E5%B9%CC%B6%A8%B4%CE%D0%F2%B5%C4%C3%FC%C1%EE">定义固定次序命令</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">5.8<a href="#_5.8_%CA%B9%D3%C3%BF%D5%C3%FC%C1%EE">使用空命令</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt; text-indent: -18pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: 宋体;">6<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><!--[endif]--><span lang="EN-US" style="font-family: 宋体;"><a href="#_6_%CA%B9%D3%C3%B1%E4%C1%BF">使用变量</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">6.1<a href="#_6.1_%B1%E4%C1%BF%D2%FD%D3%C3%BB%F9%B4%A1">变量引用基础</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">6.2<a href="#_6.2_%B1%E4%C1%BF%B5%C4%C1%BD%B8%F6%CC%D8%C9%AB">变量的两个特色</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">6.3<a href="#_6.3%B1%E4%C1%BF%D2%FD%D3%C3%B8%DF%BC%B6%BC%BC%CA%F5">变量高级引用技术</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 90pt;"><span lang="EN-US" style="font-family: 宋体;">6.3.1<a href="#_6.3.1%CC%E6%BB%BB%D2%FD%D3%C3">替换引用</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 90pt;"><span lang="EN-US" style="font-family: 宋体;">6.3.2<a href="#_6.3.2%C7%B6%CC%D7%B1%E4%C1%BF%D2%FD%D3%C3%A3%A8%BC%C6%CB%E3%B5%C4%B1%E4%C1%BF%C3%FB%A3%A9">嵌套变量引用</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">6.4<a href="#_6.4%B1%E4%C1%BF%B5%C4%C8%A1%D6%B5">变量取值</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">6.5<a href="#_6.5%C9%E8%D6%C3%B1%E4%C1%BF">设置变量</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">6.6<a href="#_6.6_%CE%AA%B1%E4%C1%BF%D7%B7%BC%D3%B8%FC%B6%E0%B5%C4%CE%C4%B1%BE">为变量值追加文本</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">6.7<a href="#_6.7_override%D6%B8%C1%EE">override指令</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">6.8<a href="#_6.8%B6%A8%D2%E5%B6%E0%D0%D0%B1%E4%C1%BF">定义多行变量</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">6.9<a href="#_6.9_%BB%B7%BE%B3%B1%E4%C1%BF">环境变量</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">6.10<a href="#_6.10_%CC%D8%B6%A8%C4%BF%B1%EA%B1%E4%C1%BF%B5%C4%D6%B5">特定目标变量的值</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">6.11<a href="#_6.11_%CC%D8%B6%A8%B8%F1%CA%BD%B1%E4%C1%BF%B5%C4%D6%B5">特定格式变量的值</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 18pt;"><span lang="EN-US" style="font-family: 宋体;">7 <a href="#_7_makefile%CE%C4%BC%FE%B5%C4%CC%F5%BC%FE%D3%EF%BE%E4">Makefile文件的条件语句</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">7.1<a href="#_7.1%CC%F5%BC%FE%D3%EF%BE%E4%B5%C4%C0%FD%D7%D3">条件语句的例子</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">7.2<a href="#_7.2%CC%F5%BC%FE%D3%EF%BE%E4%B5%C4%D3%EF%B7%A8">条件语句的语法</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">7.3<a href="#_7.3%B2%E2%CA%D4%B1%EA%D6%BE%B5%C4%CC%F5%BC%FE%D3%EF%BE%E4">测试标志的条件语句</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 18pt;"><span lang="EN-US" style="font-family: 宋体;">8 <a href="#_8_%CE%C4%B1%BE%D7%AA%BB%BB%BA%AF%CA%FD">文本转换函数</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">8.1<a href="#_8.1%BA%AF%CA%FD%B5%F7%D3%C3%D3%EF%B7%A8">函数调用语法</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">8.2<a href="#_8.2%D7%D6%B7%FB%B4%AE%CC%E6%BB%BB%BA%CD%B7%D6%CE%F6%BA%AF%CA%FD">字符串替换和分析函数</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">8.3<a href="#_8.3%CE%C4%BC%FE%C3%FB%BA%AF%CA%FD">文件名函数</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">8.4<a href="#_8.4%BA%AF%CA%FDforeach">函数foreach</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">8.5<a href="#_8.5%BA%AF%CA%FDif">函数if</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">8.6<a href="#_8.6%BA%AF%CA%FDcall">函数call</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">8.7<a href="#_8.7%BA%AF%CA%FDorigin">函数origin</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">8.8<a href="#_8.8_%BA%AF%CA%FDshell">函数shell</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">8.9<a href="#_8.9_%BF%D8%D6%C6make%B5%C4%BA%AF%CA%FD">控制Make的函数</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt; text-indent: -18pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: 宋体;">9<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><!--[endif]--><span lang="EN-US" style="font-family: 宋体;"><a href="#_9_%D4%CB%D0%D0make"><code><span style="">运行make</span></code></a>
<o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">9.1<a href="#_9.1_%D6%B8%B6%A8makefile%CE%C4%BC%FE%B5%C4%B2%CE%CA%FD">指定Makefile文件的参数</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">9.2<a href="#_9.2%D6%B8%B6%A8%D7%EE%D6%D5%C4%BF%B1%EA%B5%C4%B2%CE%CA%FD">指定最终目标的参数</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">9.3<a href="#_9.3_%B4%FA%CC%E6%D6%B4%D0%D0%C3%FC%C1%EE">代替执行命令</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">9.4<a href="#_9.4%B1%DC%C3%E2%D6%D8%D0%C2%B1%E0%D2%EB%D2%BB%D0%A9%CE%C4%BC%FE">避免重新编译文件</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">9.5<a href="#_9.5%D6%D8%D4%D8%B1%E4%C1%BF">变量重载</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">9.6<a href="#_9.6_%B2%E2%CA%D4%B1%E0%D2%EB%B3%CC%D0%F2">测试编译程序</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">9.7<a href="#_9.7_%D1%A1%CF%EE%B8%C5%D2%AA">选项概要</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 18pt;"><span lang="EN-US" style="font-family: 宋体;">10 <a href="#_10_%CA%B9%D3%C3%D2%FE%BA%AC%B9%E6%D4%F2">使用隐含规则</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">10.1<a href="#_10.1_%CA%B9%D3%C3%D2%FE%BA%AC%B9%E6%D4%F2">使用隐含规则</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">10.2<a href="#_10.2%D2%FE%BA%AC%B9%E6%D4%F2%C4%BF%C2%BC">隐含规则目录</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">10.3<a href="#_10.3%D2%FE%BA%AC%B9%E6%D4%F2%CA%B9%D3%C3%B5%C4%B1%E4%C1%BF">隐含规则使用的变量</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">10.4<a href="#_10.4_%D2%FE%BA%AC%B9%E6%D4%F2%C1%B4">隐含规则链</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">10.5<a href="#_10.5%B6%A8%D2%E5%D3%EB%D6%D8%D0%C2%B6%A8%D2%E5%B8%F1%CA%BD%B9%E6%D4%F2">定义与重新定义格式规则</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 90pt;"><span lang="EN-US" style="font-family: 宋体;">10.5.1<a href="#_10.5.1%B8%F6%CA%C7%B9%E6%D4%F2%BC%F2%BD%E9">格式规则简介</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 90pt;"><span lang="EN-US" style="font-family: 宋体;">10.5.2<a href="#_10.5.2%B8%F1%CA%BD%B9%E6%D4%F2%B5%C4%C0%FD%D7%D3">格式规则的例子</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 90pt;"><span lang="EN-US" style="font-family: 宋体;">10.5.3<a href="#_10.5.3%D7%D4%B6%AF%B1%E4%C1%BF">自动变量</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 90pt;"><span lang="EN-US" style="font-family: 宋体;">10.5.4<a href="#_10.5.4%B8%F1%CA%BD%C6%A5%C5%E4">格式匹配</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 90pt;"><span lang="EN-US" style="font-family: 宋体;">10.5.5<a href="#_10.5.5%CD%F2%D3%C3%B9%E6%D4%F2">万用规则</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 90pt;"><span lang="EN-US" style="font-family: 宋体;">10.5.6<a href="#_10.5.6%C9%BE%B3%FD%D2%FE%BA%AC%B9%E6%D4%F2">删除隐含规则</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">10.6<a href="#_10.6_%B6%A8%D2%E5%D7%EE%D0%C2%C0%E0%D0%CD%B5%C4%C8%B1%CA%A1%B9%E6%D4%F2">定义最新类型的缺省规则</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">10.7<a href="#_10.7_%B9%FD%CA%B1%B5%C4%BA%F3%D7%BA%B9%E6%D4%F2">过时的后缀规则</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">10.8<a href="#_10.8%D2%FE%BA%AC%B9%E6%D4%F2%CB%D1%D1%B0%CB%E3%B7%A8">隐含规则搜寻算法</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 18pt;"><span lang="EN-US" style="font-family: 宋体;">11 <a href="#_11%CA%B9%D3%C3make%B8%FC%D0%C2%B5%B5%B0%B8%CE%C4%BC%FE">使用make更新档案文件</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">11.1<a href="#_11.1%B5%B5%B0%B8%B3%C9%D4%B1%C4%BF%B1%EA">档案成员目标</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">11.2<a href="#_11.2_%D3%C3%D3%DA%B5%B5%B0%B8%B3%C9%D4%B1%C4%BF%B1%EA%B5%C4%D2%FE%BA%AC%B9%E6%D4%F2">档案成员目标的隐含规则</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 90pt;"><span lang="EN-US" style="font-family: 宋体;">11.2.1<a href="#_11.2.1%B8%FC%D0%C2%B5%B5%B0%B8%B5%C4%B7%FB%BA%C5%CB%F7%D2%FD%B1%ED">更新档案成员的符号索引表</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">11.3<a href="#_11.3_%CA%B9%D3%C3%B5%B5%B0%B8%B5%C4%CE%A3%CF%D5">使用档案的危险</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">11.4<a href="#_11.4_%D3%C3%D3%DA%B5%B5%B0%B8%CE%C4%BC%FE%B5%C4%BA%F3%D7%BA%B9%E6%D4%F2">档案文件的后缀规则</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 18pt;"><span lang="EN-US" style="font-family: 宋体;">12 <a href="#_12_GNU_make%B5%C4%CC%D8%B5%E3"><code><span style="">GNU make的特点</span></code></a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 18pt;"><span lang="EN-US" style="font-family: 宋体;">13 <a href="#_13_%B2%BB%BC%E6%C8%DD%D0%D4%BA%CD%C8%A5%B5%F4%B5%C4%CC%D8%B5%E3">不兼容性和失去的特点</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 18pt;"><span lang="EN-US" style="font-family: 宋体;">14 <a href="#_14_makefile%CE%C4%BC%FE%B9%DF%C0%FD">Makefile文件惯例</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">14.1<a href="#_14.1_makefile%CE%C4%BC%FE%B5%C4%CD%A8%D3%C3%B9%DF%C0%FD">makefile文件的通用惯例</a>
<o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">14.2<a href="#_14.2_makefile%CE%C4%BC%FE%D6%D0%B5%C4%B9%A4%BE%DF">makefile文件的工具</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">14.3<a href="#_14.3_%D6%B8%B6%A8%C3%FC%C1%EE%B5%C4%B1%E4%C1%BF">指定命令的变量</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">14.4<a href="#_14.4_%D3%C3%D3%DA%B0%B2%D7%B0%C2%B7%BE%B6%B5%C4%B1%E4%C1%BF">安装路径变量</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">14.5<a href="#_14.5%D3%C3%BB%A7%B1%EA%D7%BC%C4%BF%B1%EA">用户标准目标</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 54pt;"><span lang="EN-US" style="font-family: 宋体;">14.6<a href="#_14.6_%B0%B2%D7%B0%C3%FC%C1%EE%B7%D6%C0%E0">安装命令分类</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 18pt;"><span lang="EN-US" style="font-family: 宋体;">15<a href="#_15_%BF%EC%CB%D9%B2%CE%BF%BC">快速参考</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 18pt;"><span lang="EN-US" style="font-family: 宋体;">16<a href="#_16_make%B2%FA%C9%FA%B5%C4%B4%ED%CE%F3">make产生的错误</a> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 18pt;"><span lang="EN-US" style="font-family: 宋体;">17<a href="#_17_%B8%B4%D4%D3%B5%C4makfile%CE%C4%BC%FE%C0%FD%D7%D3">复杂的Makefile文件例子</a> <o:p></o:p></span></p>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160; </span>附录<span style="">&#160; </span><a href="#_%C3%FB%B4%CA%B7%AD%D2%EB%B6%D4%D5%D5%B1%ED">名词翻译对照表</a><o:p></o:p></span></p>

<h1><a name="_1_Make_概述"></a><span lang="EN-US" style="font-size: 18pt; font-family: 宋体;">1 Make 概述<o:p></o:p></span></h1>

<p class="MsoNormal" style="text-indent: 21.25pt;"><span lang="EN-US" style="font-family: 宋体;">Make 可自动决定一个大程序中哪些文件需要重新编译，并发布重新编译它们的命令。本版本GNU Make使用手册由Richard
M. Stallman and Roland McGrath编著，是从Paul D. Smith撰写的V3.76版本发展过来的。<o:p></o:p></span></p>

<p class="MsoNormal" style="text-indent: 21.25pt;"><span lang="EN-US" style="font-family: 宋体;">GNU Make符合<cite>IEEE Standard 1003.2-1992</cite>
(POSIX.2) 6.2章节的规定。<o:p></o:p></span></p>

<p class="MsoNormal" style="text-indent: 21.25pt;"><span style="font-family: 宋体;">因为<span lang="EN-US">C语言程序更具有代表性，所以我们的例子基于C语言程序，但Make并不是仅仅能够处理C语言程序，它可以处理那些编译器能够在Shell命令下运行的的各种语言的程序。事实上，GNU
Make不仅仅限于程序，它可以适用于任何如果一些文件变化导致另外一些文件必须更新的任务。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21.25pt;"><span style="font-family: 宋体;">如果要使用<span lang="EN-US">Make，必须先写一个称为Makefile的文件，该文件描述程序中各个文件之间的相互关系，并且提供每一个文件的更新命令。在一个程序中，可执行程序文件的更新依靠OBJ文件，而OBJ文件是由源文件编译得来的。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21.25pt;"><span style="font-family: 宋体;">一旦合适的<span lang="EN-US">Makefile文件存在，每次更改一些源文件，在shell命令下简单的键入：<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21.25pt;"><span lang="EN-US" style="font-family: 宋体;">make<o:p></o:p></span></p>

<p class="MsoNormal"><span style="font-family: 宋体;">就能执行所有的必要的重新编译任务。<span lang="EN-US">Make程序根据Makefile文件中的数据和每个文件更改的时间戳决定哪些文件需要更新。对于这些需要更新的文件，Make基于Makefile文件发布命令进行更新，进行更新的方式由提供的命令行参数控制。具体操作请看<b style=""><i>运行Make</i></b>章节。<o:p></o:p></span></span></p>

<h2><a name="_1.1怎样阅读本手册"></a><span lang="EN-US" style="font-family: 宋体;">1.1怎样阅读本手册<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21.25pt;"><span style="font-family: 宋体;">如果您现在对<span lang="EN-US">Make一无所知或者您仅需要了解对make 的普通性介绍，请查阅前几章内容，略过后面的章节。前几章节是普通介绍性内容，后面的章节是具体的专业、技术内容。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21.25pt;"><span style="font-family: 宋体;">如果您对其它<span lang="EN-US">Make程序十分熟悉，请参阅<b style=""><i>GNU Make的特点</i></b>和</span></span><b style=""><i><span style="font-family: 黑体;">不兼容性和失去的特点</span></i></b><span style="font-family: 宋体;">部分，</span><b style=""><i><span lang="EN-US" style="font-family: 黑体;">GNU Make的特点</span></i></b><span style="font-family: 宋体;">这一章列出了<span lang="EN-US">GNU Make对make程序的扩展，<b style=""><i>不兼容和失去的特点</i></b>一章解释了其它Make程序有的特征而GNU Make缺乏的原因。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21.25pt;"><span style="font-family: 宋体;">对于快速浏览者，请参阅<b style=""><i>选项概要、快速参考</i></b>和<b style=""><i>内建的特殊目标名</i></b>部分。<span lang="EN-US"><o:p></o:p></span></span></p>

<h2><a name="_1.2问题和BUG"></a><span lang="EN-US" style="font-family: 宋体;">1.2问题和BUG<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21.25pt;"><span style="font-family: 宋体;">如果您有关于<span lang="EN-US">GNU
Make的问题或者您认为您发现了一个BUG，请向开发者报告；我们不能许诺我们能干什么，但我们会尽力修正它。在报告BUG之前，请确定您是否真正发现了BUG，仔细研究文档后确认它是否真的按您的指令运行。如果文档不能清楚的告诉您怎么做，也要报告它，这是文档的一个BUG。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21.25pt;"><span style="font-family: 宋体;">在您报告或者自己亲自修正<span lang="EN-US">BUG之前，请把它分离出来，即在使问题暴露的前提下尽可能的缩小Makefile文件。然后把这个Makefile文件和Make给出的精确结果发给我们。同时请说明您希望得到什么，这可以帮助我们确定问题是否出在文档上。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21.25pt;"><span style="font-family: 宋体;">一旦您找到一个精确的问题，请给我们发<span lang="EN-US">E-mail，我们的E-mail地址是：<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21.25pt;"><span lang="EN-US" style="font-family: 宋体;"><a href="mailto:bug-make@gnu.org">bug-make@gnu.org</a><o:p></o:p></span></p>

<p class="MsoNormal" style="text-indent: 21.25pt;"><span style="font-family: 宋体;">在邮件中请包含您使用的<span lang="EN-US">GNU Make的版本号。您可以利用命令‘make--version’得到版本号。同时希望您提供您的机器型号和操作系统类型，如有可能的话，希望同时提供config.h文件（该文件有配置过程产生）。<o:p></o:p></span></span></p>

<h1><a name="_2_Makefile文件介绍"></a><span lang="EN-US" style="font-size: 18pt; font-family: 宋体;">2 Makefile文件介绍<o:p></o:p></span></h1>

<p class="MsoNormal" style="text-indent: 21.25pt;"><span lang="EN-US" style="font-family: 宋体;">Make程序需要一个所谓的Makefile文件来告诉它干什么。在大多数情况下，Makefile文件告诉Make怎样编译和连接成一个程序。<o:p></o:p></span></p>

<p class="MsoNormal" style="text-indent: 21.25pt;"><span style="font-family: 宋体;">本章我们将讨论一个简单的<span lang="EN-US">Makefile文件，该文件描述怎样将8个C源程序文件和3个头文件编译和连接成为一个文本编辑器。Makefile文件可以同时告诉Make怎样运行所需要的杂乱无章的命令（例如，清除操作时删除特定的文件）。如果要看更详细、复杂的Makefile文件例子，请参阅<b style=""><i>复杂的Makefile文件例子</i></b>一章。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21.25pt;"><span style="font-family: 宋体;">当<span lang="EN-US">Make重新编译这个编辑器时，所有改动的C语言源文件必须重新编译。如果一个头文件改变，每一个包含该头文件的C语言源文件必须重新编译，这样才能保证生成的编辑器是所有源文件更新后的编辑器。每一个C语言源文件编译后产生一个对应的OBJ文件，如果一个源文件重新编译，所有的OBJ文件无论是刚刚编译得到的或原来编译得到的必须从新连接，形成一个新的可执行文件。<o:p></o:p></span></span></p>

<h2><a name="_2.1_规则的样式"></a><span lang="EN-US" style="font-family: 宋体;">2.1 规则的格式<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21.25pt;"><span style="font-family: 宋体;">一个简单的<span lang="EN-US">Makefile文件包含一系列的“规则”，其样式如下：<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21.25pt;"><span style="font-family: 宋体;">目标<span lang="EN-US">(target)…: 依赖(prerequiries)…<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21.25pt;"><span lang="EN-US" style="font-family: 宋体;">&lt;tab&gt;命令(command)<o:p></o:p></span></p>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>…<o:p></o:p></span></p>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>…<o:p></o:p></span></p>

<p class="MsoNormal" style="text-indent: 21.25pt;"><span style="font-family: 宋体;">目标<span lang="EN-US">(target)通常是要产生的文件的名称，目标的例子是可执行文件或OBJ文件。目标也可是一个执行的动作名称，诸如‘clean’（详细内容请参阅</span></span><b style=""><i><span style="font-family: 黑体;">假想目标</span></i></b><span style="font-family: 宋体;">一节）。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21.25pt;"><span style="font-family: 宋体;">依赖是用来输入从而产生目标的文件，一个目标经常有几个依赖。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21.25pt;"><span style="font-family: 宋体;">命令是<span lang="EN-US">Make执行的动作，一个规则可以含有几个命令，每个命令占一行。</span></span><b style=""><span style="font-size: 12pt; font-family: 宋体;">注意：</span></b><b style=""><span style="font-family: 宋体;">每个命令行前面必须是一个<span lang="EN-US">Tab字符，即命令行第一个字符是Tab。</span></span></b><span style="font-family: 宋体;">这是不小心容易出错的地方。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21.25pt;"><span style="font-family: 宋体;">通常，如果一个依赖发生变化，则需要规则调用命令对相应依赖和服务进行处理从而更新或创建目标。但是，指定命令更新目标的规则并不都需要依赖，例如，包含和目标‘<span lang="EN-US">clern’相联系的删除命令的规则就没有依赖。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21.25pt;"><span style="font-family: 宋体;">规则一般是用于解释怎样和何时重建特定文件的，这些特定文件是这个详尽规则的目标。<span lang="EN-US">Make需首先调用命令对依赖进行处理，进而才能创建或更新目标。当然，一个规则也可以是用于解释怎样和何时执行一个动作，详见<b style=""><i>编写规则</i></b>一章。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21.25pt;"><span style="font-family: 宋体;">一个<span lang="EN-US">Makefile文件可以包含规则以外的其它文本，但一个简单的Makefile文件仅仅需要包含规则。虽然真正的规则比这里展示的例子复杂，但格式却是完全一样。<o:p></o:p></span></span></p>

<h2><a name="_2.2一个简单的Makefile文件"></a><span lang="EN-US" style="font-family: 宋体;">2.2一个简单的Makefile文件<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21.25pt;"><span style="font-family: 宋体;">一个简单的<span lang="EN-US">Makefile文件，该文件描述了一个称为文本编辑器（edit）的可执行文件生成方法，该文件依靠8个OBJ文件（.o文件），它们又依靠8个C源程序文件和3个头文件。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21.25pt;"><span style="font-family: 宋体;">在这个例子中，所有的<span lang="EN-US">C语言源文件都包含‘defs.h’ 头文件，但仅仅定义编辑命令的源文件包含‘command.h’头文件，仅仅改变编辑器缓冲区的低层文件包含‘buffer.h’头文件。<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">edit : main.o kbd.o command.o display.o \<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160; </span>insert.o search.o files.o utils.o<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>cc -o edit main.o kbd.o command.o display.o \<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>insert.o search.o files.o utils.o<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">main.o : main.c defs.h<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>cc -c main.c<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">kbd.o : kbd.c defs.h command.h<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>cc -c kbd.c<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">command.o : command.c defs.h command.h<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>cc -c command.c<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">display.o : display.c defs.h buffer.h<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>cc -c display.c<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">insert.o : insert.c defs.h buffer.h<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>cc -c insert.c<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">search.o : search.c defs.h buffer.h<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>cc -c search.c<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">files.o : files.c defs.h buffer.h command.h<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>cc -c files.c<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">utils.o : utils.c defs.h<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>cc -c utils.c<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">clean :<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>rm edit main.o kbd.o command.o display.o \<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>insert.o search.o files.o utils.o<o:p></o:p></span></pre>

<p class="MsoNormal" style="text-indent: 21.25pt;"><span style="font-family: 宋体;">我们把每一个长行使用反斜杠<span lang="EN-US">-新行法分裂为两行或多行，实际上它们相当于一行，这样做的意图仅仅是为了阅读方便。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21.25pt;"><span style="font-family: 宋体;">使用<span lang="EN-US">Makefile文件创建可执行的称为‘edit’的文件，键入：make<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21.25pt;"><span style="font-family: 宋体;">使用<span lang="EN-US">Makefile文件从目录中删除可执行文件和目标，键入：make clean<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21.25pt;"><span style="font-family: 宋体;">在这个<span lang="EN-US">Makefile文件例子中，目标包括可执行文件‘edit’和OBJ文件‘main.o’及‘kdb.o’。依赖是C语言源文件和C语言头文件如‘main.c’和‘def.h’等。事实上，每一个OBJ文件即是目标也是依赖。所以命令行包括‘cc
-c main.c’和‘cc -c kbd.c’。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21.25pt;"><span style="font-family: 宋体;">当目标是一个文件时，如果它的任一个依赖发生变化，目标必须重新编译和连接。任何命令行的第一个字符必须是‘<span lang="EN-US">Tab’字符，这样可以把Makefile文件中的命令行与其它行分别开来。（<b style="">一定要牢记：Make并不知道命令是如何工作的，它仅仅能向您提供保证目标的合适更新的命令。Make的全部工作是当目标需要更新时，按照您制定的具体规则执行命令。</b>）<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21.25pt;"><span style="font-family: 宋体;">目标‘<span lang="EN-US">clean’不是一个文件，仅仅是一个动作的名称。正常情况下，在规则中‘clean’这个动作并不执行，目标‘clean’也不需要任何依赖。一般情况下，除非特意告诉make执行‘clean’命令，否则‘clean’命令永远不会执行。注意这样的规则不需要任何依赖，它们存在的目的仅仅是执行一些特殊的命令。象这些不需要依赖仅仅表达动作的目标称为假想目标。详细内容参见<b style=""><i>假想目标</i></b>；参阅</span></span><b style=""><i><span style="font-family: 宋体;">命令错</span></i></b><b style=""><i><span style="font-family: 宋体;">误</span></i></b><span style="font-family: 宋体;">可以了解<span lang="EN-US">rm或其它命令是怎样导致make忽略错误的。<o:p></o:p></span></span></p>

<h2><a name="_2.3_make是处理makefile文件的过程"></a><span lang="EN-US" style="font-family: 宋体;">2.3 make处理makefile文件的过程<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21.25pt;"><span style="font-family: 宋体;">缺省情况下，<span lang="EN-US">make开始于第一个目标（假想目标的名称前带‘.’）。这个目标称为缺省最终目标（即make最终更新的目标，具体内容请看<b style=""><i>指定最终目标的参数</i></b>一节）。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21.25pt;"><span style="font-family: 宋体;">在上节的简单例子中，缺省最终目标是更新可执行文件‘<span lang="EN-US">edit’，所以我们将该规则设为第一规则。这样，一旦您给出命令：<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21.25pt;"><span lang="EN-US" style="font-family: 宋体;">make<o:p></o:p></span></p>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;">make就会读当前目录下的makefile文件，并开始处理第一条规则。在本例中，第一条规则是连接生成‘edit’，但在make全部完成本规则工作之前，必须先处理‘edit’所依靠的OBJ文件。这些OBJ文件按照各自的规则被处理更新，每个OBJ文件的更新规则是编译其源文件。重新编译根据其依靠的源文件或头文件是否比现存的OBJ文件更‘新’，或者OBJ文件是否存在来判断。<o:p></o:p></span></p>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160; </span>其它规则的处理根据它们的目标是否和缺省最终目标的依赖相关联来判断。如果一些规则和缺省最终目标无任何关联则这些规则不会被执行，除非告诉Make强制执行（如输入执行make
clean命令）。<o:p></o:p></span></p>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160; </span>在OBJ文件重新编译之前，Make首先检查它的依赖C语言源文件和C语言头文件是否需要更新。如果这些C语言源文件和C语言头文件不是任何规则的目标，make将不会对它们做任何事情。Make也可以自动产生C语言源程序，这需要特定的规则，如可以根据Bison或Yacc产生C语言源程序。<o:p></o:p></span></p>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160; </span>在OBJ文件重新编译（如果需要的话）之后，make决定是否重新连接生成edit可执行文件。如果edit可执行文件不存在或任何一个OBJ文件比存在的edit可执行文件‘新’，则make重新连接生成edit可执行文件。<o:p></o:p></span></p>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160; </span>这样，如果我们修改了‘insert.c’文件，然后运行make，make将会编译‘insert.c’文件更新‘insert.o’文件，然后重新连接生成edit可执行文件。如果我们修改了‘command.h’文件，然后运行make，make将会重新编译‘kbd.o’和‘command.o’文件，然后重新连接生成edit可执行文件。<o:p></o:p></span></p>

<h2><a name="_2.4使用变量简化makefile文件"></a><span lang="EN-US" style="font-family: 宋体;">2.4使用变量简化makefile文件<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">在我们的例子中，我们在‘<span lang="EN-US">edit’的生成规则中把所有的OBJ文件列举了两次，这里再重复一遍：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">edit : main.o kbd.o command.o display.o \<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160; </span>insert.o search.o files.o utils.o<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>cc -o edit main.o kbd.o command.o display.o \<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>insert.o search.o files.o utils.o<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">这样的两次列举有出错的可能，例如在系统中加入一个新的<span lang="EN-US">OBJ文件，我们很有可能在一个需要列举的地方加入了，而在另外一个地方却忘记了。我们使用变量可以简化makefile文件并且排除这种出错的可能。变量是定义一个字符串一次，而能在多处替代该字符串使用（具体内容请阅读</span></span><b style=""><i><span style="font-family: 黑体;">使用变量</span></i></b><span style="font-family: 宋体;">一节）。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">在<span lang="EN-US">makefile文件中使用名为<code><span style="">objects</span></code>, <code><span style="">OBJECTS</span></code>,
<code><span style="">objs</span></code>,
<code><span style="">OBJS</span></code>,
<code><span style="">obj</span></code>,
或 <code><span style="">OBJ的变量代表所有OBJ文件已是约定成俗。</span></code>在这个makefile文件<code><span style="">我们定义了名为objects的变量，其定义格式如下：<o:p></o:p></span></code></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">objects = main.o kbd.o command.o display.o \<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>insert.o search.o files.o utils.o<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">然后，在每一个需要列举<code><span lang="EN-US" style="">OBJ文件的地方，我们使用写为</span></code><samp><span lang="EN-US" style="">`$(objects)'形式的变量代替</span></samp>（具体内容请阅读</span><b style=""><i><span style="font-family: 黑体;">使用变量</span></i></b><span style="font-family: 宋体;">一节）<samp><span style="">。下面是使用变量后的完整的</span></samp><span lang="EN-US">makefile文件：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">objects = main.o kbd.o command.o display.o \<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>insert.o search.o files.o utils.o<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">edit : $(objects)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>cc -o edit $(objects)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">main.o : main.c defs.h<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>cc -c main.c<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">kbd.o : kbd.c defs.h command.h<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>cc -c kbd.c<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">command.o : command.c defs.h command.h<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>cc -c command.c<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">display.o : display.c defs.h buffer.h<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>cc -c display.c<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">insert.o : insert.c defs.h buffer.h<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>cc -c insert.c<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">search.o : search.c defs.h buffer.h<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>cc -c search.c<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">files.o : files.c defs.h buffer.h command.h<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160; </span><span style="">&#160;&#160;&#160;&#160;</span>cc -c files.c<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">utils.o : utils.c defs.h<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>cc -c utils.c<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">clean :<o:p></o:p></span></pre>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>rm
edit $(objects)<o:p></o:p></span></p>

<h2><a name="_2.5_让make推断命令"></a><span lang="EN-US" style="font-family: 宋体;">2.5 让make推断命令<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">编译单独的<span lang="EN-US">C语言源程序并不需要写出命令，因为make可以把它推断出来：make有一个使用‘CC Cc’命令的把C语言源程序编译更新为相同文件名的OBJ文件的隐含规则。例如make可以自动使用‘<samp><span style="">cc -c main.c -o main.o’命令把‘</span></samp><tt><span style="">main.c’</span></tt><samp><span style="">编译</span></samp> ‘<tt><span style="">main.o’。因此，我们可以省略OBJ文件的更新规则。详细内容请看<b style=""><i>使用隐含规则</i></b>一节。<o:p></o:p></span></tt></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><tt><span style="font-family: 宋体;">如果</span></tt><span lang="EN-US" style="font-family: 宋体;">C语言源程序能够这样自动编译，则它同样能够自动加入到依赖中。所以我们可在依赖中省略C语言源程序，进而可以省略命令。下面是使用隐含规则和变量objects的完整makefile文件的例子：<o:p></o:p></span></p>

<pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">objects = main.o kbd.o command.o display.o \<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>insert.o search.o files.o utils.o<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">edit : $(objects)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>cc -o edit $(objects)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">main.o : defs.h<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">kbd.o : defs.h command.h<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">command.o : defs.h command.h<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">display.o : defs.h buffer.h<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">insert.o : defs.h buffer.h<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">search.o : defs.h buffer.h<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">files.o : defs.h buffer.h command.h<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">utils.o : defs.h<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">.PHONY : clean<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">clean :<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>-rm edit $(objects)</span><span lang="EN-US" style="font-family: 宋体;"><o:p></o:p></span></pre>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">这是我们实际编写<span lang="EN-US">makefile文件的例子。（和目标‘clean’联系的复杂情况在别处阐述。具体参见<b style=""><i>假想目标</i></b>及<b style=""><i>命令错误</i></b>两节内容。）因为隐含规则十分方便，所以它们非常重要，在makefile文件中经常使用它们。<o:p></o:p></span></span></p>

<h2><a name="_2.6_另一种风格的makefile文件"></a><span lang="EN-US" style="font-family: 宋体;">2.6 另一种风格的makefile文件<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">当时在<span lang="EN-US">makefile文件中使用隐含规则创建OBJ文件时，采用另一种风格的makefile文件也是可行的。在这种风格的makefile文件中，可以依据依赖分组代替依据目标分组。下面是采用这种风格的makefile文件：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">o</span><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">bjects = main.o kbd.o command.o display.o \<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>insert.o search.o files.o utils.o<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">edit : $(objects)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>cc -o edit $(objects)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">$(objects) : defs.h<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">kbd.o command.o files.o : command.h<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">display.o insert.o search.o files.o : buffer.h</span><span lang="EN-US" style="font-family: 宋体;"><o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">这里的<span lang="EN-US">defs.h是所有OBJ文件的共同的一个依赖；command.h和bufffer.h是具体列出的OBJ文件的共同依赖。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">虽然采用这种风格编写<span lang="EN-US">makefile文件更具风味：makefile文件更加短小，但一部分人以为把每一个目标的信息放到一起更清晰易懂而不喜欢这种风格。<o:p></o:p></span></span></p>

<h2><a name="_2.7_在目录中删除文件的规则"></a><span lang="EN-US" style="font-family: 宋体;">2.7 在目录中删除文件的规则<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">编译程序并不是编写<span lang="EN-US">make规则的唯一事情。Makefile文件可以告诉make去完成编译程序以外的其它任务，例如，怎样删除OBJ文件和可执行文件以保持目录的‘干净’等。下面是删除利用make规则编辑器的例子：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">clean:<o:p></o:p></span></pre>

<p class="MsoNormal" style="text-indent: 21pt;"><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>rm edit $(objects)<o:p></o:p></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">在实际应用中，应该编写较为复杂的规则以防不能预料的情况发生。更接近实用的规则样式如下：<span lang="EN-US"><o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">.PHONY : clean<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">clean :<o:p></o:p></span></pre>

<p class="MsoNormal" style="text-indent: 21pt;"><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>-rm edit $(objects)<o:p></o:p></span></p>

<p class="MsoNormal"><span style="font-family: 宋体;">这样可以防止<span lang="EN-US">make因为存在名为’clean’的文件而发生混乱，并且导致它在执行rm命令时发生错误（具体参见<b style=""><i>假想目标</i></b>及<b style=""><i>命令错误</i></b>两节内容）。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">诸如这样的规则不能放在<span lang="EN-US">makefile文件的开始，因为我们不希望它变为缺省最终目标。应该象我们的makefile文件例子一样，把关于edit的规则放在前面，从而把编译更新edit可执行程序定为缺省最终目标。<o:p></o:p></span></span></p>

<h1><a name="_3_编写makefile文件"></a><span lang="EN-US" style="font-size: 18pt; font-family: 宋体;">3 编写makefile文件<o:p></o:p></span></h1>

<p class="MsoNormal" style="text-indent: 21pt;"><span lang="EN-US" style="font-family: 宋体;">make编译系统依据的信息来源于称为makefile文件的数据库。<o:p></o:p></span></p>

<h2><a name="_3.1_makefile文件的内容"></a><span lang="EN-US" style="font-family: 宋体;">3.1
makefile文件的内容<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21.25pt;"><span lang="EN-US" style="font-family: 宋体;">makefile文件包含5方面内容：具体规则、隐含规则、定义变量、指令和注释。规则、变量和指令将在后续章节介绍。<o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 42.25pt; text-indent: -21pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: Wingdings;">l<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><!--[endif]--><b style=""><span style="font-family: 宋体;">具体规则</span></b><span style="font-family: 宋体;">用于阐述什么时间或怎样重新生成称为规则目标的一个或多个文件的。它列举了目标所依靠的文件，这些文件称为该目标的依赖。具体规则可能同时提供了创建或更新该目标的命令。详细内容参阅<b style=""><i>编写规则</i></b>一章。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 42.25pt; text-indent: -21pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: Wingdings;">l<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><!--[endif]--><b><span style="font-family: 宋体;">隐含规则</span></b><span style="font-family: 宋体;">用于阐述什么时间或怎样重新生成同一文件名的一系列文件的。它描述的目标是根据和它名字相同的文件进行创建或更新的，同时提供了创建或更新该目标的命令。详细内容参阅<b style=""><i>使用隐含规则</i></b>一节。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 42.25pt; text-indent: -21pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: Wingdings;">l<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><!--[endif]--><span style="font-family: 宋体;">定义变量是为一个变量赋一个固定的字符串值，从而在以后的文件中能够使用该变量代替这个字符串。注意在<span lang="EN-US">makefile文件中定义变量占一独立行。在上一章的makefile文件例子中我们定义了代表所有OBJ文件的变量objects（详细内容参阅<b style=""><i>使用变量简化makefile文件</i></b>一节）。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 42.25pt; text-indent: -21pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: Wingdings;">l<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><!--[endif]--><span style="font-family: 宋体;">指令是<span lang="EN-US">make根据makefile文件执行一定任务的命令。这些包括如下几方面:<o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 63.25pt; text-indent: -21pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: Wingdings;">n<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><!--[endif]--><span style="font-family: 宋体;">读其它<span lang="EN-US">makefile文件（详细内容参见<b style=""><i>包含其它的makefile文件</i></b>）。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 63.25pt; text-indent: -21pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: Wingdings;">n<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><!--[endif]--><span style="font-family: 宋体;">判定（根据变量的值）是否使用或忽略<span lang="EN-US">makefile文件的部分内容（详细内容参阅<b style=""><i>makefile文件的条件语句</i></b>一节）。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 63.25pt; text-indent: -21pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: Wingdings;">n<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><!--[endif]--><span style="font-family: 宋体;">定义多行变量，即定义变量值可以包含多行字符的变量（详细内容参见<b style=""><i>定义多行变量</i></b>一节）。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 42.25pt; text-indent: -21pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: Wingdings;">l<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><!--[endif]--><span style="font-family: 宋体;">以‘<span lang="EN-US">#’开始的行是注释行。注释行在处理时将被make忽略，如果一个注释行在行尾是‘\’则表示下一行继续为注释行，这样注释可以持续多行。除在define指令内部外，注释可以出现在makefile文件的任何地方，甚至在命令内部（这里shell决定什么是注释内容）。<o:p></o:p></span></span></p>

<h2><a name="_3.2_makfile文件名字的规定"></a><span lang="EN-US" style="font-family: 宋体;">3.2
makfile文件的命名<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">缺省情况下，当<span lang="EN-US">make寻找makefile文件时，它试图搜寻具有如下的名字的文件，按顺序：‘GNUmakefile’、‘makefile’和‘Makefile’。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">通常情况下您应该把您的<span lang="EN-US">makefile文件命名为‘makefile’或‘Makefile’。(我们推荐使用‘Makefile’，因为它基本出现在目录列表的前面，后面挨着其它重要的文件如‘README’等。)。虽然首先搜寻‘GNUmakefile’，但我们并不推荐使用。除非您的makefile文件是特为GNU
make编写的，在其它make版本上不能执行，您才应该使用‘GNUmakefile’作为您的makefile的文件名。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">如果<span lang="EN-US">make不能发现具有上面所述名字的文件，它将不使用任何makefile文件。这样您必须使用命令参数给定目标，make试图利用内建的隐含规则确定如何重建目标。详细内容参见<b style=""><i>使用隐含规则</i></b>一节。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">如果您使用非标准名字<span lang="EN-US">makefile文件，您可以使用‘-f’或‘--file’参数指定您的makefile文件。参数‘-f
name’或‘--file=name’能够告诉make读名字为‘name’的文件作为makefile文件。如果您使用
‘-f’或‘--file’参数多于一个，意味着您指定了多个makefile文件，所有的makefile文件按具体的顺序发生作用。一旦您使用了‘-f’或‘--file’参数，将不再自动检查是否存在名为‘GNUmakefile’、‘makefile’或‘Makefile’的makefile文件。<o:p></o:p></span></span></p>

<h2><a name="_3.3_包含其它的makefile文件"></a><span lang="EN-US" style="font-family: 宋体;">3.3 包含其它的makefile文件<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span lang="EN-US" style="font-family: 宋体;">include指令告诉make暂停读取当前的makefile文件，先读完include指令指定的makefile文件后再继续。指令在makefile文件占单独一行，其格式如下：<o:p></o:p></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span lang="EN-US" style="font-family: 宋体;">include <var>filenames</var>...<o:p></o:p></span></p>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;">filenames可以包含shell文件名的格式。<o:p></o:p></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">在<span lang="EN-US">include指令行，行开始处的多余的空格是允许的，但make处理时忽略这些空格，注意该行不能以Tab字符开始（因为，以Tab字符开始的行，make认为是命令行）。include和文件名之间以空格隔开，两个文件名之间也以空格隔开，多余的空格make处理时忽略，在该行的尾部可以加上以‘#’为起始的注释。文件名可以包含变量及函数调用，它们在处理时由make进行扩展（具体内容参阅<b style=""><i>使用变量</i></b>一节）。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">例如，有三个‘<span lang="EN-US">.mk’文件：‘a.mk’、‘b.mk’和‘c.mk’，变量$(bar)扩展为bish bash，则下面的表达是：<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span lang="EN-US" style="font-family: 宋体;">include foo *.mk $(bar)<o:p></o:p></span></p>

<p class="MsoNormal"><span style="font-family: 宋体;">和‘<span lang="EN-US">include foo
a.mk b.mk c.mk bish bash’等价。<o:p></o:p></span></span></p>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160; </span>当make遇见include指令时， make就暂停读取当前的makefile文件，依次读取列举的makefile文件，读完之后，make再继续读取当前makefile文件中include指令以后的内容。<o:p></o:p></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">使用<span lang="EN-US">include指令的一种情况是几个程序分别有单独的makefile文件，但它们需要一系列共同的变量定义（详细内容参阅<b style=""><i>设置变量</i></b>），或者一系列共同的格式规则（详细内容参阅<b style=""><i>定义与重新定义格式规则</i></b>）。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">另一种使用<span lang="EN-US">include指令情况是需要自动从源文件为目标产生依赖的情况，此时，依赖在主makefile文件包含的文件中。这种方式比其它版本的make把依赖附加在主makefile文件后部的传统方式更显得简洁。具体内容参阅<b style=""><i>自动产生依赖</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">如果<span lang="EN-US">makefile文件名不以‘/’开头，并且在当前目录下也不能找到，则需搜寻另外的目录。首先，搜寻以‘-|’或‘--include-dir’参数指定的目录，然后依次搜寻下面的目录（如果它们存在的话）：<tt><span style="">‘</span></tt><var>prefix</var><tt><span style="">/include'</span></tt>
(通常为 <tt><span style="">‘/usr/local/include'</span></tt>)
<tt><span style="">‘/usr/gnu/include'</span></tt>,
<tt><span style="">‘/usr/local/include'</span></tt>,
<tt><span style="">‘/usr/include'。<o:p></o:p></span></tt></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><tt><span style="font-family: 宋体;">如果指定包含的</span></tt><span lang="EN-US" style="font-family: 宋体;">makefile<tt><span style="">文件在上述所有的目录都不能找到，make将产生一个警告信息，注意这不是致命的错误。处理完include指令包含的makefile文件之后，继续处理当前的makefile文件。一旦完成makefile文件的读取操作，make将试图创建或更新过时的或不存在的makefile文件。详细内容参阅<b style=""><i>makefile文件重新生成的过程</i></b>。只有在所有make寻求丢失的makefile文件的努力失败后，make才能断定丢失的makefile文件是一个致命的错误。<o:p></o:p></span></tt></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><tt><span style="font-family: 宋体;">如果您希望对不存在且不能重新创建的<span lang="EN-US">makefile文件进行忽略，并且不产生错误信息，则使用-include指令代替include指令，格式如下：<o:p></o:p></span></span></tt></p>

<pre><span lang="EN-US" style="font-family: 宋体;">-include <var>filenames</var>...<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">这种指令的作用就是对于任何不存在的<tt><span lang="EN-US" style="">makefile文件都不会产生错误（即使警告信息也不会产生）。如果希望保持和其它版本的make兼容，使用sinclude指令代替-include指令。<o:p></o:p></span></tt></span></p>

<h2><a name="_3.4_环境变量makefiles"></a><span lang="EN-US" style="font-family: 宋体;">3.4
变量MAKEFILES<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">如果定义了环境变量</span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">MAKEFILES</span></code><span style="font-family: 宋体;">，<span lang="EN-US">make认为该变量的值是一列附加的makefile文件名，文件名之间由空格隔开，并且这些makefile文件应首先读取。Make完成这个工作和上节完成include指令的方式基本相同，即在特定的目录中搜寻这些文件。值得注意的是，缺省最终目标不会出现在这些makefile文件中，而且如果一些makefile文件没有找到也不会出现任何错误信息。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">环境变量</span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">MAKEFILES</span></code><span style="font-family: 宋体;">主要在<span lang="EN-US">make递归调用过程中起通讯作用（详细内容参阅<b style=""><i>递归调用make</i></b>）。在make顶级调用之前设置环境变量并不是十分好的主意，因为这样容易将makefile文件与外界的关系弄的更加混乱。然而如果运行make而缺少makefile文件时，环境变量</span></span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">MAKEFILES</span></code><span style="font-family: 宋体;">中<span lang="EN-US">makefile文件可以使内置的隐含规则更好的发挥作用，如搜寻定义的路径等（详细内容参阅<b style=""><i>在目录中搜寻依赖</i></b>）。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">一些用户喜欢在登录时自动设置临时的环境变量</span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">MAKEFILES</span></code><span style="font-family: 宋体;">，而<span lang="EN-US">makefile文件在该变量指定的文件无效时才使用。这是非常糟糕的主意，应为许多makefile文件在这种情况下运行失效。最好的方法是直接在makefile文件中写出具体的include指令(详细内容参看上一节)。<o:p></o:p></span></span></p>

<h2><a name="_3.5_makefile文件重新生成的过程"></a><span lang="EN-US" style="font-family: 宋体;">3.5 makefile文件重新生成的过程<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">有时<span lang="EN-US">makefile文件可以由其它文件重新生成，如从RCS或SCCS文件生成等。如果一个makefile文件可以从其它文件重新生成，一定注意让make更新makefile文件之后再读取makefile文件。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">完成读取所有的<span lang="EN-US">makefile文件之后，make检查每一个目标，并试图更新它。如果对于一个makefile文件有说明它怎样更新的规则（无论在当前的makefile文件中或其它makefile文件中），或者存在一条隐含规则说明它怎样更新（具体内容参见<b style=""><i>使用隐含规则</i></b>），则在必要的时候该makefile文件将会自动更新。在所有的makefile文件检查之后，如果发现任何一个makefile文件发生变化，make就会清空所有记录，并重新读入所有makefile文件。（然后再次试图更新这些makefile文件，正常情况下，因为这些makefile文件已被更新，make将不会再更改它们。）<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">如果您知道您的一个或多个<span lang="EN-US">makefile文件不能重新创建，也许由于执行效率缘故，您不希望make按照隐含规则搜寻或重建它们，您应使用正常的方法阻止按照隐含规则检查它们。例如，您可以写一个具体的规则，把这些makefile文件当作目标，但不提供任何命令（详细内容参阅<b style=""><i>使用空命令</i></b>）。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">如果在<span lang="EN-US">makefile文件中指定依据双冒号规则使用命令重建一个文件，但没有提供依赖，则一旦make运行就会重建该文件（详细内容参见<b style=""><i>双冒号规则</i></b>）。同样，如果在makefile文件中指定依据双冒号规则使用命令重建的一个makefile文件，并且不提供依赖，则一旦make运行就会重建该makefile文件，然后重新读入所有makefile文件，然后再重建该makefile文件，再重新读入所有makefile文件，如此往复陷入无限循环之中，致使make不能再完成别的任务。如果要避免上述情况的发生，<b style="">一定注意不要依据双冒号规则使用命令并且不提供依赖重建任何makefile文件。</b><o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">如果您没有使用‘<span lang="EN-US">-f’或‘--file’指定makefile文件，make将会使用缺省的makefile文件名（详细内容参见3.2节内容）。不象使用‘-f’或‘--file’选项指定具体的makefile文件，这时make不能确定makefile文件是否存在。如果缺省的makefile文件不存在，但可以由运行的make依据规则创建，您需要运行这些规则，创建要使用的makefile文件。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">如果缺省的<span lang="EN-US">makefile文件不存在，make将会按照搜寻的次序将它们试着创建，一直到将makefile文件成功创建或make将所有的文件名都试过来。注意make不能找到或创建makefile文件不是错误，makefile文件并不是运行make必须的。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">因为即使您使用‘<span lang="EN-US">-t’特别指定，‘-t’或‘--touch’选项对更新makefile文件不产生任何影响， makefile文件仍然会更新，所以当您使用‘-t’或‘--touch’选项时，您不要使用过时的makefile文件来决定‘touch’哪个目标（具体含义参阅<b style=""><i>代替执行命令</i></b>）。同样，因为<samp><span style="">‘-q'</span></samp> (或 <samp><span style="">‘--question'</span></samp>) 和 <samp><span style="">‘-n'</span></samp> (或 <samp><span style="">‘--just-print'</span></samp>)也能不阻止更新makefile文件，所以过时的makefile文件对其它的目标将产生错误的输出结果。如，‘<samp><span style="">make -f mfile -n foo’命令将这样执行：更新‘mfile’，然后读入，再输出更新‘foo’的命令和依赖，但并不执行更新‘foo’，注意，所有回显的更新‘foo’的命令是在更新后的‘mfile’中指定的。<o:p></o:p></span></samp></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><samp><span style="font-family: 宋体;">在实际使用过程中，您一定会遇见确实希望阻止更新</span></samp><span lang="EN-US" style="font-family: 宋体;">makefile文件的情况。如果这样，您可以在makefile文件命令行中将需要更新的makefile文件指定为目标，如此则可<samp><span style="">阻止更新</span></samp>makefile文件。一旦makefile文件名被明确指定为一个目标，选项‘-t’等将会对它发生作用。如这样设定，‘<samp><span style="">make -f mfile -n foo’命令将这样执行：读入‘mfile’，输出更新‘foo’的命令和依赖，但并不执行更新‘foo’。回显的更新‘foo’的命令包含在现存的‘mfile’中。<o:p></o:p></span></samp></span></p>

<h2><a name="_3.6_解决其它makefile文件中的冲突"></a><span lang="EN-US" style="font-family: 宋体;">3.6 重载其它makefile文件<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">有时一个<span lang="EN-US">makefile文件和另一个makefile文件相近也是很有用的。您可以使用‘include’指令把更多的makefile文件包含进来，如此可加入更多的目标和定义的变量。然而如果两个makefile文件对相同的目标给出了不同的命令，make就会产生错误。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">在主<span lang="EN-US">makefile文件（要包含其它makefile文件的那个）中，您可以使用通配符格式规则说明只有在依靠当前makefile文件中的信息不能重新创建目标时，make才搜寻其它的makefile文件，详细内容参见<b style=""><i>定义与重新定义格式规则</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">例如：如果您有一个说明怎样创建目标‘<span lang="EN-US">foo’（和其它目标）的makefile文件称为‘Makefile’，您可以编写另外一个称为‘GNUmakefile’的makefile文件包含以下语句：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">foo:<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>frobnicate &gt; foo<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">%: force<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>@$(MAKE) -f Makefile $@<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">force: ;<o:p></o:p></span></pre>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">如果键入‘<span lang="EN-US">make
foo’，make就会找到‘GNUmakefile’，读入，然后运行‘frobnicate &gt; foo’。如果键入‘make
bar’，make发现无法根据‘GNUmakefile’创建‘bar’，它将使用格式规则提供的命令：‘make Cf Makefile
bar’。如果在‘Makefile’中提供了‘bar’更新的规则，make就会使用该规则。对其它‘GNUmakefile’不提供怎样更新的目标make也会同样处理。这种工作的方式是使用了格式规则中的格式匹配符‘%’，它可以和任何目标匹配。该规则指定了一个依赖‘force’，用来保证命令一定要执行，无论目标文件是否存在。我们给出的目标‘force’时使用了空命令，这样可防止make按照隐含规则搜寻和创建它，否则，make将把同样的匹配规则应用到目标‘force’本身，从而陷入创建依赖的循环中。<o:p></o:p></span></span></p>

<h2><a name="_3.7_make读取makefile文件的过程"></a><span lang="EN-US" style="font-family: 宋体;">3.7 make读取makefile文件的过程<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span lang="EN-US" style="font-family: 宋体;">GNU
make把它的工作明显的分为两个阶段。在第一阶段，make读取makefile文件，包括makefile文件本身、内置变量及其值、隐含规则和具体规则、构造所有目标的依靠图表和它们的依赖等。在第二阶段，make使用这些内置的组织决定需要重新构造的目标以及使用必要的规则进行工作。<o:p></o:p></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">了解<span lang="EN-US">make两阶段的工作方式十分重要，因为它直接影响变量、函数扩展方式；而这也是编写makefile文件时导致一些错误的主要来源之一。下面我们将对makefile文件中不同结构的扩展方式进行总结。我们称在make工作第一阶段发生的扩展是立即扩展：在这种情况下，make对makefile文件进行语法分析时把变量和函数直接扩展为结构单元的一部分。我们把不能立即执行的扩展称为延时扩展。延时扩展结构直到它已出现在上下文结构中或make已进入到了第二工作阶段时才执行展开。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">您可能对这一部分内容不熟悉。您可以先看完后面几章对这些知识熟悉后再参考本节内容。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><b style=""><span style="font-size: 12pt; font-family: 宋体;">变量赋值<span lang="EN-US"><o:p></o:p></span></span></b></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">变量的定义语法形式如下：<span lang="EN-US"><o:p></o:p></span></span></p>

<pre><var><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">immediate</span></var><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"> = <var>deferred</var><o:p></o:p></span></pre><pre><var><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">immediate</span></var><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"> ?= <var>deferred</var><o:p></o:p></span></pre><pre><var><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">immediate</span></var><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"> := <var>immediate</var><o:p></o:p></span></pre><pre><var><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">immediate</span></var><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"> += <var>deferred</var> or <var>immediate</var><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">define <var>immediate</var><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><span style="">&#160; </span><var>deferred</var><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">endef<o:p></o:p></span></pre>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">对于附加操作符‘<span lang="EN-US">+=’，右边变量如果在前面使用（:=）定义为简单扩展变量则是立即变量，其它均为延时变量。<o:p></o:p></span></span></p>

<p class="MsoNormal"><b style=""><span style="font-size: 12pt; font-family: 宋体;">条件语句<span lang="EN-US"><o:p></o:p></span></span></b></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">整体上讲，条件语句都按语法立即分析，常用的有：<span lang="EN-US">ifdef、ifeq、ifndef和inneq。<o:p></o:p></span></span></p>

<p class="MsoNormal"><b style=""><span style="font-size: 12pt; font-family: 宋体;">定义规则<span lang="EN-US"><o:p></o:p></span></span></b></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">规则不论其形式如何，都按相同的方式扩展。<span lang="EN-US"><o:p></o:p></span></span></p>

<pre><var><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">immediate</span></var><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"> : <var>immediate</var> ; <var>deferred</var><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span><var>deferred</var><o:p></o:p></span></pre>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">目标和依赖部分都立即扩展，用于构造目标的命令通常都是延时扩展。这个通用的规律对具体规则、格式规则、后缀规则、静态格式规则和简单依赖定义都适用。<span lang="EN-US"><o:p></o:p></span></span></p>

<h1><a name="_4编写规则"></a><span lang="EN-US" style="font-size: 18pt; font-family: 宋体;">4编写规则<o:p></o:p></span></h1>

<p class="MsoNormal" style="text-indent: 21pt;"><span lang="EN-US" style="font-family: 宋体;">makefile文件中的规则是用来说明何时以及怎样重建特定文件的，这些特定的文件称为该规则的目标（通常情况下，每个规则只有一个目标）。在规则中列举的其它文件称为目标的依赖，同时规则还给出了目标创建、更新的命令。一般情况下规则的次序无关紧要，但决定缺省最终目标时却是例外。缺省最终目标是您没有另外指定最终目标时，make认定的最终目标。缺省最终目标是makefile文件中的第一条规则的目标。如果第一条规则有多个目标，只有第一个目标被认为是缺省最终目标。有两种例外的情况：以句点（‘.’）开始的目标不是缺省最终目标（如果该目标包含一个或多个斜杠‘/’，则该目标也可能是缺省最终目标）；另一种情况是格式规则定义的目标不是缺省最终目标（参阅<b style=""><i>定义与重新定义格式规则</i></b>）。<o:p></o:p></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">所以，我们编写<span lang="EN-US">makefile文件时，通常将第一个规则的目标定为编译全部程序或是由makefile文件表述的所有程序（经常设定一个称为‘all’的目标）。参阅<b><i>指定最终目标的参数</i></b>。<o:p></o:p></span></span></p>

<h2><a name="_4.1规则的语法"></a><span lang="EN-US" style="font-family: 宋体;">4.1规则的语法<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">通常一条规则形式如下：<span lang="EN-US"><o:p></o:p></span></span></p>

<pre><var><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">targets</span></var><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"> : <var>prerequisites</var><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span><var>command</var><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>...<o:p></o:p></span></pre>

<p>或：<span lang="EN-US"> </span></p>

<pre><var><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">targets</span></var><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"> : <var>prerequisites</var> ; <var>command</var><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span><var>command</var><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>...<o:p></o:p></span></pre>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">目标（<span lang="EN-US">target）是文件的名称，中间由空格隔开。通配符可以在文件名中使用（参阅<b style=""><i>在文件名中使用通配符</i></b>），‘a（m）’形式的文件名表示成员m在文件a中（参阅<b style=""><i>档案成员目标</i></b>）。一般情况下，一条规则只有一个目标，但偶尔由于其它原因一条规则有多个目标（参阅<b style=""><i>具有多个目标的规则</i></b>）。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">命令行以<span lang="EN-US">Tab字符开始，第一个命令可以和依赖在一行，命令和依赖之间用分号隔开，也可以在依赖下一行，以Tab字符为行的开始。这两种方法的效果一样，参阅<b style=""><i>在规则中使用命令</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">因为美元符号已经用为变量引用的开始符，如果您真希望在规则中使用美元符号，您必须连写两次，‘<span lang="EN-US">$$’（参阅<b style=""><i>使用变量</i></b>）。您可以把一长行在中间插入‘\’使其分为两行，也就是说，一行的尾部是’\’的话，表示下一行是本行的继续行。但这并不是必须的，make没有对makefile文件中行的长度进行限制。一条规则可以告诉make两件事情：何时目标已经过时，以及怎样在必要时更新它们。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">判断目标过时的准则和依赖关系密切，依赖也由文件名构成，文件名之间由空格隔开，通配符和档案成员也允许在依赖中出现。一个目标如果不存在或它比其中一个依赖的修改时间早，则该目标已经过时。该思想来源于目标是根据依赖的信息计算得来的，因此一旦任何一个依赖发生变化，目标文件也就不再有效。目标的更新方式由命令决定。命令由<span lang="EN-US">shell解释执行，但也有一些另外的特点。参阅<b style=""><i>在规则中使用命令</i></b>。<o:p></o:p></span></span></p>

<h2><a name="_4.2_在文件名中使用通配符"></a><span lang="EN-US" style="font-family: 宋体;">4.2 在文件名中使用通配符<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">一个简单的文件名可以通过使用通配符代表许多文件。<span lang="EN-US">Make中的通配符和Bourne shell中的通配符一样是‘*’、‘？’和‘[…]’。例如：‘*.C’指在当前目录中所有以‘.C’结尾的文件。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">字符‘<span lang="EN-US">~’在文件名的前面也有特殊的含义。如果字符‘~’单独或后面跟一个斜杠‘/’，则代表您的home目录。如‘~/bin’扩展为‘/home/bin’。
如果字符‘~’后面跟一个字，它扩展为home目录下以该字为名字的目录，如‘~John/bin’表示‘home/John/bin’。在一些操作系统（如ms-dos，ms-windows）中不存在home目录，可以通过设置环境变量home来模拟。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">在目标、依赖和命令中的通配符自动扩展。在其它上下文中，通配符只有在您明确表明调用通配符函数时才扩展。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">通配符另一个特点是如果通配符前面是反斜杠‘<span lang="EN-US">\’，则该通配符失去通配能力。如‘foo\*bar’表示一个特定的文件其名字由‘foo’、‘*’和‘bar’构成。<o:p></o:p></span></span></p>

<h3><a name="_4.2.1通配符的例子"></a><span lang="EN-US" style="font-size: 14pt; font-family: 宋体;">4.2.1通配符例子<o:p></o:p></span></h3>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160; </span>通配符可以用在规则的命令中，此时通配符由shell扩展。例如，下面的规则删除所有OBJ文件：<o:p></o:p></span></p>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;">clean：<o:p></o:p></span></p>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160; </span>rm Cf<span style="">&#160; </span>*.o<o:p></o:p></span></p>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160; </span>通配符在规则的依赖中也很有用。在下面的makefile规则中，‘make
print’将打印所有从上次您打印以后又有改动的‘.c’文件：<o:p></o:p></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">print: *.c<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>lpr -p $?<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>touch print<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">本规则使用‘<span lang="EN-US">ptint’作为一个空目标文件（参看<b style=""><i>使用空目标文件记录事件</i></b>）；自动变量‘$?’用来打印那些已经修改的文件，参看<b style=""><i>自动变量</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal"><span style="font-family: 宋体;">当您定义一个变量时通配符不会扩展，如果您这样写：<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;">objects = *.o<o:p></o:p></span></p>

<p class="MsoNormal"><span style="font-family: 宋体;">变量<span lang="EN-US">objects的值实际就是字符串‘*.o’。然而，如果您在一个目标、依赖和命令中使用变量objects的值，通配符将在那时扩展。使用下面的语句可使通配符扩展：<o:p></o:p></span></span></p>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;">objects=$(wildcard
*.o)<o:p></o:p></span></p>

<p class="MsoNormal"><span style="font-family: 宋体;">详细内容参阅<b style=""><i>函数<span lang="EN-US">wildcard</span></i></b>。<span lang="EN-US"><o:p></o:p></span></span></p>

<h3><a name="_4.2.2使用通配符的常见错误"></a><span lang="EN-US" style="font-size: 14pt; font-family: 宋体;">4.2.2使用通配符的常见错误<o:p></o:p></span></h3>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">下面有一个幼稚使用通配符扩展的例子，但实际上该例子不能完成您所希望完成的任务。假设可执行文件‘<span lang="EN-US">foo’由在当前目录的所有OBJ文件创建，其规则如下：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">objects = *.o<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">foo : $(objects)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>cc -o foo $(CFLAGS) $(objects)<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">由于变量<span lang="EN-US">objects的值为字符串‘*.o’，通配符在目标‘foo’的规则下扩展，所以每一个OBJ文件都会变为目标‘foo’的依赖，并在必要时重新编译自己。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">但如果您已删除了所有的<span lang="EN-US">OBJ文件，情况又会怎样呢？因没有和通配符匹配的文件，所以目标‘foo’就依靠了一个有着奇怪名字的文件‘*.o’。因为目录中不存在该文件，make将发出不能创建‘*.o’的错误信息。这可不是所要执行的任务。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">实际上，使用通配符获得正确的结果是可能的，但您必须使用稍微复杂一点的技术，该技术包括使用函数<span lang="EN-US">wildcard和替代字符串等。详细内容将在下一节论述。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">微软的操作系统（<span lang="EN-US">MS-DOS、MS-WINDOWS）使用反斜杠分离目录路径，如：<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span lang="EN-US" style="font-family: 宋体;">C:\foo\bar\bar.c<o:p></o:p></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">这和<span lang="EN-US">Unix风格‘c:/foo/bar/bar.c’等价（‘c:’是驱动器字母）。当make在这些系统上运行时，不但支持在路径中存在反斜杠也支持Unix风格的前斜杠。但是这种对反斜杠的支持不包括通配符扩展，因为通配符扩展时，反斜杠用作引用字符。所以，在这些场合您必须使用Unix风格的前斜杠。<o:p></o:p></span></span></p>

<h3><a name="_4.2.3通配符函数"></a><span lang="EN-US" style="font-size: 14pt; font-family: 宋体;">4.2.3函数wildcard<o:p></o:p></span></h3>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">通配符在规则中可以自动扩展，但设置在变量中或在函数的参数中通配符一般不能正常扩展。如果您需要在这些场合扩展通配符，您应该使用函数<span lang="EN-US">wildcard，格式如下：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">$(wildcard <var>pattern</var>...)<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">可以在<span lang="EN-US">makefile文件的任何地方使用该字符串，应用时该字符串被一列在指定目录下存在的并且文件名和给出的文件名的格式相符合的文件所代替，文件名中间由空格隔开。如果没有和指定格式一致的文件，则函数wildcard的输出将会省略。注意这和在规则中通配符扩展的方式不同，在规则中使用逐字扩展方式，而不是省略方式（参阅上节）。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">使用函数<span lang="EN-US">wildcard得到指定目录下所有的C语言源程序文件名的命令格式为：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">$(wildcard *.c)<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">我们可以把所获得的<span lang="EN-US">C语言源程序文件名的字符串通过将‘.c’后缀变为‘.o’转换为OBJ文件名的字符串，其格式为：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">$(patsubst %.c,%.o,$(wildcard *.c))<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">这里我们使用了另外一个函数：<span lang="EN-US">patsubst，详细内容参阅<b style=""><i>字符串替换和分析函数</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">这样，一个编译特定目录下所有<span lang="EN-US">C语言源程序并把它们连接在一起的makefile文件可以写成如下格式：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">objects := $(patsubst %.c,%.o,$(wildcard *.c))<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">foo : $(objects)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>cc -o foo $(objects)<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">这里使用了编译<span lang="EN-US">C语言源程序的隐含规则，因此没有必要为每个文件写具体编译规则。
‘:=’是‘=’的变异，对‘:=’的解释，参阅<b style=""><i>两种风格的变量</i></b>。<o:p></o:p></span></span></p>

<h2><a name="_4.3在不同文件夹中搜寻依赖"></a><span lang="EN-US" style="font-family: 宋体;">4.3在目录中搜寻依赖<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">对于大型系统，把源文件安放在一个单独的目录中，而把二进制文件放在另一个目录中是十分常见的。<span lang="EN-US">Make 的目录搜寻特性使自动在几个目录搜寻依赖十分容易。当您在几个目录中重新安排您的文件，您不必改动单独的规则，仅仅改动一下搜寻路径即可。<o:p></o:p></span></span></p>

<h3><a name="_4.3.1_VPATH：所有依赖的搜寻路径"></a><span lang="EN-US" style="font-size: 14pt; font-family: 宋体;">4.3.1 VPATH：所有依赖的搜寻路径<o:p></o:p></span></h3>

<p class="MsoNormal" style="text-indent: 21pt;"><span lang="EN-US" style="font-family: 宋体;">make变量VPATH的值指定了make搜寻的目录。经常用到的是那些包含依赖的目录，并不是当前的目录；但VPATH指定了make对所有文件都适用的目录搜寻序列，包括了规则的目标所需要的文件。<o:p></o:p></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">如果一个作为目标或依赖的文件在当前目录中不存在，<span lang="EN-US">make就会在VPATH指定的目录中搜寻该文件。如果在这些目录中找到要寻找的文件，则就象这些文件在当前目录下存在一样，规则把这些文件指定为依赖。参阅<b style=""><i>编写搜寻目录的shell命令</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">在<span lang="EN-US">VPATH变量定义中，目录的名字由冒号或空格分开。目录列举的次序也是make 搜寻的次序。在MS-DOS、MS-WINDOWS系统中，VPATH变量定义中的目录的名字由分号分开，因为在这些系统中，冒号用为路径名的一部分（通常在驱动器字母后面）。例如：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160; </span>VPATH = src:../headers<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">指定了两个目录，‘<span lang="EN-US">src’和‘…/headers’，make也按照这个次序进行搜寻。使用该VPATH的值，下面的规则，<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160; </span>foo.o : foo.c<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">在执行时就象如下写法一样会被中断：<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;">foo.o : src/foo.c<o:p></o:p></span></p>

<p class="MsoNormal"><span style="font-family: 宋体;">然后在<span lang="EN-US">src目录下搜寻foo.c。<o:p></o:p></span></span></p>

<h3><a name="_4.3.2_vpath指令"></a><span lang="EN-US" style="font-size: 14pt; font-family: 宋体;">4.3.2 vpath指令<o:p></o:p></span></h3>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;">vpath指令（注意字母是小写）和VPATH变量类似，但却更具灵活性。vpath指令允许对符合一定格式类型的文件名指定一个搜寻路径。这样您就可以对一种格式类型的文件名指定一个搜寻路径，对另外格式类型的文件名指定另外一个搜寻路径。总共由三种形式的vpath指令：<o:p></o:p></span></p>

<p class="MsoNormal"><code><b style=""><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">vpath
</span></b></code><var><b style=""><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">pattern</span></b></var><code><b style=""><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;"> </span></b></code><var><b style=""><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">directories<o:p></o:p></span></b></var></p>

<p class="MsoNormal" style="margin-left: 20.6pt;"><var><b style=""><span style="font-family: 宋体; font-style: normal;">对</span></b></var><b style=""><span style="font-family: 宋体;">一定格式类型的文件名指定一个搜寻路径。搜寻的路径由一列要搜寻的目录构成，目录由冒号（在<span lang="EN-US">MS-DOS、MS-WINDOWS系统中用分号）或空格隔开，和VPATH变量定义要搜寻的路径格式一样。<o:p></o:p></span></span></b></p>

<p class="MsoNormal"><code><b style=""><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">vpath
</span></b></code><var><b style=""><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">pattern</span></b></var><b style=""><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></b></p>

<p class="MsoNormal" style="margin-left: 25.7pt;"><b style=""><span style="font-family: 宋体;">清除和一定类型格式相联系的搜寻路径。<span lang="EN-US"><o:p></o:p></span></span></b></p>

<p class="MsoNormal"><code><b style=""><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">vpath</span></b></code><b style=""><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></b></p>

<p class="MsoNormal" style="margin-left: 30.9pt;"><b style=""><span style="font-family: 宋体;">清除所有前面由<span lang="EN-US">vapth指令指定的搜寻路径。<o:p></o:p></span></span></b></p>

<p class="MsoNormal"><span style="font-family: 宋体;">一个<span lang="EN-US">vpath的格式pattern是一个包含一个’%’的字符串。该字符串必须和正搜寻的一个依赖的文件名匹配，字符%可和任何字符串匹配（关于格式规则，参阅<b style=""><i>定义与重新定义格式规则</i></b>）。例如，%.h和任何文件名以.h结尾的文件匹配。如果不使用‘%’，格式必须与依赖精确匹配，这种情况很少使用。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">在<span lang="EN-US">vpath指令格式中的字符‘%’可以通过前面的反斜杠被引用。引用其它字符‘%’的反斜杠也可以被更多的反斜杠引用。引用字符‘%’和其它反斜杠的反斜杠在和文件名比较之前和格式是分开的。如果反斜杠所引用的字符‘%’没有错误，则该反斜杠不会运行带来任何危害。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">如果<span lang="EN-US">vpath指令格式和一个依赖的文件名匹配，并且在当前目录中该依赖不存在，则vpath指令中指定的目录和VPATH变量中的目录一样可以被搜寻。例如：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">vpath %.h ../headers<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">将告诉<span lang="EN-US">make如果在当前目录中以‘.h’结尾文件不存在，则在‘../headers’目录下搜寻任何以‘.h’结尾依赖。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">如果有几个<span lang="EN-US">vpath指令格式和一个依赖的文件名匹配，则make一个接一个的处理它们，搜寻所有在指令中指定的目录。Make按它们在makefile文件中出现的次序控制多个vpath指令，多个指令虽然有相同的格式，但它们是相互独立的。以下代码：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">vpath %.c foo<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">vpath %<span style="">&#160;&#160; </span>blish<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">vpath %.c bar<o:p></o:p></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">表示搜寻<samp><span lang="EN-US" style="">`.c'文件先搜寻目录</span></samp><tt><span lang="EN-US" style="">`foo'、然后`blish'，最后`bar'；如果是如下代码：</span></tt><span lang="EN-US"><o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">vpath %.c foo:bar<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">vpath %<span style="">&#160;&#160; </span>blish<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">表示搜寻<samp><span lang="EN-US" style="">`.c'文件先搜寻目录</span></samp><tt><span style="">‘<span lang="EN-US">foo'、然后‘bar'，最后‘blish'。<o:p></o:p></span></span></tt></span></p>

<h3><a name="_4.3.3文件夹的搜寻过程"></a><span lang="EN-US" style="font-size: 14pt; font-family: 宋体;">4.3.3目录搜寻过程<o:p></o:p></span></h3>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160; </span>当通过目录搜寻找到一个文件，该文件有可能不是您在依赖列表中所列出的依赖；有时通过目录搜寻找到的路径也可能被废弃。Make决定对通过目录搜寻找到的路径保存或废弃所依据的算法如下：<o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 26.25pt; text-indent: -15.75pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: 宋体;">1、</span><!--[endif]--><span style="font-family: 宋体;">如果一个目标文件在<span lang="EN-US">makefile文件所在的目录下不存在，则将会执行目录搜寻。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 26.25pt; text-indent: -15.75pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: 宋体;">2、</span><!--[endif]--><span style="font-family: 宋体;">如果目录搜寻成功，则路径和所得到的文件暂时作为目标文件储存。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 26.25pt; text-indent: -15.75pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: 宋体;">3、</span><!--[endif]--><span style="font-family: 宋体;">所有该目标的依赖用相同的方法考察。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 26.25pt; text-indent: -15.75pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: 宋体;">4、</span><!--[endif]--><span style="font-family: 宋体;">把依赖处理完成后，该目标可能需要或不需要重新创建：<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 42pt; text-indent: -15.75pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: 宋体;">1、</span><!--[endif]--><span style="font-family: 宋体;">如果该目标不需要重建，目录搜寻时所得到的文件的路径用作该目标所有依赖的路径，同时包含该目标文件。简而言之，如果<span lang="EN-US">make不必重建目标，则您使用通过目录搜寻得到的路径。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 42pt; text-indent: -15.75pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: 宋体;">2、</span><!--[endif]--><span style="font-family: 宋体;">如果该目标需要重建，目录搜寻时所得到的文件的路径将废弃，目标文件在<span lang="EN-US">makefile文件所在的目录下重建。简而言之，如果make要重建目标，是在makefile文件所在的目录下重建目标，而不是在目录搜寻时所得到的文件的路径下。<o:p></o:p></span></span></p>

<p class="MsoNormal"><span style="font-family: 宋体;">该算法似乎比较复杂，但它却可十分精确的解释实际您所要的东西。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">其它版本的<span lang="EN-US">make使用一种比较简单的算法：如果目标文件在当前目录下不存在，而它通过目录搜寻得到，不论该目标是否需要重建，始终使用通过目录搜寻得到的路径。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">实际上，如果在<span lang="EN-US">GNU make中使您的一些或全部目录具备这种行为，您可以使用GPATH变量来指定这些目录。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span lang="EN-US" style="font-family: 宋体;">GPATH变量和VPATH变量具有相同的语法和格式。如果通过目录搜寻得到一个过时的目标，而目标存在的目录又出现在GPATH变量，则该路径将不废弃，目标将在该路径下重建。
<o:p></o:p></span></p>

<h3><a name="_4.3.4_为文件夹搜寻编写shell命令"></a><span lang="EN-US" style="font-size: 14pt; font-family: 宋体;">4.3.4编写目录搜寻的shell命令<o:p></o:p></span></h3>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">即使通过目录搜寻在其它目录下找到一个依赖，不能改变规则的命令，这些命令同样按照原来编写的方式执行。因此，您应该小心的编写这些命令，以便它们可以在<span lang="EN-US">make能够在发现依赖的目录中处理依赖。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">借助诸如‘<span lang="EN-US">$^’的自动变量可更好的使用shell命令（参阅<b style=""><i>自动变量</i></b>）。例如，‘$^’的值代表所有的依赖列表，并包含寻找依赖的目录；‘$@’的值是目标。<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">foo.o : foo.c<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>cc -c $(CFLAGS) $^ -o $@<o:p></o:p></span></pre>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">变量<span lang="EN-US">CFLAGS存在可以方便您利用隐含规则指定编译C语言源程序的旗标。我们这里使用它是为了保持编译C语言源程序一致性。参阅<b style=""><i>隐含规则使用的变量</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">依赖通常情况下也包含头文件，因自动变量‘<span lang="EN-US">$&lt;’的值是第一个依赖，因此这些头文件您可以不必在命令中提及，例如：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">VPATH = src:../headers<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">foo.o : foo.c defs.h hack.h<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>cc -c $(CFLAGS) $&lt; -o $@<o:p></o:p></span></pre>

<h3><a name="_4.3.5_文件夹搜寻和隐含规则"></a><span lang="EN-US" style="font-size: 14pt; font-family: 宋体;">4.3.5 目录搜寻和隐含规则<o:p></o:p></span></h3>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">搜寻的目录是由变量<span lang="EN-US">VPATH或隐含规则引入的vpath指令指定的（详细参阅<b><i>使用隐含规则</i></b>）。例如，如果文件‘foo.o’没有具体的规则，make则使用隐含规则：如文件foo.c存在，make使用内置的规则编译它；如果文件foo.c不在当前目录下，就搜寻适当的目录，如在别的目录下找到foo.c，make同样使用内置的规则编译它。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">隐含规则的命令使用自动变量是必需的，所以隐含规则可以自然地使用目录搜寻得到的文件。<span lang="EN-US"><o:p></o:p></span></span></p>

<h3><a name="_4.3.6_连接库的文件夹搜寻"></a><span lang="EN-US" style="font-size: 14pt; font-family: 宋体;">4.3.6 连接库的搜寻目录<o:p></o:p></span></h3>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">对于连接库文件，目录搜寻采用一种特别的方式。这种特别的方式来源于个玩笑：您写一个依赖，它的名字是‘<span lang="EN-US">-|name’的形式。（您可以在这里写一些奇特的字符，因为依赖正常是一些文件名，库文件名通常是‘libname.a’ 的形式，而不是‘-|name’
的形式。）<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">当一个依赖的名字是‘<span lang="EN-US">-|name’的形式时，make特别地在当前目录下、与vpath匹配的目录下、VPATH指定的目录下以及‘<tt><span style="">/lib’</span></tt>,
‘<tt><span style="">/usr/lib'</span></tt>,
和 ‘<var>prefix</var><tt><span style="">/lib'（正常情况为`/usr/local/lib'，但是</span></tt>MS-DOS、MS-Windows版本的make的行为好像是<i>prefix</i>定义为DJGPP安装树的根目录的情况）<tt><span style="">目录下搜寻名字为‘lib</span></tt><var>name</var><tt><span style="">.so'的文件然后再处理它</span></tt>。如果<tt><span style="">没有搜寻到‘lib</span></tt><var>name</var><tt><span style="">.so'文件，然后在前述的目录下搜寻‘lib</span></tt><var>name</var><tt><span style="">.a'文件。</span></tt><o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">例如，如果在您的系统中有‘<tt><span lang="EN-US" style="">/usr/lib/libcurses.a'的库文件，则：<o:p></o:p></span></tt></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">foo : foo.c -lcurses<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>cc $^ -o $@<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">如果‘<span lang="EN-US">foo’比‘foo.c’更旧，将导致命令‘<samp><span style="">cc foo.c /usr/lib/libcurses.a -o
foo'执行。<o:p></o:p></span></samp></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">缺省情况下是搜寻‘<tt><span lang="EN-US" style="">lib</span></tt><var><span lang="EN-US">name</span></var><tt><span lang="EN-US" style="">.so'</span></tt><span lang="EN-US"> 和‘<tt><span style="">lib</span></tt><var>name</var><tt><span style="">.a'文件，具体搜寻的文件及其类型可使用</span></tt><code><span style="">.LIBPATTERNS变量指定，这个变量值中的每一个字都是一个字符串格式。当寻找名为</span></code>‘-|name’的依赖时，make首先用<i>name</i>替代列表中第一个字中的格式部分形成要搜寻的库文件名，然后使用该库文件名在上述的目录中搜寻。如果没有发现库文件，则使用列表中的下一个字，其余以此类推。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><code><span lang="EN-US" style="font-family: 宋体;">.LIBPATTERNS变量</span></code><span style="font-family: 宋体;">缺省的值是<span lang="EN-US">"‘<samp><span style="">lib%.so lib%.a'</span></samp>"，该值对前面描述的缺省行为提供支持。您可以通过将该值设为空值从而彻底关闭对连接库的扩展。<o:p></o:p></span></span></p>

<h2><a name="_4.4假想目标"></a><span lang="EN-US" style="font-family: 宋体;">4.4假想目标<o:p></o:p></span></h2>

<p class="MsoBodyTextIndent">假想目标并不是一个真正的文件名，它仅仅是您制定的一个具体规则所执行的一些命令的名称。使用假想目标有两个原因：避免和具有相同名称的文件冲突和改善性能。</p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">如果您写一个其命令不创建目标文件的规则，一旦由于重建而提及该目标，则该规则的命令就会执行。这里有一个例子：<span lang="EN-US"><o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">clean:<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>rm *.o temp<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">因为<span lang="EN-US">rm命令不创建名为‘clean’的文件，所以不应有名为‘clean’的文件存在。因此不论何时您发布<samp><span style="">`make clean'指令，</span></samp>rm命令就会执行</span></span><span style="font-size: 10pt; font-family: 宋体;">。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">假想目标能够终止任何在目录下创建名为‘<span lang="EN-US">clean’的文件工作。但如在目录下存在文件clean，因为该目标clean没有依赖，所以文件clean始终会认为已经该更新，因此它的命令将永不会执行。为了避免这种情况，您应该使用象如下特别的.PHONY目标格式将该目标具体的声明为一个假想目标：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">.PHONY : clean<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">一旦这样声明，‘<span lang="EN-US">make
clean’命令无论目录下是否存在名为‘clean’的文件，该目标的命令都会执行。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">因为<span lang="EN-US">make知道假想目标不是一个需要根据别的文件重新创建的实际文件，所以它将跳过隐含规则搜寻假想目标的步骤（详细内容参阅<b><i>使用隐含规则</i></b>）。这是把一个目标声明为假想目标可以提高执行效率的原因，因此使用假想目标您不用担心在目录下是否有实际文件存在。这样，对前面的例子可以用假想目标的写出，其格式如下：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">.PHONY: clean<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">clean:<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>rm *.o temp<o:p></o:p></span></pre>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">另外一个使用假想目标的例子是使用<span lang="EN-US">make的递归调用进行连接的情况：此时，makefile文件常常包含列举一系列需要创建的子目录的变量。不用假想目标完成这种任务的方法是使用一条规则，其命令是一个在各个子目录下循环的shell命令，如下面的例子：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">subdirs:<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>for dir in $(SUBDIRS); do \<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(MAKE) -C $$dir; \<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>done<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">但使用这个方法存在下述问题：首先，这个规则在创建子目录时产生的任何错误都不及时发现，因此，当一个子目录创建失败时，该规则仍然会继续创建剩余的子目录。虽然该问题可以添加监视错误产生并退出的<span lang="EN-US">shell命令来解决，但非常不幸的是如果make使用了‘-k’选项，这个问题仍然会产生。第二，也许更重要的是您使用了该方法就失去使用make并行处理的特点能力。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">使用假想目标（如果一些子目录已经存在，您则必须这样做，否则，不存在的子目录将不会创建）则可以避免上述问题：<span lang="EN-US"><o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">SUBDIRS = foo bar baz<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">.PHONY: subdirs $(SUBDIRS)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">subdirs: $(SUBDIRS)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">$(SUBDIRS):<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(MAKE) -C $<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">foo: baz<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">此时，如果子目录‘<span lang="EN-US">baz’没有创建完成，子目录’foo’将不会创建；当试图使用并行创建时这种关系的声明尤其重要。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">一个假想目标不应该是一个实际目标文件的依赖，如果这样，<span lang="EN-US">make每次执行该规则的命令，目标文件都要更新。只要假想目标不是一个真实目标的依赖，假想目标的命令只有在假想目标作为特别目标时才会执行（参阅<b><i>指定最终目标的参数</i></b>）。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">假想目标也可以有依赖。当一个目录下包含多个程序时，使用假想目标可以方便的在一个<span lang="EN-US">makefile文件中描述多个程序的更新。重建的最终目标缺省情况下是makefile文件的第一个规则的目标，但将多个程序作为假想目标的依赖则可以轻松的完成在一个makefile文件中描述多个程序的更新。如下例：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">all : prog1 prog2 prog3<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">.PHONY : all<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">prog1 : prog1.o utils.o<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>cc -o prog1 prog1.o utils.o<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">prog2 : prog2.o<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>cc -o prog2 prog2.o<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">prog3 : prog3.o sort.o utils.o<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>cc -o prog3 prog3.o sort.o utils.o<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">这样，您可以重建所有程序，也可以参数的形式重建其中的一个或多个（如‘<samp><span lang="EN-US" style="">make prog1
prog3'）。<o:p></o:p></span></samp></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><samp><span style="font-family: 宋体;">当一个假想目标是另一个假想目标的依赖，则该假想目标将作为一个假想目标的子例程。例如，这里‘<span lang="EN-US">make cleanall'用来删除OBJ文件、diff文件和程序文件：<o:p></o:p></span></span></samp></p>

<pre><span lang="EN-US" style="font-family: 宋体;">.PHONY: cleanall cleanobj cleandiff<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">cleanall : cleanobj cleandiff<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>rm program<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">cleanobj :<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>rm *.o<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">cleandiff :<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>rm *.diff<o:p></o:p></span></pre>

<h2><a name="_4.5_没有命令或依赖的规则"></a><span lang="EN-US" style="font-family: 宋体;">4.5 没有命令或依赖的规则<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">如果一个规则没有依赖、也没有命令，而且这个规则的目标也不是一个存在的文件，则<span lang="EN-US">make认为只要该规则运行，该目标就已被更新。这意味着，所有以这种规则的目标为依赖的目标，它们的命令将总被执行。这里举一个例子：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">clean: FORCE<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>rm $(objects)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">FORCE:<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">这里的目标‘<span lang="EN-US">FORCR’满足上面的特殊条件，所以以其为依赖的目标‘clean’将总强制它的命令执行。关于‘FORCR’的名字没有特别的要求，但‘FORCR’是习惯使用的名字。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">也许您已经明白，使用‘<span lang="EN-US">FORCR’的方法和使用假想目标（.PHONY: clean）的结果一样，但使用假想目标更具体更灵活有效，由于一些别的版本的make不支持假想目标，所以‘FORCR’出现在许多makefile文件中。参阅<b><i>假想目标</i></b>。<o:p></o:p></span></span></p>

<h2><a name="_4.6使用空目标文件记录事件"></a><span lang="EN-US" style="font-family: 宋体;">4.6使用空目标文件记录事件<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">空目标是一个假想目标变量，它用来控制一些命令的执行，这些命令可用来完成一些经常需要的具体任务。但又不象真正的假想目标，它的目标文件可以实际存在，但文件的内容与此无关，通常情况下，这些文件没有内容。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">空目标文件的用途是用来记录规则的命令最后一次执行的时间，也是空目标文件最后更改的时间。它之所以能够这样执行是因为规则的命令中有一条用于更新目标文件的‘<span lang="EN-US">touch’命令。另外，空目标文件应有一些依赖（否则空目标文件没有存在的意义）。如果空目标比它的依赖旧，当您命令重建空目标文件时，有关的命令才会执行。下面有一个例子：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">print: foo.c bar.c<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>lpr -p $?<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>touch print<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">按照这个规则，如果任何一个源文件从上次执行‘<samp><span lang="EN-US" style="">make print'</span></samp>以来发生变化，键入‘<samp><span lang="EN-US" style="">make print'则执行lpr命令。自动变量‘$?’用来打印那些发生变化的文件（参阅<b><i>自动变量</i></b>）。<o:p></o:p></span></samp></span></p>

<h2><a name="_4.7_内部使用的一些特殊目标名"></a><samp><span lang="EN-US" style="font-size: 14pt; font-family: 宋体;">4.7
内建的特殊目标名<o:p></o:p></span></samp></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><samp><span style="font-family: 宋体;">一些名字作为目标使用则含有特殊的意义：<span lang="EN-US"><o:p></o:p></span></span></samp></p>

<p class="MsoNormal" style="margin-left: 21pt; text-indent: -21pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: Wingdings;">l<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><!--[endif]--><b><span lang="EN-US" style="font-family: 宋体;">.PHONY<o:p></o:p></span></b></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">特殊目标<span lang="EN-US">.PHONY的依赖是假想目标。假想目标是这样一些目标，make无条件的执行它命令，和目录下是否存在该文件以及它最后一次更新的时间没有关系。详细内容参阅<b><i>假想目标</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 21pt; text-indent: -21pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: Wingdings;">l<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><!--[endif]--><b><span lang="EN-US" style="font-family: 宋体;">.SUFFIXES<o:p></o:p></span></b></p>

<p class="MsoNormal" style="margin-left: 21pt;"><span style="font-family: 宋体;">特殊目标<span lang="EN-US">.SUFFIXES的依赖是一列用于后缀规则检查的后缀。详细内容参阅<b><i>过时的后缀规则</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 21pt; text-indent: -21pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: Wingdings;">l<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><!--[endif]--><b><span lang="EN-US" style="font-family: 宋体;">.DEFAULT<o:p></o:p></span></b></p>

<p class="MsoNormal" style="margin-left: 21pt;"><span lang="EN-US" style="font-family: 宋体;">.DEFAULT指定一些命令，这些命令用于那些没有找到规则（具体规则或隐含规则）更新的目标。详细内容参阅<b><i>定义最新类型的-缺省规则</i></b>。如果.DEFAULT指定了一些命令，则所有提及到的文件只能作为依赖，而不能作为任何规则的目标；这些指定的命令也只按照他们自己的方式执行。详细内容参阅<b><i>隐含规则搜寻算法</i></b>。<o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 21pt; text-indent: -21pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: Wingdings;">l<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><!--[endif]--><b><span lang="EN-US" style="font-family: 宋体;">.PRECIOUS<o:p></o:p></span></b></p>

<p class="MsoNormal" style="margin-left: 21pt;"><span style="font-family: 宋体;">特殊目标<span lang="EN-US">.PRECIOUS的依赖将按照下面给定的特殊方式进行处理：如果在执行这些目标的命令的过程中，make被关闭或中断，这些目标不能被删除，详细内容参阅<b><i>关闭和中断make</i></b>；如果目标是中间文件，即使它已经没有任何用途也不能被删除，具体情况和该目标正常完成一样，参阅<b><i>隐含规则链</i></b>；该目标的其它功能和特殊目标.SECONDARY的功能重叠。如果规则的目标格式与依赖的文件名匹配，您可以使用隐含规则的格式（如‘%.O’）列举目标作为特殊目标.PRECIOUS的依赖文件来保存由这些规则创建的中间文件。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 21pt; text-indent: -21pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: Wingdings;">l<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><!--[endif]--><b><span lang="EN-US" style="font-family: 宋体;">.INTERMEDIATE<o:p></o:p></span></b></p>

<p class="MsoNormal" style="margin-left: 21pt;"><span style="font-family: 宋体;">特殊目标<span lang="EN-US">.INTERMEDIATE的依赖被处理为中间文件。详细内容参见<b><i>隐含规则链</i></b>。.INTERMEDIATE如果没有依赖文件，它将不会发生作用。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 21pt; text-indent: -21pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: Wingdings;">l<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><!--[endif]--><b><span lang="EN-US" style="font-family: 宋体;">.SECONDARY<o:p></o:p></span></b></p>

<p class="MsoNormal" style="margin-left: 21pt;"><span style="font-family: 宋体;">特殊目标<span lang="EN-US">.SECONDARY的依赖被处理为中间文件，但它们永远不能自动删除。详细内容参见<b><i>隐含规则链</i></b>。.SECONDARY如果没有依赖文件，则所有的makefile文件中的目标都将被处理为中间文件。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 21pt; text-indent: -21pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: Wingdings;">l<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><!--[endif]--><b><span lang="EN-US" style="font-family: 宋体;">.DELETE_ON_ERROR<o:p></o:p></span></b></p>

<p class="MsoNormal" style="margin-left: 21pt;"><span style="font-family: 宋体;">如果在<span lang="EN-US">makefile文件的某处.DELETE_ON_ERROR作为一个目标被提及，则如果该规则发生变化或它的命令没有正确完成而退出，make将会删除该规则的目标，具体行为和它受到了删除信号一样。详细内容参阅<b><i>命令错误</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 21pt; text-indent: -21pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: Wingdings;">l<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><!--[endif]--><span lang="EN-US" style="font-family: 宋体;">.IGNORE<o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 21pt;"><span style="font-family: 宋体;">如果您特别为目标<span lang="EN-US">.IGNORE指明依赖，则MAKE将会忽略处理这些依赖文件时执行命令产生的错误。如果.IGNORE作为一个没有依赖的目标提出来，MAKE将忽略处理所有文件时产生的错误。.IGNORE命令并没有特别的含义，.IGNORE的用途仅是为了和早期版本的兼容。因为.IGNORE影响所有的命令，所以它的用途不大；我们推荐您使用其它方法来忽略特定命令产生的错误。详细内容参阅<b><i>命令错误</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 21pt; text-indent: -21pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: Wingdings;">l<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><!--[endif]--><b><span lang="EN-US" style="font-family: 宋体;">.SILENT<o:p></o:p></span></b></p>

<p class="MsoNormal" style="margin-left: 21pt;"><span style="font-family: 宋体;">如果您特别为<span lang="EN-US">.SILENT指明依赖，则在执行之前MAKE将不会回显重新构造文件的命令。如果.SILENT作为一个没有依赖的目标提出来，任何命令在执行之前都不会打印。.SILENT并没有特别的含义，其用途仅是为了和早期版本的兼容。我们推荐您使用其它方法来处理那些不打印的命令。详细内容参阅<b><i>命令回显</i></b>。如果您希望所有的命令都不打印，请使用‘-s’或‘-silent’选项(详细参阅<b><i>选项概要</i></b>)。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 21pt; text-indent: -21pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: Wingdings;">l<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><!--[endif]--><b><span lang="EN-US" style="font-family: 宋体;">.EXPORT_ALL_VARIABLES<o:p></o:p></span></b></p>

<p class="MsoNormal" style="margin-left: 21pt;"><span style="font-family: 宋体;">如该特殊目标简单的作为一个目标被提及，<span lang="EN-US">MAKE将缺省地把所有变量都传递到子进程中。参阅使<b>与子MAKE通信的变量</b>。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 21pt; text-indent: -21pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: Wingdings;">l<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><!--[endif]--><b><span lang="EN-US" style="font-family: 宋体;">.NOTPARALLEL<o:p></o:p></span></b></p>

<p class="MsoNormal" style="margin-left: 21pt;"><span style="font-family: 宋体;">如果<span lang="EN-US">.NOTPARALLEL作为一个目标提及，即使给出‘-j’选项，make也不使用并行执行。但递归调用的make命令仍可并行执行（在调用的makefile文件中包含.NOTPARALLEL的目标的例外）。.NOTPARALLEL的任何依赖都将忽略。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">任何定义的隐含规则后缀如果作为目标出现都会视为一个特殊规则，即使两个后缀串联起来也是如此，例如‘<span lang="EN-US">.c.o’。这些目标称为后缀规则，这种定义方法是过时的定义隐含规则的方法（目前仍然广泛使用的方法）。原则上，如果您要把它分为两个并把它们加到后缀列表中，任何目标名都可采用这种方法指定。实际上，后缀一般以‘.’开始，因此，这些特别的目标同样以‘.’开始。具体参阅<b><i>过时的后缀规则</i></b>。<o:p></o:p></span></span></p>

<h2><a name="_4.8_具有多个目标的规则"></a><span lang="EN-US" style="font-family: 宋体;">4.8 具有多个目标的规则<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">具有多个目标的规则等同于写多条规则，这些规则除了目标不同之外，其余部分完全相同。相同的命令应用于所有目标，但命令执行的结果可能有所差异，因此您可以在命令中使用‘<span lang="EN-US">$@’分配不同的实际目标名称。这条规则同样意味着所有的目标有相同的依赖。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">在以下两种情况下具有多个目标的规则相当有用：<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 21pt; text-indent: -21pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: Wingdings;">l<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><!--[endif]--><span style="font-family: 宋体;">您仅仅需要依赖，但不需要任何命令。例如：<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 21pt;"><span lang="EN-US" style="font-family: 宋体;">kbd.o command.o files.o: command.h<o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 21pt;"><span style="font-family: 宋体;">为三个提及的目标文件给出附加的共同依赖。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 21pt; text-indent: -21pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: Wingdings;">l<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><!--[endif]--><span style="font-family: 宋体;">所有的目标使用相同的命令。但命令的执行结果未必完全相同，因为自动变量‘<span lang="EN-US">$@’可以在重建时指定目标（参阅自动变量）。例如：<o:p></o:p></span></span></p>

<pre style="margin-left: 18pt;"><span lang="EN-US" style="font-family: 宋体;">bigoutput littleoutput : text.g<o:p></o:p></span></pre><pre style="margin-left: 18pt;"><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160; </span><span style="">&#160;</span>generate text.g -$(subst output,,$@) &gt; $@<o:p></o:p></span></pre>

<p class="MsoNormal" style="text-indent: 18pt;"><span style="font-family: 宋体;">等同于：<span lang="EN-US"><o:p></o:p></span></span></p>

<pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">bigoutput : text.g<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>generate text.g -big &gt; bigoutput<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">littleoutput : text.g<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>generate text.g -little &gt; littleoutput<o:p></o:p></span></pre>

<p class="MsoNormal" style="margin-left: 21.25pt; text-indent: 14.75pt;"><span style="font-family: 宋体;">这里我们假设程序可以产生两种输出文件类型：一种给出‘<span lang="EN-US">-big’，另一种给出‘-little’。参阅<b><i>字符串代替和分析函数</i></b>，对函数subst的解释。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">如果您喜欢根据目标变换依赖，象使用变量‘<span lang="EN-US">$@’变换命令一样。您不必使用具有多个目标的规则，您可以使用<b><i>静态格式规则</i></b>。详细内容见下文。<o:p></o:p></span></span></p>

<h2><a name="_4.9_具有多条规则的目标"></a><span lang="EN-US" style="font-family: 宋体;">4.9 具有多条规则的目标<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">一个目标文件可以有多个规则。在所有规则中提及的依赖都将融合在一个该目标的依赖列表中。如果该目标比任何一个依赖‘旧’，所有的命令将执行重建该目标。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">但如果一条以上的规则对同一文件给出多条命令，<span lang="EN-US">make将使用最后给出的规则，同时打印错误信息。（作为特例，如果文件名以点‘.’开始，不打印出错信息。这种古怪的行为仅仅是为了和其它版本的make兼容）。您没有必要这样编写您的makefile文件，这正是make给您发出错误信息的原因。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">一条特别的依赖规则可以用来立即给多条目标文件提供一些额外的依赖。例如，使用名为‘<span lang="EN-US">objects’的变量，该变量包含系统产生的所有输出文件列表。如果‘congfig.h’发生变化所有的输出文件必须重新编译，可以采用下列简单的方法编写：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">objects = foo.o bar.o<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">foo.o : defs.h<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">bar.o : defs.h test.h<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">$(objects) : config.h<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">这些可以自由插入或取出而不影响实际指定的目标文件生成规则，如果您希望断断续续的为目标添加依赖，这是非常方便的方法。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">另外一个添加依赖的方法是定义一个变量，并将该变量作为<span lang="EN-US">make命令的参数使用。详细内容参阅<b><i>变量重载</i></b>。例如：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">extradeps=<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">$(objects) : $(extradeps)<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">命令<samp><span lang="EN-US" style="">`make extradeps=foo.h'含义是将‘foo.h’作为所有OBJ文件的依赖，如果仅仅输入‘make’命令则不是这样。<o:p></o:p></span></samp></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><samp><span style="font-family: 宋体;">如果没有具体的规则为目标的生成指定命令，那么<span lang="EN-US">make将搜寻合适的隐含规则进而确定一些命令来完成生成或重建目标。详细内容参阅<b><i>使用隐含规则</i></b>。<o:p></o:p></span></span></samp></p>

<h2><a name="_4.10_静态格式规则"></a><samp><span lang="EN-US" style="font-family: 宋体; font-weight: normal;">4.10 </span></samp><span style="font-family: 宋体;">静态格式规则</span><samp><span lang="EN-US" style="font-family: 宋体; font-weight: normal;"><o:p></o:p></span></samp></h2>

<p class="MsoBodyTextIndent">静态格式规则是指定多个目标并能够根据每个目标名构造对应的依赖名的规则。静态格式规则在用于多个目标时比平常的规则更常用，因为目标可以不必有完全相同的依赖；也就是说，这些目标的依赖必须类似，但不必完全相同。</p>

<h3><a name="_4.10.1_静态格式规则的语法"></a><span lang="EN-US" style="font-size: 14pt; font-family: 宋体;">4.10.1 静态格式规则的语法<o:p></o:p></span></h3>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">这里是静态格式规则的语法格式：<span lang="EN-US"><o:p></o:p></span></span></p>

<pre><var><span lang="EN-US" style="font-family: 宋体;">targets</span></var><span lang="EN-US" style="font-family: 宋体;"> ...: <var>target-pattern</var>: <var>dep-patterns</var> ...<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span><var>commands</var><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>...<o:p></o:p></span></pre>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">目标列表指明该规则应用的目标。目标可以含有通配符，具体使用和平常的目标规则基本一样（参阅<b><i>在文件名中使用通配符</i></b>）。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoBodyTextIndent">目标的格式和依赖的格式是说明如何计算每个目标依赖的方法。从匹配目标格式的目标名中依据格式抽取部分字符串，这部分字符串称为径。将径分配到每一个依赖格式中产生依赖名。</p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">每一个格式通常包含字符‘<span lang="EN-US">%’。目标格式匹配目标时，‘%’可以匹配目标名中的任何字符串；这部分匹配的字符串称为径；剩下的部分必须完全相同。如目标‘foo.o’匹配格式‘%.o’，字符串‘foo’称为径。而目标‘foo.c’和‘foo.out’不匹配格式。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">每个目标的依赖名是使用径代替各个依赖中的‘<span lang="EN-US">%’产生。如，如果一个依赖格式为‘%.c’，把径‘foo’代替依赖格式中的‘%’生成依赖的文件名‘foo.c’。在依赖格式中不包含‘%’也是合法的，此时对所有目标来说，依赖是相同的。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">在格式规则中字符‘<span lang="EN-US">%’可以用前面加反斜杠‘\’方法引用。引用‘%’的反斜杠也可以由更多的反斜杠引用。引用‘%’、‘\’的反斜杠在和文件名比较或由径代替它之前从格式中移走。反斜杠不会因为引用‘%’而混乱。如，格式</span></span><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">`the\%weird\\%pattern\\'是</span></tt><samp><span lang="EN-US" style="font-family: 宋体;">`the%weird\'</span></samp><span lang="EN-US" style="font-family: 宋体;"> 加上字符<samp><span style="">‘%'，</span></samp>后面再和字符串 <samp><span style="">‘pattern\\'连接。最后的两个反斜杠由于不能影响任何统配符‘%’所以保持不变。<o:p></o:p></span></samp></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><samp><span style="font-family: 宋体;">这里有一个例子，它将对应的‘<span lang="EN-US">.c’文件编译成‘foo.o’和‘bar.o’。<o:p></o:p></span></span></samp></p>

<pre><span lang="EN-US" style="font-family: 宋体;">objects = foo.o bar.o<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">all: $(objects)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">$(objects): %.o: %.c<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(CC) -c $(CFLAGS) $&lt; -o $@<o:p></o:p></span></pre>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">这里‘<span lang="EN-US">$&lt;’是自动变量，控制依赖的名称，‘$@’也是自动变量，掌握目标的名称。详细内容参阅<b><i>自动变量</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">每一个指定目标必须和目标格式匹配，如果不符则产生警告。如果您有一列文件，仅有其中的一部分和格式匹配，您可以使用<b><span lang="EN-US">filter</span></b>函数把不符合的文件移走（参阅<b style=""><i>字符串替代和分析函数</i>）：</b><span lang="EN-US" style=""><o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">files = foo.elc bar.o lose.o<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">$(filter %.o,$(files)): %.o: %.c<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(CC) -c $(CFLAGS) $&lt; -o $@<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">$(filter %.elc,$(files)): %.elc: %.el<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>emacs -f batch-byte-compile $&lt;<o:p></o:p></span></pre>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">在这个例子中，</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">$(filter %.o,$(files))'的结果是</span></span></samp><tt><span style="font-family: 宋体;">‘<span lang="EN-US">bar.o lose.o'</span></span></tt><span style="font-family: 宋体;">，第一个静态格式规则是将相应的<span lang="EN-US">C语言源文件编译更新为OBJ文件，<samp><span style="">‘$(filter
%.elc,$(files))'</span></samp> 的结果是<tt><span style="">‘foo.elc'，它由‘foo.el’构造。<o:p></o:p></span></tt></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><tt><span style="font-family: 宋体;">另一个例子是阐明怎样在静态格式规则中使用‘<span lang="EN-US">$*’：<o:p></o:p></span></span></tt></p>

<pre><span lang="EN-US" style="font-family: 宋体;">bigoutput littleoutput : %output : text.g<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>generate text.g -$* &gt; $@<o:p></o:p></span></pre>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">当命令<span lang="EN-US">generate执行时，$*扩展为径，即‘big’或‘little’二者之一。<o:p></o:p></span></span></p>

<h3><a name="_4.10.2静态格式规则和隐含规则"></a><span lang="EN-US" style="font-size: 14pt; font-family: 宋体;">4.10.2静态格式规则和隐含规则<o:p></o:p></span></h3>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">静态格式规则和定义为格式规则的隐含规则有很多相同的地方（详细参阅</span><b style=""><i><span style="font-family: 宋体;">定义与重新定义格式规则</span></i></b><span style="font-family: 宋体;">）。双方都有对目标的格式和构造依赖名称的格式，差异是<span lang="EN-US">make使用它们的时机不同。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">隐含规则可以应用于任何于它匹配的目标，但它仅仅是在目标没有具体规则指定命令以及依赖可以被搜寻到的情况下应用。如果有多条隐含规则适合，仅有执行其中一条规则，选择依据隐含规则的定义次序。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">相反，静态格式规则用于在规则中指明的目标。它不能应用于其它任何目标，并且它的使用方式对于各个目标是固定不变的。如果使用两个带有命令的规则发生冲突，则是错误。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">静态格式规则因为如下原因可能比隐含规则更好：<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 21pt; text-indent: -21pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: Wingdings;">l<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><!--[endif]--><span style="font-family: 宋体;">对一些文件名不能按句法分类的但可以给出列表的文件，使用静态格式规则可以重载隐含规则链。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 21pt; text-indent: -21pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: Wingdings;">l<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><!--[endif]--><span style="font-family: 宋体;">如果不能精确确定使用的路径，您不能确定一些无关紧要的文件是否导致<span lang="EN-US">make使用错误的隐含规则（因为隐含规则的选择根据其定义次序）。使用静态格式规则则没有这些不确定因素：每一条规则都精确的用于指定的目标上。<o:p></o:p></span></span></p>

<h2><a name="_4.11双冒号规则"></a><span lang="EN-US" style="font-family: 宋体;">4.11双冒号规则<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">双冒号规则是在目标名后使用‘：：’代替‘：’的规则。当同一个目标在一条以上的规则中出现时，双冒号规则和平常的规则处理有所差异。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">当一目标在多条规则中出现时，所有的规则必须是同一类型：要么都是双冒号规则，要么都是普通规则。如果他们都是双冒号规则，则它们之间都是相互独立的。如果目标比一个双冒号规则的依赖‘旧’，则该双冒号规则的命令将执行。这可导致具有同一目标双冒号规则全部或部分执行。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">双冒号规则实际就是将具有相同目标的多条规则相互分离，每一条双冒号规则都独立的运行，就像这些规则的目标不同一样。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">对于一个目标的双冒号规则按照它们在<span lang="EN-US">makefile文件中出现的顺序执行。然而双冒号规则真正有意义的场合是双冒号规则和执行顺序无关的场合。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">双冒号规则有点模糊难以理解，它仅仅提供了一种在特定情况下根据引起更新的依赖文件不同，而采用不同方式更新目标的机制。实际应用双冒号规则的情况非常罕见。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">每一个双冒号规则都应该指定命令，如果没有指定命令，则会使用隐含规则。详细内容参阅</span><b style=""><i><span style="font-family: 宋体;">使用隐含规则</span></i></b><span style="font-family: 宋体;">。<span lang="EN-US"><o:p></o:p></span></span></p>

<h2><a name="_4.12_自动生成依赖"></a><span lang="EN-US" style="font-family: 宋体;">4.12 自动生成依赖<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">在为一个程序编写的<span lang="EN-US">makefile文件中，常常需要写许多仅仅是说明一些OBJ文件依靠头文件的规则。例如，如果‘main.c’通过一条#include语句使用‘defs.h’，您需要写入下的规则：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">main.o: defs.h<o:p></o:p></span></pre>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">您需要这条规则让<span lang="EN-US">make知道如果‘defs.h’一旦改变必须重新构造‘main.o’。由此您可以明白对于一个较大的程序您需要在makefile文件中写很多这样的规则。而且一旦添加或去掉一条#include语句您必须十分小心地更改makefile文件。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">为避免这种烦恼，现代<span lang="EN-US">C编译器根据原程序中的#include语句可以为您编写这些规则。如果需要使用这种功能，通常可在编译源程序时加入‘-M’开关，例如，下面的命令：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">cc -M main.c<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">产生如下输出：<span lang="EN-US"><o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">main.o : main.c defs.h<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">这样您就不必再亲自写这些规则，编译器可以为您完成这些工作。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">注意，由于在<span lang="EN-US">makefile文件中提及构造‘main.o’，因此‘main.o’将永远不会被隐含规则认为是中间文件而进行搜寻，这同时意味着make不会在使用它之后自动删除它；参阅</span></span><b style=""><i><span style="font-family: 宋体;">隐含规则链</span></i></b><span style="font-family: 宋体;">。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">对于旧版的<span lang="EN-US">make程序，通过一个请求命令，如‘make depend’，利用编译器的特点生成依赖是传统的习惯。这些命令将产生一个‘depend’文件，该文件包含所有自动生成的依赖；然后makefile文件可以使用include命令将它们读入（参阅</span></span><b style=""><i><span style="font-family: 宋体;">包含其它<span lang="EN-US">makefile文件</span></span></i></b><span style="font-family: 宋体;">）。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">在<span lang="EN-US">GNU make中，重新构造makefile文件的特点使这个惯例成为了过时的东西DD您永远不必具体告诉make重新生成依赖，因为GNU
make总是重新构造任何过时的makefile文件。参阅</span></span><b style=""><i><span lang="EN-US" style="font-family: 宋体;">Makefile文件的重新生成的过程</span></i></b><span style="font-family: 宋体;">。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">我们推荐使用自动生成依赖的习惯是把<span lang="EN-US">makefile文件和源程序文件一一对应起来。如，对每一个源程序文件‘name.c’有一名为‘name.d’的makefile文件和它对应，该makefile文件中列出了名为‘name.o’的OBJ文件所依赖的文件。这种方式的优点是仅在源程序文件改变的情况下才有必要重新扫描生成新的依赖。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">这里有一个根据<span lang="EN-US">C语言源程序‘name.c’生成名为‘name.d’依赖文件的格式规则：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">%.d: %.c<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>set -e; $(CC) -M $(CPPFLAGS) $&lt; \<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>| sed 's/\($*\)\.o[ :]*/\1.o $@ : /g' &gt; $@; \<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>[ -s $@ ] || rm -f $@<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">关于定义格式规则的信息参阅</span><b style=""><i><span style="font-family: 宋体;">定义与重新定义格式规则</span></i></b><span style="font-family: 宋体;">。‘<span lang="EN-US">-e’开关是告诉shell如果$(CC)命令运行失败（非零状态退出）立即退出。正常情况下，shell退出时带有最后一个命令在管道中的状态（sed）,因此make不能注意到编译器产生的非零状态。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">对于<span lang="EN-US">GNU C编译器您可以使用‘-MM’开关代替‘-M’，这是省略了有关系统头文件的依赖。详细内容参阅《GNU
CC使用手册》中</span></span><b style=""><i><span style="font-family: 宋体;">控制预处理选项</span></i></b><span style="font-family: 宋体;">。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">命令<span lang="EN-US">Sed的作用是翻译（例如）：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">main.o : main.c defs.h<o:p></o:p></span></pre>

<p><span style="font-size: 10.5pt;">到：<span lang="EN-US"><o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">main.o main.d : main.c defs.h<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">这使每一个‘<span lang="EN-US">.d’文件和与之对应的‘.o’文件依靠相同的源程序文件和头文件，据此，Make可以知道如果任一个源程序文件和头文件发生变化，则必须重新构造依赖文件。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">一旦您定义了重新构造‘<span lang="EN-US">.d’文件的规则，您可以使用使用include命令直接将它们读入，（参阅</span></span><b style=""><i><span style="font-family: 宋体;">包含其它<span lang="EN-US">makefile文件</span></span></i></b><span style="font-family: 宋体;">），例如：<span lang="EN-US"><o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">sources = foo.c bar.c<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">include $(sources:.c=.d)<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">（这个例子中使用一个代替变量参照从源程序文件列表</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">foo.c bar.c'翻译到依赖文件列表‘foo.d bar.d'。详细内容参阅<b><i>替换引用</i></b>。）所以，‘.d’的makefile文件和其它makefile文件一样，即使没用您的任何进一步的指令，make同样会在必要的时候重新构建它们。</span></span></samp><span style="font-family: 宋体;">参阅</span><b style=""><i><span lang="EN-US" style="font-family: 宋体;">Makefile文件的重新生成过程</span></i></b><b style=""><span style="font-family: 宋体;">。</span></b><span lang="EN-US" style="font-family: 宋体;"><o:p></o:p></span></p>

<h1><a name="_5在规则中使用命令"></a><span lang="EN-US" style="font-size: 18pt; font-family: 宋体;">5在规则中使用命令<o:p></o:p></span></h1>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">规则中的命令由一系列<span lang="EN-US">shell命令行组成，它们一条一条的按顺序执行。除第一条命令行可以分号为开始附属在目标-依赖行后面外，所有的命令行必须以TAB开始。空白行与注释行可在命令行中间出现，处理时它们被忽略。（但是必须注意，以TAB开始的‘空白行’不是空白行，它是空命令，参阅</span></span><b style=""><i><span style="font-family: 宋体;">使用空命令</span></i></b><span style="font-family: 宋体;">。）<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">用户使用多种不同的<span lang="EN-US">shell程序，如果在makefile文件中没有指明其它的shell，则使用缺省的‘/bin/sh’解释makefile文件中的命令。参阅</span></span><b style=""><i><span style="font-family: 宋体;">命令执行</span></i></b><span style="font-family: 宋体;">。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">使用的<span lang="EN-US">shell种类决定了是否能够在命令行上写注释以及编写注释使用的语法。当使用‘/bin/sh’作为shell，以‘#’开始的注释一直延伸到该行结束。‘#’不必在行首，而且‘#’不是注释的一部分。<o:p></o:p></span></span></p>

<h2><a name="_5.1_命令回显"></a><span lang="EN-US" style="font-family: 宋体;">5.1 命令回显<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">正常情况下<span lang="EN-US">make在执行命令之前首先打印命令行，我们因这样可将您编写的命令原样输出故称此为回显。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">以‘<span lang="EN-US">@’起始的行不能回显，‘@’在传输给shell时被丢弃。典型的情况，您可以在makefile文件中使用一个仅仅用于打印某些内容的命令，如echo命令来显示makefile文件执行的进程：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">@echo About to make distribution files<o:p></o:p></span></pre>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">当使用<span lang="EN-US">make时给出‘-n’或‘--just-print’标志，则仅仅回显命令而不执行命令。参阅</span></span><b style=""><i><span style="font-family: 宋体;">选项概要</span></i></b><span style="font-family: 宋体;">。在这种情况下也只有在这种情况下，所有的命令行都回显，即使以‘<span lang="EN-US">@’开始的命令行也回显。这个标志对于在不使用命令的情况下发现make认为哪些是必要的命令非常有用。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">‘<span lang="EN-US">-s’或‘--silent’标志可以使make阻止所有命令回显，好像所有的行都以‘@’开始一样。在makefile文件中使用不带依赖的特别目标‘.SILENT’的规则可以达到相同的效果（参阅</span></span><b style=""><i><span style="font-family: 宋体;">内建的特殊目标名</span></i></b><span style="font-family: 宋体;">）。因为‘<span lang="EN-US">@’使用更加灵活以至于现在已基本不再使用特别目标.SILENT。<o:p></o:p></span></span></p>

<h2><a name="_5.2命令的执行"></a><span lang="EN-US" style="font-family: 宋体;">5.2执行命令<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">需要执行命令更新目标时，每一命令行都会使用一个独立的子<span lang="EN-US">shell环境，保证该命令行得到执行。（实际上，make可能走不影响结果的捷径。）<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 20.6pt;"><b style=""><span style="font-family: 宋体;">请注意</span></b><span style="font-family: 宋体;">：</span><b style=""><span style="font-family: 宋体;">这意味着设置局部变量的<span lang="EN-US">shell命令如cd等将不影响紧跟着的命令行；如果您需要使用cd命令影响到下一个命令，请把这两个命令放到一行，它们中间用分号隔开，这样make将认为它们是一个单一的命令行，把它们放到一起传递给shell，然后按顺序执行它们。</span></span></b><span style="font-family: 宋体;">例如：<span lang="EN-US"><o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">foo : bar/lose<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>cd bar; gobble lose &gt; ../foo<o:p></o:p></span></pre>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">如果您喜欢将一个单一的命令分割成多个文本行，您必须用反斜杠作为每一行的结束，最后一行除外。这样，多个文本行通过删除反斜杠按顺序组成一新行，然后将它传递给<span lang="EN-US">shell。如此，下面的例子和前面的例子是等同的：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">foo : bar/lose<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>cd bar;<span style="">&#160; </span>\<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>gobble lose &gt; ../foo<o:p></o:p></span></pre>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">用作<span lang="EN-US">shell的程序是由变量SHELL指定，缺省情况下，使用程序‘/bin/sh’作为shell。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">在<span lang="EN-US">MS_DOS上运行，如果变量SHELL没有指定，变量COMSPEC的值用来代替指定shell。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">在<span lang="EN-US">MS_DOS上运行和在其它系统上运行，对于makefile文件中设置变量SHELL的行的处理也不一样。因为MS_DOS的shell，‘command.com’，功能十分有限，所以许多make用户倾向于安装一个代替的shell。因此，在MS_DOS上运行，make检测变量SHELL的值，并根据它指定的Unix风格或DOS风格的shell变化它的行为。即使使用变量SHELL指向‘command.com’
，make依然检测变量SHELL的值。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">如果变量<span lang="EN-US">SHELL指定Unix风格的shell，在MS_DOS上运行的make将附加检查指定的shell是否能真正找到；如果不能找到，则忽略指定的shell。在MS_DOS上，GNU
make按照下述步骤搜寻shell:<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span lang="EN-US" style="font-family: 宋体;">1、在变量SHELL指定的目录中。例如，如果makefile指明</span><samp><span lang="EN-US" style="font-family: 宋体;">`SHELL = /bin/sh'</span></samp><span style="font-family: 宋体;">，<span lang="EN-US">make将在当前路径下寻找子目录‘/bin’。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span lang="EN-US" style="font-family: 宋体;">2、</span><span style="font-family: 宋体;">在当前路径下。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span lang="EN-US" style="font-family: 宋体;">3、按顺序搜寻变量PATH指定的目录。<o:p></o:p></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">在所有搜寻的目录中，<span lang="EN-US">make首先寻找指定的文件（如例子中的‘sh’）。如果该文件没有存在，make将在上述目录中搜寻带有确定的可执行文件扩展的文件。例如：</span></span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">.exe'</span></span></tt><span lang="EN-US" style="font-family: 宋体;">, </span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">.com'</span></span></tt><span lang="EN-US" style="font-family: 宋体;">, </span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">.bat'</span></span></tt><span lang="EN-US" style="font-family: 宋体;">, </span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">.btm'</span></span></tt><span lang="EN-US" style="font-family: 宋体;">, </span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">.sh'</span></span></tt><span style="font-family: 宋体;">文件和其它文件等。</span><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;"><o:p></o:p></span></tt></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">如果上述过程中能够成功搜寻一个<span lang="EN-US">shell，则变量SHELL的值将设置为所发现shell的全路径文件名。然而如果上述努力全部失败，变量SHELL的值将不改变，设置shell的行的有效性将被忽略。这是在make运行的系统中如果确实安装了Unix风格的shell，make仅支持指明的Unix风格shell特点的原因。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">注意这种对<span lang="EN-US">shell的扩展搜寻仅仅限制在makefile文件中设置变量SHELL的情况。如果在环境或命令行中设置，希望您指定shell的全路径文件名，而且全路径文件名需象在Unix系统中运行的一样准确无误。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">经过上述的<span lang="EN-US">DOS特色的处理，而且您还把 ‘sh.exe’安装在变量PATH指定的目录中，或在makefile文件内部设置</span></span><samp><span lang="EN-US" style="font-family: 宋体;">`SHELL
= /bin/sh'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <span style="">（和多数Unix的makefile文件一样）</span>，则<span style="">在MS_DOS上的运行效果和在Unix上运行完全一样。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">不像其它大多数变量，变量<span lang="EN-US">SHELL从不根据环境设置。这是因为环境变量SHELL是用来指定您自己选择交互使用的shell程序。如果变量SHELL在环境中设置，它将影响makefile文件的功能，这是非常不划算的，参阅</span></span><b style=""><i><span style="font-family: 宋体;">环境变量</span></i></b><span style="font-family: 宋体;">。然而在<span lang="EN-US">MS-DOS和MS-WINDOWS中在环境中设置变量SHELL的值是要使用的，因为在这些系统中，绝大多数用户并不设置该变量的值，所以make很可能特意为该变量指定要使用的值。在MS-DOS上，如果变量SHELL的设置对于make不合适，您可以设置变量MAKESHELL用来指定make使用的shell；这种设置将使变量SHELL的值失效。<o:p></o:p></span></span></p>

<h2><a name="_5.3_并行执行"></a><span lang="EN-US" style="font-family: 宋体;">5.3 并行执行<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span lang="EN-US" style="font-family: 宋体;">GNU　make可以同时执行几条命令。正常情况下，make一次执行一个命令，待它完成后在执行下一条命令。然而，使用‘-j’和‘--jobs’选项将告诉make同时执行多条命令。在MS-DOS上，‘-j’选项没有作用，因为该系统不支持多进程处理。<o:p></o:p></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">如果‘<span lang="EN-US">-j’选项后面跟一个整数，该整数表示一次执行的命令的条数；这称为job slots数。如果‘-j’选项后面没有整数，也就是没有对job
slots的数目限制。缺省的job slots数是一，这意味着按顺序执行（一次执行一条命令）。同时执行多条命令的一个不太理想的结果是每条命令产生的输出与每条命令发送的时间对应，即命令产生的消息回显可能较为混乱。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">另一个问题是两个进程不能使用同一设备输入，所以必须确定一次只能有一条命令从终端输入，<span lang="EN-US">make只能保证正在运行的命令的标准输入流有效，其它的标准输入流将失效。这意味着如果有几个同时从标准输入设备输入的话，对于绝大多数子进程将产生致命的错误（即产生一个‘Broken
pipe’信号）。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">命令对一个有效的标准输入流（它从终端输入或您为<span lang="EN-US">make改造的标准输入设备输入）的需求是不可预测的。第一条运行的命令总是第一个得到标准输入流，在完成一条命令后第一条启动的另一条命令将得到下一个标准输入流，等等。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">如果我们找到一个更好替换方案，我们将改变<span lang="EN-US">make的这种工作方式。在此期间，如果您使用并行处理的特点，您不应该使用任何需要标准输入的命令。如果您不使用该特点，任何需要标准输入的命令将都能正常工作。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">最后，<span lang="EN-US">make的递归调用也导致出现问题。更详细的内容参阅</span></span><b style=""><i><span style="font-family: 宋体;">与子<span lang="EN-US">make通讯的选项</span></span></i></b><span style="font-family: 宋体;">。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">如果一个命令失败（被一个信号中止，或非零退出），且该条命令产生的错误不能忽略（参阅</span><b style=""><i><span style="font-family: 宋体;">命令错误</span></i></b><span style="font-family: 宋体;">），剩余的构建同一目标的命令行将会停止工作。如果一条命令失败，而且‘<span lang="EN-US">-k’或‘--keep-going’选项也没有给出（参阅</span></span><b style=""><i><span style="font-family: 宋体;">选项概要</span></i></b><span style="font-family: 宋体;">），<span lang="EN-US">make将放弃继续执行。如果make由于某种原因（包括信号）要中止，此时又子进程正在运行，它将等到这些子进程结束之后再实际退出。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">当系统正满负荷运行时，您或许希望在负荷轻的时再添加任务。这时，您可以使用‘<span lang="EN-US">-|’选项告诉make根据平均负荷限制同一时刻运行的任务数量。‘-|’或‘--max-load’选项一般后跟一个浮点数。例如：<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span lang="EN-US" style="font-family: 宋体;">-| 2.5<o:p></o:p></span></p>

<p class="MsoNormal"><span style="font-family: 宋体;">将不允许<span lang="EN-US">make在平均负荷高于2.5时启动一项任务。‘-|’选项如果没有跟数据，则取消前面‘-|’给定的负荷限制。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">更精确地讲，当<span lang="EN-US">make启动一项任务时，而它此时已经有至少一项任务正在运行，则它将检查当前的平均负荷；如果不低于‘-|’选项给定的负荷限制时，make将等待直到平均负荷低于限制或所有其它任务完成后再启动其它任务。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">缺省情况下没有负荷限制。<span lang="EN-US"><o:p></o:p></span></span></p>

<h2><a name="_5.4命令错误"></a><span lang="EN-US" style="font-family: 宋体;">5.4命令错误<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">在每一个<span lang="EN-US">shell命令返回后，make检查该命令退出的状态。如果该命令成功地完成，下一个命令行就会在新的子shell环境中执行，当最后一个命令行完成后，这条规则也宣告完成。如果出现错误（非零退出状态），make将放弃当前的规则，也许是所有的规则。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">有时一个特定的命令失败并不是出现了问题。例如：您可能使用<span lang="EN-US">mkdir命令创建一个目录存在，如果该目录已经存在，mkdir将报告错误，但您此时也许要make继续执行。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">要忽略一个命令执行产生的错误，请使用字符‘<span lang="EN-US">-’（在初始化TAB的后面）作为该命令行的开始。字符‘-’在命令传递给shell执行时丢弃。例如：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">clean:<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>-rm -f *.o<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">这条命令即使在不能删除一个文件时也强制<span lang="EN-US">rm继续执行。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">在运行<span lang="EN-US">make时使用‘-i’或‘--ignore-errors’选项，将会忽略所有规则的命令运行产生的错误。在makefile文件中使用如果没有依赖的特殊目标.IGNORE规则，也具有同样的效果。但因为使用字符‘-’更灵活，所以该条规则已经很少使用。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">一旦使用‘<span lang="EN-US">-’或‘-i’选项，运行命令时产生的错误被忽略，此时make象处理成功运行的命令一样处理具有返回错误的命令，唯一不同的地方是打印一条消息，告诉您命令退出时的编码状态，并说明该错误已经被忽略。如果发生错误而make并不说明其被忽略，则暗示当前的目标不能成功重新构造，并且和它直接相关或间接相关的目标同样不能重建。因为前一个过程没有完成，所以不会进一步执行别的命令。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">在上述情况下，<span lang="EN-US">make一般立即放弃任务，返回一个非零的状态。然而，如果指定‘-k’或‘--keep-goning’选项，make则继续考虑这个目标的其它依赖，如果有必要在make放弃返回非零状态之前重建它们。例如，在编译一个OBJ文件发生错误后，即使make已经知道将所有OBJ文件连接在一起是不可能的，</span></span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">make -k'选项也继续编译其它</span></span></samp><span lang="EN-US" style="font-family: 宋体;">OBJ文件。详细内容参阅</span><b style=""><i><span style="font-family: 宋体;">选项概要</span></i></b><span style="font-family: 宋体;">。通常情况下，<span lang="EN-US">make的行为基于假设您的目的是更新指定的目标，一旦make得知这是不可能的，它将立即报告失败。‘-k’选项是告诉make真正的目的是测试程序中所有变化的可行性，或许是寻找几个独立的问题以便您可以在下次编译之前纠正它们。这是</span></span><span lang="EN-US" style="font-family: 宋体;">Emacs编译命令缺省情况下传递‘-k’选项的原因。<o:p></o:p></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">通常情况下，当一个命令运行失败时，如果它已经改变了目标文件，则该文件很可能发生混乱而不能使用或该文件至少没有完全得到更新。但是，文件的时间戳却表明该文件已经更新到最新，因此在<span lang="EN-US">make下次运行时，它将不再更新该文件。这种状况和命令被发出的信号强行关闭一样，参阅</span></span><b style=""><i><span style="font-family: 宋体;">中断或关闭<span lang="EN-US">make</span></span></i></b><span style="font-family: 宋体;">。因此，如果在开始改变目标文件后命令出错，一般应该删除目标文件。如果</span><code><span lang="EN-US" style="font-family: 宋体;">.DELETE_ON_ERROR作为目标在makefile文件中出现，make将自动做这些事情。这是您应该明确要求make执行的动作，不是以前的惯例；特别考虑到兼容性问题时，您更应明确提出这样的要求。<o:p></o:p></span></code></p>

<h2><a name="_5.5中断或关闭make"></a><code><span lang="EN-US" style="font-family: 宋体;">5.5中断或关闭make<o:p></o:p></span></code></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">如果<span lang="EN-US">make在一条命令运行时得到一个致命的信号， 则make将根据第一次检查的时间戳和最后更改的时间戳是否发生变化决定它是否删除该命令要更新的目标文件。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">删除目标文件的目的是当<span lang="EN-US">make下次运行时确保目标文件从原文件得到更新。为什么？假设正在编译文件时您键入Ctrl-c，而且这时已经开始写OBJ文件‘foo.o’，Ctrl-c关闭了该编译器，结果得到不完整的OBJ文件‘foo.o’的时间戳比源程序‘foo.c’的时间戳新，如果make收到Ctrl-c的信号而没有删除OBJ文件‘foo.o’，下次请求make更新OBJ文件‘foo.o’时，make将认为该文件已更新到最新而没有必要更新，结果在linker将OBJ文件连接为可执行文件时产生奇怪的错误信息。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">您可以将目标文件作为特殊目标<span lang="EN-US">.PRECIOUS的依赖从而阻止make这样删除该目标文件。在重建一个目标之前，make首先检查该目标文件是否出现在特殊目标.PRECIOUS的依赖列表中，从而决定在信号发生时是否删除该目标文件。您不删除这种目标文件的原因可能是：目标更新是一种原子风格，或目标文件存在仅仅为了记录更改时间（其内容无关紧要），或目标文件必须一直存在，用来防止其它类型的错误等。<o:p></o:p></span></span></p>

<h2><a name="_5.6_make的递归调用"></a><span lang="EN-US" style="font-family: 宋体;">5.6递归调用make<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">递归调用意味着可以在<span lang="EN-US">makefile文件中将make作为一个命令使用。这种技术在包含大的系统中把makefile分离为各种各样的子系统时非常有用。例如，假设您有一个子目录‘subdir’，该目录中有它自己的makefile文件，您希望在该子目录中运行make时使用该makefile文件，则您可以按下述方式编写：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160; </span>subsystem:<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>cd subdir &amp;&amp; $(MAKE)<o:p></o:p></span></pre>

<p><span style="font-size: 10.5pt;">或<span lang="EN-US">,
等同于这样写 (参阅<b><i>选项概要</i></b>): <o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">subsystem:<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(MAKE) -C subdir<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">您可以仅仅拷贝上述例子实现<span lang="EN-US">make的递归调用，但您应该了解它们是如何工作的，它们为什么这样工作，以及子make和上层make的相互关系。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">为了使用方便，<span lang="EN-US">GNU make把变量CURDIR的值设置为当前工作的路径。如果‘-C’选项有效，它将包含的是新路径，而不是原来的路径。该值和它在makefile中设置的值有相同的优先权（缺省情况下，环境变量CURDIR不能重载）。注意，操作make时设置该值无效。<o:p></o:p></span></span></p>

<h3><a name="_5.6.1_变量MAKE的工作方式"></a><span lang="EN-US" style="font-size: 14pt; font-family: 宋体;">5.6.1 变量MAKE的工作方式<o:p></o:p></span></h3>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">递归调用<span lang="EN-US">make的命令总是使用变量MAKE，而不是明确的命令名‘make’，如下所示：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">subsystem:<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>cd subdir &amp;&amp; $(MAKE)<o:p></o:p></span></pre>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">该变量的值是调用<span lang="EN-US">make的文件名。如果这个文件名是‘/bin/make’，则执行的命令是</span></span><samp><span lang="EN-US" style="font-family: 宋体;">`cd
subdir &amp;&amp; /bin/make'。如果您在上层makefile文件时用特定版本的make，则执行递归调用时也使用相同的版本。<o:p></o:p></span></samp></p>

<p class="MsoNormal" style="text-indent: 21pt;"><samp><span style="font-family: 宋体;">在命令行中使用变量<span lang="EN-US">MAKE可以改变‘-t'</span></span></samp><span lang="EN-US" style="font-family: 宋体;"> (<samp><span style="">‘--touch'</span></samp>), <samp><span style="">‘-n'</span></samp> (<samp><span style="">‘--just-print'</span></samp>), 或 <samp><span style="">‘-q'</span></samp> (<samp><span style="">‘--question'</span></samp>)选项的效果。如果在使用变量MAKE的命令行首使用字符‘+’也会起到相同的作用。参阅<b><i>代替执行命令</i></b>。<o:p></o:p></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">设想一下在上述例子中命令‘<span lang="EN-US">make -t’的执行过程。（‘-t’选项标志目标已经更新，但却不执行任何命令，</span></span><span style="font-family: 宋体;">参阅<b><i>代替执行命令</i>。）</b>按照通常的定义，命令‘<span lang="EN-US">make
Ct’在上例中仅仅创建名为‘subsystem’的文件而不进行别的工作。您实际要求运行‘cd subdir &amp;&amp; make Ct’干什么？是执行命令或是按照‘-t’的要求不执行命令？<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span lang="EN-US" style="font-family: 宋体;">Make的这个特点是这样的：只要命令行中包含变量MAKE，标志<samp><span style="">`-t'</span></samp>, <samp><span style="">`-n'</span></samp> 和 <samp><span style="">`-q'将不对本行起作用。虽然</span></samp>存在标志不让命令执行，但包含变量MAKE的命令行却正常运行，make实际上是通过变量MAKEFLAGS将标志值传递给了子make（参阅<b><i>与子make通讯的选项</i></b>）。所以您的验证文件、打印命令的请求等都能传递给子系统。<o:p></o:p></span></p>

<h3><a name="_5.6.2与子make的通讯变量"></a><span lang="EN-US" style="font-size: 14pt; font-family: 宋体;">5.6.2与子make通讯的变量<o:p></o:p></span></h3>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">通过明确要求，上层<span lang="EN-US">make变量的值可以借助环境传递给子make，这些变量能在子make中缺省定义，在您不使用‘-e’开关的情况下，传递的变量的值不能代替子make使用的makefile文件中指定的值（参阅<b><i>命令概要</i></b>）。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">向下传递、或输出一个变量时，<span lang="EN-US">make将该变量以及它的值添加到运行每一条命令的环境中。子make，作为响应，使用该环境初始化它的变量值表。参阅<b><i>环境变量</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">除了明确指定外，<span lang="EN-US">make仅向下输出在环境中定义并初始化的或在命令行中设置的变量，而且这些变量的变量名必须仅由字母、数字和下划线组成。一些shell不能处理名字中含有字母、数字和下划线以外字符的环境变量。特殊变量如SHELL和MAKEFLAGS一般总要向下输出（除非您不输出它们）。即使您把变量MAKEFILE设为其它的值，它也向下输出。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span lang="EN-US" style="font-family: 宋体;">Make自动传递在命令行中定义的变量的值，其方法是将它们放入MAKEFLAGS变量中。详细内容参阅下节。Make缺省创造的变量的值不能向下传递，子make可以自己定义它们。如果您要将指定变量输出给子make，请用export指令，格式如下：<o:p></o:p></span></p>

<pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">export <var>variable</var> ...<o:p></o:p></span></pre>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">您要将阻止一些变量输出给子<span lang="EN-US">make，请用unexport指令，格式如下：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">unexport <var>variable</var> ...<o:p></o:p></span></pre>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">为方便起见，您可以同时定义并输出一个变量：<span lang="EN-US"><o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">export <var>variable</var> = value<o:p></o:p></span></pre>

<p><span style="font-size: 10.5pt;">下面的格式具有相同的效果<span lang="EN-US">: <o:p></o:p></span></span></p>

<pre><var><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">variable</span></var><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"> = value<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">export <var>variable</var><o:p></o:p></span></pre>

<p><span style="font-size: 10.5pt;">以及<span lang="EN-US">
<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">export <var>variable</var> := value<o:p></o:p></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">具有相同的效果：<span lang="EN-US"><o:p></o:p></span></span></pre><pre><var><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">variable</span></var><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"> := value<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">export <var>variable</var><o:p></o:p></span></pre>

<p><span style="font-size: 10.5pt;">同样<span lang="EN-US">,
<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">export <var>variable</var> += value<o:p></o:p></span></pre>

<p><span style="font-size: 10.5pt;">亦同样<span lang="EN-US">: <o:p></o:p></span></span></p>

<pre><var><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">variable</span></var><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"> += value<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">export <var>variable</var><o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">参阅<b><i>为变量值追加文本</i></b>。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">您可能注意到<span lang="EN-US">export和unexport指令在make与shell中的工作方式相同，如sh。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">如果您要将所有的变量都输出，您可以单独使用<span lang="EN-US">export：<o:p></o:p></span></span></p>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;">export<o:p></o:p></span></p>

<p class="MsoNormal"><span style="font-family: 宋体;">这告诉<span lang="EN-US">make
把export和unexport没有提及的变量统统输出，但任何在unexport提及的变量仍然不能输出。如果您单独使用export作为缺省的输出变量方式，名字中含有字母、数字和下划线以外字符的变量将不能输出，这些变量除非您明确使用export指令提及才能输出。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">单独使用<span lang="EN-US">export的行为是老板本GNU
make缺省定义的行为。如果您的makefile依靠这些行为，而且您希望和老板本GNU make兼容，您可以为特殊目标</span></span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.EXPORT_ALL_VARIABLES</span></code><span lang="EN-US" style="font-family: 宋体;"> 编写一条规则代替export指令，它将被老板本GNU make忽略，但如果同时使用export指令则报错。<o:p></o:p></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">同样，您可以单独使用<span lang="EN-US">unexport告诉make缺省不要输出变量，因为这是缺省的行为，只有前面单独使用了export（也许在一个包括的makefile中）您才有必要这样做。您不能同时单独使用export和unexport指令实现对某些命令输出对其它的命令不输出。最后面的一条指令（export或unexport）将决定make的全部运行结果。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">作为一个特点，变量<span lang="EN-US">MAKELEVEL的值在从一个层次向下层传递时发生变化。该变量的值是字符型，它用十进制数表示层的深度。‘0’代表顶层make，‘1’代表子make，‘2’代表子-子-make，以此类推。Make为一个命令建立一次环境，该值增加1。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">该变量的主要作用是在一个条件指令中测试（参阅<b><i><span lang="EN-US">makefile文件的条件语句</span></i></b>）；采用这种方法，您可以编写一个<span lang="EN-US">makefile，如果递归调用采用一种运行方式，由您控制直接执行采用另一种运行方式。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">您可以使用变量<span lang="EN-US">MAKEFILES使所有的子make使用附加的makefile文件。变量MAKEFILES的值是makefile文件名的列表，文件名之间用空格隔开。在外层makefile中定义该变量，该变量的值将通过环境向下传递；因此它可以作为子make的额外的makefile文件，在子make读正常的或指定的makefile文件前，将它们读入。参阅<b><i>变量MAKEFILES</i>。</b><o:p></o:p></span></span></p>

<h3><a name="_5.6.3与子make的通讯选项"></a><span lang="EN-US" style="font-size: 14pt; font-family: 宋体;">5.6.3与子make通讯的选项<o:p></o:p></span></h3>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">诸如‘<span lang="EN-US">-s’和‘-k’标志通过变量MAKEFLAGS自动传递给子make。该变量由make自动建立，并包含make收到的标志字母。所以，如果您是用‘make
Cks’变量MAKEFLAGS就得到值‘ks’。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">作为结果，任一个子<span lang="EN-US">make都在它的运行环境中为变量MAKEFLAGS赋值；作为响应，make使用该值作为标志并进行处理，就像它们作为参数被给出一样。参阅<b><i>选项概要</i>。<o:p></o:p></b></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">同样，在命令行中定义的变量也将借助变量<span lang="EN-US">MAKEFLAGS传递给子make。变量MAKEFLAGS值中的字可以包含‘=’，make将它们按变量定义处理，其过程和在命令行中定义的变量一样。参阅<b><i>变量重载</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">选项<samp><span lang="EN-US" style="">`-C'</span></samp><span lang="EN-US">, <samp><span style="">`-f'</span></samp>,
<samp><span style="">`-o'</span></samp>,
和 ‘<samp><span style="">-W’不能放入</span></samp>变量MAKEFLAGS中；这些选项不能向下传递。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">‘<span lang="EN-US">-j’选项是一个特殊的例子（参阅<b><i>并行执行</i></b>）。如果您将它设置为一些数值‘N’，而且您的操作系统支持它（大多数Unix系统支持，其它操作系统不支持），父make和所有子make通讯保证在它们中间同时仅有‘N’个任务运行。注意，任何包含递归调用的任务（参阅<b><i>代替执行命令</i></b>）不能计算在总任务数内（否则，我们仅能得到‘N’个子make运行，而没有多余的时间片运行实在的工作）。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">如果您的操作系统不支持上述通讯机制，那么‘<span lang="EN-US">-j 1’将放到变量MAKEFLAGS中代替您指定的值。这是因为如果‘-j’选项传递给子make，您可能得到比您要求多很多的并行运行的任务数。如果您给出‘-j’选项而没有数字参数，意味着尽可能并行处理多个任务，这样向下传递，因为倍数的无限制性所以至多为1。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">如果您不希望其它的标志向下传递，您必须改变变量<span lang="EN-US">MAKEFLAGS的值，其改变方式如下：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">subsystem:<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>cd subdir &amp;&amp; $(MAKE) MAKEFLAGS=<o:p></o:p></span></pre>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">该命令行中定义变量的实际上出现在变量<span lang="EN-US">MAKEOVERRIDES中，而且变量MAKEFLAGS包含了该变量的引用值。如果您要向下传递标志，而不向下传递命令行中定义的变量，这时，您可以将变量MAKEOVERRIDES的值设为空，格式如下：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">MAKEOVERRIDES =<o:p></o:p></span></pre>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">这并不十分有用。但是，一些系统对环境的大小有固定限制，而且该值较小，将这么多的信息放到变量<span lang="EN-US">MAKEFLAGS的值中可能超过该限制。如果您看到‘<samp><span style="">Arg list too long'的错误信息，很可能就是由于该问题造成的。（按照严格的</span></samp>POSIX.2的规定，如果在makefile文件定义特殊目标‘.POSIX’，改变变量MAKEOVERRIDES的值并不影响变量MAKEFLAGS。也许您并不关心这些。）<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">为了和早期版本兼容，具有相同功能的变量<span lang="EN-US">MFLAGS也是存在的。除了它不能包含命令行定义变量外，它和变量MAKEFLAGS有相同的值，而且除非它是空值，它的值总是以短线开始（MAKEFLAGS只有在和多字符选项一起使用时才以短线开始，如和‘<samp><span style="">--warn-undefined-variables’连用）。变量MFLAGS传统的使用在明确的递归调用make的命令中，例如：<o:p></o:p></span></samp></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">subsystem:<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>cd subdir &amp;&amp; $(MAKE) $(MFLAGS)<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">但现在，变量<span lang="EN-US">MAKEFLAGS使这种用法变得多余。如果您要您的makefile文件和老版本的make程序兼容，请使用这种方式；这种方式在现代版本make中也能很好的工作。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">如果您要使用每次运行<span lang="EN-US">make都要设置的特定选项，例如‘-k’选项（参阅<b><i>选项概要</i></b>），变量MAKEFLAGS十分有用。您可以简单的在环境中将给变量MAKEFLAGS赋值，或在makefile文件中设置变量MAKEFLAGS，指定的附加标志可以对整个makefile文件都起作用。（注意：您不能以这种方式使用变量MFLAGS，变量MFLAGS存在仅为和早期版本兼容，采用其它方式设置该变量make将不予解释。）<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">当<span lang="EN-US">make解释变量MAKEFLAGS值的时候（不管在环境中定义或在makefile文件中定义），如果该值不以短线开始，则make首先为该值假设一个短线；接着将该值分割成字，字与字间用空格隔开，然后将这些字进行语法分析，好像它们是在命令行中给出的选项一样。（<samp><span style="">‘-C'</span></samp>, <samp><span style="">‘-f'</span></samp>,<samp><span style="">‘-h'</span></samp>,<samp><span style="">‘-o'</span></samp>,<samp><span style="">‘-W'</span></samp>选项以及它们的长名字版本都将忽略，对于无效的选项不产生错误信息。）<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">如果您在环境中定义变量<span lang="EN-US">MAKEFLAGS，您不要使用严重影响make运行，破坏makefile文件的意图以及make自身的选项。例如<samp><span style="">‘-t'</span></samp>, <samp><span style="">‘-n'</span></samp>, 和<samp><span style="">‘-q'选项，如果将它们中的一个放到</span></samp>变量MAKEFLAGS的值中，可能产生灾难性的后果，或至少产生让人讨厌的结果。<o:p></o:p></span></span></p>

<h3><a name="_5.6.4_‘--print-directory’选项"></a><span lang="EN-US" style="font-size: 14pt; font-family: 宋体;">5.6.4 ‘<samp><span style="">--print-directory’选项<o:p></o:p></span></samp></span></h3>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">如果您使用几层<span lang="EN-US">make递归调用，使用‘-w’或‘--print-directory’选项，通过显示每个make开始处理以及处理完成的目录使您得到比较容易理解的输出。例如，如果使用‘make
Cw’命令在目录‘/u/gnu/make’中运行make，则make将下面格式输出信息：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">make: Entering directory `/u/gnu/make'.<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">说明进入目录中，还没有进行任何任务。下面的信息：<span lang="EN-US"><o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">make: Leaving directory `/u/gnu/make'.<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">说明任务已经完成。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><span style="font-family: 宋体;">通常情况下，您不必具体指明这个选项，因为<span lang="EN-US">make已经为您做了：当您使用‘-C’选项时，‘-w’选项已经自动打开，在子make中也是如此。如果您使用‘-s’选项，‘-w’选项不会自动打开，因为‘-s’选项是不打印信息，同样使用<samp><span style="">`--no-print-directory'选项</span></samp>‘-w’选项也不会自动打开。<o:p></o:p></span></span></p>

<h2><a name="_5.7定义固定次序的命令"></a><span lang="EN-US" style="font-family: 宋体;">5.7定义固定次序命令<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">在创建各种目标时，相同次序的命令十分有用时，您可以使用<span lang="EN-US">define指令定义固定次序的命令，并根据这些目标的规则引用固定次序。固定次序实际是一个变量，因此它的名字不能和其它的变量名冲突。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">下面是定义固定次序命令的例子：<span lang="EN-US"><o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">define run-yacc<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">yacc $(firstword $^)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">mv y.tab.c $@<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">endef<o:p></o:p></span></pre>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;">run-yacc是定义的变量的名字；endef标志定义结束；中间的行是命令。define指令在固定次序中不对变量引用和函数调用扩展；字符‘$’、圆括号、变量名等等都变成您定义的变量的值的一部分。<b><i>定义多行变量</i></b>一节对指令define有详细解释。<o:p></o:p></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">在该例子中，对于任何使用该固定次序的规则，第一个命令是对其第一个依赖运行<span lang="EN-US">Yacc命令，Yacc命令执行产生的输出文件一律命名为‘y.tab.c’；第二条命令，是将该输出文件的内容移入规则的目标文件中。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">在使用固定次序时，规则中命令使用的变量应被确定的值替代，您可以象替代其它变量一样替代这些变量（详细内容参阅<b><i>变量引用基础</i></b>）。因为由<span lang="EN-US">define指令定义的变量是递归扩展的变量，所以在使用时所有变量引用才扩展。例如：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">foo.c : foo.y<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(run-yacc)<o:p></o:p></span></pre>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">当固定次序‘<span lang="EN-US">run-yacc’运行时，‘foo.y’将代替变量‘$^’，‘foo.c’将代替变量‘$@’。<o:p></o:p></span></span></p>

<p class="MsoNormal"><span style="font-family: 宋体;">这是一个现实的例子，但并不是必要的，因为<span lang="EN-US">make有一条隐含规则可以根据涉及的文件名的类型确定所用的命令。参阅<b><i>使用隐含规则</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">在命令执行时，固定次序中的每一行被处理为和直接出现在规则中的命令行一样，前面加上一个<span lang="EN-US">Tab，make也特别为每一行请求一个独立的子shell。您也可以在固定次序的每一行上使用影响命令行的前缀字符(<samp><span style="">`@'</span></samp>, <samp><span style="">`-'</span></samp>,和 <samp><span style="">`+'</span></samp>)，参阅<b><i>在规则中使用命令</i></b>。例如使用下述的固定次序：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">@echo "frobnicating target $@"<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">frob-step-1 $&lt; -o $@-step-1<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">frob-step-2 $@-step-1 -o $@<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">endef<o:p></o:p></span></pre>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;">make将不回显第一行，但要回显后面的两个命令行。<o:p></o:p></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">另一方面，如果前缀字符在引用固定次序的命令行中使用，则该前缀字符将应用到固定次序的每以行中。例如这个规则：<span lang="EN-US"><o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">frob.out: frob.in<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>@$(frobnicate)<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">将不回显固定次序的任何命令。具体内容参阅<b><i>命令回显</i></b>。<span lang="EN-US"><o:p></o:p></span></span></p>

<h2><a name="_5.8_使用空命令"></a><span lang="EN-US" style="font-family: 宋体;">5.8 使用空命令<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">定义什么也不干的命令有时很有用，定义空命令可以简单的给出一个仅仅含有空格而不含其它任何东西的命令即可。例如：<span lang="EN-US"><o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">target: ;<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">为字符串‘<span lang="EN-US">target’定义了一个空命令。您也可以使用以Tab字符开始的命令行定义一个空命令，但这由于看起来空白容易造成混乱。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">也许您感到奇怪，为什么我们定义一个空命令？唯一的原因是为了阻止目标更新时使用隐含规则提供的命令。（参阅<b><i>使用隐含规则</i></b>以及<b><i>定义最新类型的缺省规则</i></b>）<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">也许您喜爱为实际不存在的目标文件定义空命令，因为这样它的依赖可以重建。然而这样做并不是一个好方法，因为如果目标文件实际存在，则依赖有可能不重建，使用假想目标是较好的选择，参阅<b><i>假想目标</i></b>。<span lang="EN-US"><o:p></o:p></span></span></p>

<h1><a name="_6_使用变量"></a><span lang="EN-US" style="font-size: 18pt; font-family: 宋体;">6 使用变量<o:p></o:p></span></h1>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">变量是在<span lang="EN-US">makefile中定义的名字，其用来代替一个文本字符串，该文本字符串称为该变量的值。在具体要求下，这些值可以代替目标、依赖、命令以及makefile文件中其它部分。（在其它版本的make中，变量称为宏（macros）。）<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">在<span lang="EN-US">makefile文件读入时，除规则中的shell命令、使用‘=’定义的‘=’右边的变量、以及使用define指令定义的变量体此时不扩展外，makefile文件其它各个部分的变量和函数都将扩展。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">变量可以代替文件列表、传递给编译器的选项、要执行的程序、查找源文件的目录、输出写入的目录，或您可以想象的任何文本。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">变量名是不包括<samp><span style="">‘<span lang="EN-US">:'</span></span></samp><span lang="EN-US">,<samp><span style="">‘#'</span></samp>,<samp><span style="">‘='、前导或结尾空格的任何字符串。然而变量名包含字母、数字以及下划线以外的其它字符的情况应尽量避免，因为它们可能在将来被赋予特别的含义，而且对于一些shell它们也不能通过环境传递给子make（参阅<b><i>与子make通讯的变量</i></b>）。变量名是大小写敏感的，例如变量名‘foo'</span></samp>,
<samp><span style="">‘FOO'</span></samp>,
和 <samp><span style="">‘Foo'代表不同的变量。<o:p></o:p></span></samp></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><samp><span style="font-family: 宋体;">使用大写字母作为变量名是以前的习惯，但我们推荐在<span lang="EN-US">makefile内部使用小写字母作为变量名，预留大写字母作为控制隐含规则参数或用户重载命令选项参数的变量名。参阅<b><i>变量重载</i></b>。<o:p></o:p></span></span></samp></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">一少部分的变量使用一个标点符号或几个字符作为变量名，这些变量是自动变量，它们又特定的用途。参阅<b><i>自动变量</i></b>。<span lang="EN-US"><o:p></o:p></span></span></p>

<h2><a name="_6.1_变量引用基础"></a><span lang="EN-US" style="font-family: 宋体;">6.1 变量引用基础<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">写一个美元符号后跟用圆括号或大括号括住变量名则可引用变量的值：<samp><span style="">‘<span lang="EN-US">$(foo)'</span></span></samp><span lang="EN-US"> 和 <samp><span style="">‘${foo}'都是对变量‘foo’的有效引用。‘$’的这种特殊作用是您在命令或文件名中必须写‘$$’才有单个‘$’的效果的原因。<o:p></o:p></span></samp></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">变量的引用可以用在上下文的任何地方：目标、依赖、命令、绝大多数指令以及新变量的值等等。这里有一个常见的例子，在程序中，变量保存着所有<span lang="EN-US">OBJ文件的文件名：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">objects = program.o foo.o utils.o<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">program : $(objects)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>cc -o program $(objects)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">$(objects) : defs.h<o:p></o:p></span></pre>

<p style="margin: 0cm 0cm 1e-04pt;"><span style="font-size: 10.5pt;">变量的引用按照严格的文本替换进行，这样该规则<span lang="EN-US"><o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">foo = c<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">prog.o : prog.$(foo)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(foo)$(foo) -$(foo) prog.$(foo)<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">可以用于编译<span lang="EN-US">C语言源程序‘prog.c’。因为在变量分配时，变量值前面的空格被忽略，所以变量foo的值是‘C’。（不要在您的makefile文件这样写！）<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">美元符号后面跟一个字符但不是美元符号、圆括号、大括号，则该字符将被处理为单字符的变量名。因此可以使用‘<span lang="EN-US">$x’引用变量x。然而，这除了在使用自动变量的情况下，在其它实际工作中应该完全避免。参阅<b><i>自动变量</i></b>。<o:p></o:p></span></span></p>

<h2><a name="_6.2_变量的两个特色"></a><span lang="EN-US" style="font-family: 宋体;">6.2 变量的两个特色<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">在<span lang="EN-US">GNU
make中可以使用两种方式为变量赋值，我们将这两种方式称为变量的两个特色（two flavors）。两个特色的区别在于它们的定义方式和扩展时的方式不同。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">变量的第一个特色是递归调用扩展型变量。这种类型的变量定义方式：在命令行中使用‘<span lang="EN-US">=’定义（参阅<b><i>设置变量</i></b>）或使用define指令定义（参阅<b><i>定义多行变量</i></b>）。变量替换对于您所指定的值是逐字进行替换的；如果它包含对其它变量的引用，这些引用在该变量替换时（或在扩展为其它字符串的过程中）才被扩展。这种扩展方式称为递归调用型扩展。例如：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">foo = $(bar)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">bar = $(ugh)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">ugh = Huh?<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">all:;echo $(foo)<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">将回显<samp><span style="">‘<span lang="EN-US">Huh?'：‘</span></span></samp><span lang="EN-US">$(foo)<samp><span style="">’扩展为‘</span></samp>$(bar)<samp><span style="">’，进一步扩展为‘</span></samp>$(ugh)<samp><span style="">’，最终扩展为‘</span></samp>Huh?<samp><span style="">’。<o:p></o:p></span></samp></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><samp><span style="font-family: 宋体;">这种特色的变量是其它版本<span lang="EN-US">make支持的变量类型，有缺点也有优点。大多数人认为的该类型的变量的优点是：<o:p></o:p></span></span></samp></p>

<pre><span lang="EN-US" style="font-family: 宋体;">CFLAGS = $(include_dirs) -O<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">include_dirs = -Ifoo -Ibar<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">即能够完成希望它完成的任务：当‘<span lang="EN-US">CFLAGS’在命令中扩展时，它将最终扩展为‘-Ifoo -Ibar’。其最大的缺点是不能在变量后追加内容，如在：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">CFLAGS = $(CFLAGS) -O<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">在变量扩展过程中可能导致无穷循环（实际上<span lang="EN-US">make侦测到无穷循环就会产生错误信息）。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">它的另一个缺点是在定义中引用的任何函数时（参阅<b><i>文本转换函数</i></b>）变量一旦展开函数就会立即执行。这可导致<span lang="EN-US">make运行变慢，性能变坏；并且导致通配符与shell函数（因不能控制何时调用或调用多少次）产生不可预测的结果。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">为避免该问题和递归调用扩展型变量的不方便性，出现了另一个特色变量：简单扩展型变量。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">简单扩展型变量在命令行中用‘<span lang="EN-US">:=’定义（参阅<b><i>设置变量</i></b>）。简单扩展型变量的值是一次扫描永远使用，对于引用的其它变量和函数在定义的时候就已经展开。简单扩展型变量的值实际就是您写的文本扩展的结果。因此它不包含任何对其它变量的引用；在该变量定义时就包含了它们的值。所以：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">x := foo<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">y := $(x) bar<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">x := later<o:p></o:p></span></pre>

<p><span style="font-size: 10.5pt;">等同于：<span lang="EN-US"> <o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">y := foo bar<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">x := later<o:p></o:p></span></pre>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">引用一个简单扩展型变量时，它的值也是逐字替换的。这里有一个稍复杂的例子，说明了‘<span lang="EN-US">:=’和shell函数连接用法（参阅<b><i>函数shell</i></b>）。该例子也表明了变量MAKELEVEL的用法，该变量在层与层之间传递时值发生变化。（参阅<b><i>与子make通讯的变量</i></b>，可获得变量MAKELEVEL关于的信息。）<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">ifeq (0,${MAKELEVEL})<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">cur-dir<span style="">&#160;&#160; </span>:= $(shell pwd)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">whoami<span style="">&#160;&#160;&#160; </span>:= $(shell whoami)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">host-type := $(shell arch)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">MAKE := ${MAKE} host-type=${host-type} whoami=${whoami}<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">endif<o:p></o:p></span></pre>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">按照这种方法使用‘<span lang="EN-US">:=’的优点是看起来象下述的典型的‘下降到目录’的命令：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">${subdirs}:<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160; </span>${MAKE} cur-dir=${cur-dir}/$@ -C $@ all<o:p></o:p></span></pre>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">简单扩展型变量因为在绝大多数程序设计语言中可以象变量一样工作，因此它能够使复杂的<span lang="EN-US">makefile程序更具有预测性。它们允许您使用它自己的值重新定义（或它的值可以被一个扩展函数以某些方式处理），它们还允许您使用更有效的扩展函数（参阅<b><i>文本转换函数</i></b>）。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">您可以使用简单扩展型变量将控制的前导空格引入到变量的值中。前导空格字符一般在变量引用和函数调用时被丢弃。简单扩展型变量的这个特点意味着您可以在一个变量的值中包含前导空格，并在变量引用时保护它们。象这样：<span lang="EN-US"><o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">nullstring :=<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">space := $(nullstring) # end of the line<o:p></o:p></span></pre>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">这里变量<span lang="EN-US">space的值就是一个空格，注释‘<samp><span style=""># end of the line</span></samp>’包括在这里为了让人更易理解。因为尾部的空格不能从变量值中分离出去，仅在结尾留一个空格也有同样的效果（但是此时相当难读），如果您在变量值后留一个空格，象这样在行的结尾写上注释清楚表明您的打算是很不错的主意。相反，如果您在变量值后不要空格，您千万记住不要在行的后面留下几个空格再随意放入注释。例如：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">dir := /foo/bar<span style="">&#160;&#160;&#160; </span># directory to put the frobs in<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">这里变量<span lang="EN-US">dir的值是<samp><span style="">‘/foo/bar ’（四个尾部空格），这不是预期的结果。（假设‘/foo/bar’是预期的值）。<o:p></o:p></span></samp></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">另一个给变量赋值的操作符是‘<span lang="EN-US">?=’，它称为条件变量赋值操作符，因为它仅仅在变量还没有定义的情况下有效。这声明：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">FOO ?= bar<o:p></o:p></span></pre>

<p style=""><span style="font-size: 10.5pt;">和下面的语句严格等同（参阅<b><i>函数<span lang="EN-US">origin</span></i></b>）<span lang="EN-US"><o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">ifeq ($(origin FOO), undefined)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160; </span>FOO = bar<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">endif<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">注意，一个变量即使是空值，它仍然已被定义，所以使用‘<span lang="EN-US">?=’定义无效。<o:p></o:p></span></span></p>

<h2><a name="_6.3变量引用高级技术"></a><span lang="EN-US" style="font-family: 宋体;">6.3变量引用高级技术<o:p></o:p></span></h2>

<p class="MsoNormal"><span style="font-family: 宋体;">本节内容介绍变量引用的高级技术。<span lang="EN-US"><o:p></o:p></span></span></p>

<h3><a name="_6.3.1替换引用"></a><span lang="EN-US" style="font-size: 14pt; font-family: 宋体;">6.3.1替换引用<o:p></o:p></span></h3>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">替换引用是用您指定的变量替换一个变量的值。它的形式‘<samp><span lang="EN-US" style="">$(</span></samp><var><span lang="EN-US">var</span></var><samp><span lang="EN-US" style="">:</span></samp><var><span lang="EN-US">a</span></var><samp><span lang="EN-US" style="">=</span></samp><var><span lang="EN-US">b</span></var><samp><span lang="EN-US" style="">)</span></samp>’（或‘<samp><span lang="EN-US" style="">${</span></samp><var><span lang="EN-US">var</span></var><samp><span lang="EN-US" style="">:</span></samp><var><span lang="EN-US">a</span></var><samp><span lang="EN-US" style="">=</span></samp><var><span lang="EN-US">b</span></var><samp><span lang="EN-US" style="">}</span></samp>’），它的含义是把变量<span lang="EN-US">var的值中的每一个字结尾的a用b替换。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">我们说‘在一个字的结尾’，我们的意思是<span lang="EN-US">a一定在一个字的结尾出现，且a的后面要么是空格要么是该变量值的结束，这时的a被替换，值中其它地方的a不被替换。例如：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">foo := a.o b.o c.o<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">bar := $(foo:.o=.c)<o:p></o:p></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">将变量‘<span lang="EN-US">bar’的值设为‘<samp><span style="">a.c b.c c.c</span></samp>’。参阅<b><i>变量设置</i></b>。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">替换引用实际是使用扩展函数<span lang="EN-US">patsubst的简写形式（参阅<b><i>字符串替换和分析函数</i></b>）。我们提供替换引用也是使扩展函数patsubst与make的其它实现手段兼容的措施。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">另一种替换引用是使用强大的扩展函数<span lang="EN-US">patsubst。它的形式和上述的‘<samp><span style="">$(</span></samp><var>var</var><samp><span style="">:</span></samp><var>a</var><samp><span style="">=</span></samp><var>b</var><samp><span style="">)</span></samp>’一样，不同在于它必须包含单个‘%’字符，其实这种形式等同于‘<samp><span style="">$(patsubst </span></samp><var>a</var><samp><span style="">,</span></samp><var>b</var><samp><span style="">,$(</span></samp><var>var</var><samp><span style="">))</span></samp>’。有关于函数patsubst扩展的描述参阅<b><i>字符串替换和分析函数</i></b>。例如：<o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">foo := a.o b.o c.o<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">bar := $(foo:%.o=%.c)<o:p></o:p></span></pre>

<p><span style="font-size: 10.5pt;">社值变量<samp><span style="">‘<span lang="EN-US">bar'</span></span></samp>的值为<samp><span style="">‘<span lang="EN-US">a.c b.c c.c'</span></span></samp>。<span lang="EN-US"><o:p></o:p></span></span></p>

<h3><a name="_6.3.2嵌套变量引用（计算的变量名）"></a><span lang="EN-US" style="font-size: 14pt; font-family: 宋体;">6.3.2嵌套变量引用（计算的变量名）<o:p></o:p></span></h3>

<pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">嵌套变量引用（计算的变量名）是一个复杂的概念，仅仅在十分复杂的<span lang="EN-US">makefile程序中使用。绝大多数情况您不必考虑它们，仅仅知道创建名字中含有美元标志的变量可能有奇特的结果就足够了。然而，如果您是要把一切搞明白的人或您实在对它们如何工作有兴趣，请认真阅读以下内容。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">变量可以在它的名字中引用其它变量，这称为嵌套变量引用（计算的变量名）。例如：<span lang="EN-US"><o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">x = y<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">y = z<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">a := $($(x))<o:p></o:p></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">定义阿<span lang="EN-US">a为‘z’：‘$(x)’在‘$($(x))’中扩展为‘y’，因此‘$($(x))’扩展为‘$(y)’，最终扩展为‘z’。这里对引用的变量名的陈述不太明确；它根据‘$(x)’的扩展进行计算，所以引用‘$(x)’是嵌套在外层变量引用中的。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">前一个例子表明了两层嵌套，但是任何层次数目的嵌套都是允许的，例如，这里有一个三层嵌套的例子：<span lang="EN-US"><o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">x = y<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">y = z<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">z = u<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">a := $($($(x)))<o:p></o:p></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">这里最里面的‘<span lang="EN-US">$(x)’ 扩展为‘y’，因此‘$($(x))’扩展为‘$(y)’，‘$(y)’ 扩展为‘z’，最终扩展为‘u’。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">在一个变量名中引用递归调用扩展型变量，则按通常的风格再扩展。例如：<span lang="EN-US"><o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">x = $(y)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">y = z<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">z = Hello<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">a := $($(x))<o:p></o:p></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">定义的<span lang="EN-US">a是‘Hello’：‘$($(x))’扩展为‘$($(y))’，‘$($(y))’变为‘$(z)’, $(z)’最终扩展为‘Hello’。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">嵌套变量引用和其它引用一样也可以包含修改引用和函数调用（参阅<b><i>文本转换函数</i></b>）。例如，使用函数<span lang="EN-US">subst（参阅<b><i>字符串替换和分析函数</i>）：<o:p></o:p></b></span></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">x = variable1<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">variable2 := Hello<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">y = $(subst 1,2,$(x))<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">z = y<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">a := $($($(z)))<o:p></o:p></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">定义的<span lang="EN-US">a是‘Hello’。任何人也不会写象这样令人费解的嵌套引用程序，但它确实可以工作：‘$($($(z)))’ 扩展为‘$($(y))’，‘$($(y))’变为‘$(subst 1,2,$(x))’。它从变量‘x’得到值‘variable1’,变换替换为‘variable2’，所以整个字符串变为‘$( variable2)’，一个简单的变量引用，它的值为‘Hello’。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">嵌套变量引用不都是简单的变量引用，它可以包含好几个变量引用，同样也可包含一些固定文本。例如，<span lang="EN-US"><o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">a_dirs := dira dirb<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">1_dirs := dir1 dir2<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">a_files := filea fileb<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">1_files := file1 file2<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">ifeq "$(use_a)" "yes"<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">a1 := a<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">else<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">a1 := 1<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">endif<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">ifeq "$(use_dirs)" "yes"<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">df := dirs<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">else<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">df := files<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">endif<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">dirs := $($(a1)_$(df))<o:p></o:p></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">根据设置的<span lang="EN-US">use_a和use_dirs的输入可以将dirs这个相同的值分别赋给<code><span style="">a_dirs</span></code>, <code><span style="">1_dirs</span></code>, <code><span style="">a_files</span></code> 或 <code><span style="">1_files。<o:p></o:p></span></code></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">嵌套变量引用也可以用于替换引用：<span lang="EN-US"><o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">a_objects := a.o b.o c.o<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">1_objects := 1.o 2.o 3.o<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">sources := $($(a1)_objects:.o=.c)<o:p></o:p></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">根据<span lang="EN-US">a1的值，定义的sources可以是<samp><span style="">`a.c b.c c.c'</span></samp> 或 <samp><span style="">`1.c 2.c 3.c'。<o:p></o:p></span></samp></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">使用嵌套变量引用唯一的限制是它们不能只部分指定要调用的函数名，这是因为用于识别函数名的测试在嵌套变量引用扩展之前完成。例如：<span lang="EN-US"><o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">ifdef do_sort<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">func := sort<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">else<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">func := strip<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">endif<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">bar := a d b g q c<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">foo := $($(func) $(bar))<o:p></o:p></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">则给变量‘<span lang="EN-US">foo’的值赋为<samp><span style="">‘sort a d b g q c'</span></samp> 或 <samp><span style="">‘strip a d b g q c'，而不是将‘a d b g q c’作为函数sort或strip的参数。如果在将来去掉这种限制是一个不错的主意。<o:p></o:p></span></samp></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">您也可以变量赋值的左边使用嵌套变量引用，或在<span lang="EN-US">define指令中。如：<o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">dir = foo<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">$(dir)_sources := $(wildcard $(dir)/*.c)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">define $(dir)_print<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">lpr $($(dir)_sources)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">endef<o:p></o:p></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">该例子定义了变量<samp><span style="">‘<span lang="EN-US">dir'</span></span></samp><span lang="EN-US">,<samp><span style="">‘foo_sources'</span></samp>, 和<samp><span style="">‘foo_print'</span></samp>。<o:p></o:p></span></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">注意：虽然嵌套变量引用和递归调用扩展型变量都是用在复杂的<span lang="EN-US">makefile文件中，但二者不同（参阅<b><i>变量的两个特色</i></b>）。<o:p></o:p></span></span></pre>

<h2><a name="_6.4变量的取值"></a><span lang="EN-US" style="font-family: 宋体;">6.4变量取值<o:p></o:p></span></h2>

<pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">变量有以下几种方式取得它们的值：<span lang="EN-US"><o:p></o:p></span></span></pre><pre style="margin-left: 21pt; text-indent: -21pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-size: 10.5pt; font-family: Wingdings;">l<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span></span><!--[endif]--><span style="font-size: 10.5pt; font-family: 宋体;">您可以在运行<span lang="EN-US">make时为变量指定一个重载值。参阅<b><i>变量重载</i></b>。<o:p></o:p></span></span></pre><pre style="margin-left: 21pt; text-indent: -21pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-size: 10.5pt; font-family: Wingdings;">l<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span></span><!--[endif]--><span style="font-size: 10.5pt; font-family: 宋体;">您可以在<span lang="EN-US">makefile文件中指定值，即变量赋值（参阅<b><i>设置变量</i></b>）或使用逐字定义变量（参阅<b><i>定义多行变量</i></b>）。<o:p></o:p></span></span></pre><pre style="margin-left: 21pt; text-indent: -21pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-size: 10.5pt; font-family: Wingdings;">l<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span></span><!--[endif]--><span style="font-size: 10.5pt; font-family: 宋体;">把环境变量变为<span lang="EN-US">make的变量。参阅<b><i>环境变量</i></b>。<o:p></o:p></span></span></pre><pre style="margin-left: 21pt; text-indent: -21pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-size: 10.5pt; font-family: Wingdings;">l<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span></span><!--[endif]--><span style="font-size: 10.5pt; font-family: 宋体;">自动变量可根据规则提供值，它们都有简单的习惯用法，参阅<b><i>自动变量</i></b>。<span lang="EN-US"><o:p></o:p></span></span></pre><pre style="margin-left: 21pt; text-indent: -21pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-size: 10.5pt; font-family: Wingdings;">l<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span></span><!--[endif]--><span style="font-size: 10.5pt; font-family: 宋体;">变量可以用常量初始化。参阅<b><i>隐含规则使用的变量</i></b>。<span lang="EN-US"><o:p></o:p></span></span></pre>

<h2><a name="_6.5设置变量"></a><span lang="EN-US" style="font-family: 宋体;">6.5设置变量<o:p></o:p></span></h2>

<pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">在<span lang="EN-US">makefile文件中设置变量，编写以变量名开始后跟‘=’或‘:=’的一行即可。任何跟在‘=’或‘:=’后面的内容就变为变量的值。例如：<o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">objects = main.o foo.o bar.o utils.o<o:p></o:p></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">定义一个名为<span lang="EN-US">objects的变量，变量名前后的空格和紧跟‘=’的空格将被忽略。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">使用‘<span lang="EN-US">=’定义的变量是递归调用扩展型变量；以‘:=’定义的变量是简单扩展型变量。简单扩展型变量定义可以包含变量引用，而且变量引用在定义的同时就被立即扩展。参阅<b><i>变量的两种特色</i></b>。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">变量名中也可以包含变量引用和函数调用，它们在该行读入时扩展，这样可以计算出能够实际使用的变量名。<span lang="EN-US"><o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">变量值的长度没有限制，但受限于计算机中的实际交换空间。当定义一个长变量时，在合适的地方插入反斜杠，把变量值分为多个文本行是不错的选择。这不影响<span lang="EN-US">make的功能，但可使makefile文件更加易读。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">绝大多数变量如果您不为它设置值，空字符串将自动作为它的初值。虽然一些变量有内建的非空的初始化值，但您可随时按照通常的方式为它们赋值（参阅<b><i>隐含规则使用的变量</i></b>。）另外一些变量可根据规则自动设定新值，它们被称为自动变量。参阅<b><i>自动变量</i></b>。<span lang="EN-US"><o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">如果您喜欢仅对没有定义过的变量赋给值，您可以使用速记符‘<span lang="EN-US">?=’代替‘=’。下面两种设置变量的方式完全等同（参阅<b><i>函数origin</i></b>）：<o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">FOO ?= bar<o:p></o:p></span></pre>

<p>和</p>

<pre><span lang="EN-US" style="font-family: 宋体;">ifeq ($(origin FOO), undefined)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">FOO = bar<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">endif<o:p></o:p></span></pre>

<h2><a name="_6.6_为变量追加更多的文本"></a><span lang="EN-US" style="font-family: 宋体;">6.6 为变量值追加文本<o:p></o:p></span></h2>

<pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">为已经定以过的变量的值追加更多的文本一般比较有用。您可以在独立行中使用‘<span lang="EN-US">+=’来实现上述设想。如：<o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">objects += another.o<o:p></o:p></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">这为变量<span lang="EN-US">objects的值添加了文本‘another.o’（其前面有一个前导空格）。这样：<o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">objects = main.o foo.o bar.o utils.o<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">objects += another.o<o:p></o:p></span></pre>

<p><span style="font-size: 10.5pt;">变量</span><code><span lang="EN-US" style="font-size: 10.5pt;">objects</span></code><span lang="EN-US" style="font-size: 10.5pt;"> 设置为<samp><span style="">‘main.o
foo.o bar.o utils.o another.o'</span></samp>。<o:p></o:p></span></p>

<p><span style="font-size: 10.5pt;">使用 <samp><span lang="EN-US" style="">`+='</span></samp><span lang="EN-US"> 相同于: <o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">objects = main.o foo.o bar.o utils.o<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">objects := $(objects) another.o<o:p></o:p></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">对于使用复杂的变量值，不同方法的差别非常重要。如变量在以前没有定义过，则‘<span lang="EN-US">+=’的作用和‘=’相同：它定义一个递归调用型变量。然而如果在以前有定义，‘+=’的作用依赖于您原始定义的变量的特色，详细内容参阅<b><i>变量的两种特色</i></b>。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">当您使用‘<span lang="EN-US">+=’为变量值附加文本时，make的作用就好象您在初始定义变量时就包含了您要追加的文本。如果开始您使用‘:=’定义一个简单扩展型变量，再用‘+=’对该简单扩展型变量值追加文本，则该变量按新的文本值扩展，好像在原始定义时就将追加文本定义上一样，详细内容参阅<b><i>设置变量</i></b>。实际上，<o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">variable := value<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">variable += more<o:p></o:p></span></pre>

<p><span style="font-size: 10.5pt;">等同于：<span lang="EN-US"><o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">variable := value<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">variable := $(variable) more<o:p></o:p></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">另一方面，当您把‘<span lang="EN-US">+=’和首次使用无符号‘=’定义的递归调用型变量一起使用时，make的运行方式会有所差异。在您引用递归调用型变量时，make并不立即在变量引用和函数调用时扩展您设定的值；而是将它逐字储存起来，将变量引用和函数调用也储存起来，以备以后扩展。当您对于一个递归调用型变量使用‘+=’时，相当于对一个不扩展的文本追加新文本。<o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">variable = value<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">variable += more<o:p></o:p></span></pre>

<p><span style="font-size: 10.5pt;">粗略等同于：<span lang="EN-US"><o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">temp = value<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">variable = $(temp) more<o:p></o:p></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">当然，您从没有定义过叫做<span lang="EN-US">temp的变量，如您在原始定义变量时，变量值中就包含变量引用，此时可以更为深刻地体现使用不同方式定义的的重要性。拿下面常见的例子，<o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">CFLAGS = $(includes) -O<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">...<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">CFLAGS += -pg # enable profiling<o:p></o:p></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">第一行定义了变量<span lang="EN-US">CFLAGS，而且变量CFLAGS引用了其它变量，includes。（变量CFLAGS用于C编译器的规则，参阅<b><i>隐含规则目录</i></b>。）由于定义时使用‘=’，所以变量CFLAGS是递归调用型变量，意味着‘</span></span><span lang="EN-US" style="font-family: 宋体;">$(includes) -O</span><span style="font-size: 10.5pt; font-family: 宋体;">’在<span lang="EN-US">make处理变量CFLAGS定义时是不扩展的；也就是变量includes在生效之前不必定义，它仅需要在任何引用变量CFLAGS之前定义即可。如果我们试图不使用‘+=’为变量CFLAGS追加文本，我们可能按下述方式：<o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">CFLAGS := $(CFLAGS) -pg # enable profiling<o:p></o:p></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">这似乎很好，但结果绝不是我们所希望的。使用‘<span lang="EN-US">:=’重新定义变量CFLAGS为简单扩展型变量，意味着make在设置变量CFLAGS之前扩展了‘$(CFLAGS) -pg’。如果变量includes此时没有定义，我们将得到‘-0 -pg’，并且以后对变量includes的定义也不会有效。相反，使用‘+=’ 设置变量CFLAGS我们得到没有扩展的‘$(CFLAGS) C0 -pg’，这样保留了对变量includes的引用，在后面一个地方如果变量includes得到定义，‘$(CFLAGS)’仍然可以使用它的值。<o:p></o:p></span></span></pre>

<h2><a name="_6.7_override指令"></a><span lang="EN-US" style="font-family: 宋体;">6.7
override指令<o:p></o:p></span></h2>

<pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">如果一个变量设置时使用了命令参数（参阅<b><i>变量重载</i></b>），那么在<span lang="EN-US">makefile文件中通常的对该变量赋值不会生效。此时对该变量进行设置，您需要使用override指令，其格式如下：<o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">override <var>variable</var> = <var>value</var><o:p></o:p></span></pre>

<p><span style="font-size: 10.5pt;">或<span lang="EN-US"><o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">override <var>variable</var> := <var>value</var><o:p></o:p></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">为该变量追加更多的文本，使用：<span lang="EN-US"><o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">override <var>variable</var> += <var>more text</var><o:p></o:p></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">参阅<b><i>为变量值追加文本</i></b>。<span lang="EN-US"><o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">override指令不是打算扩大makefile和命令参数冲突，而是希望用它您可以改变和追加哪些设置时使用了命令参数的变量的值。<o:p></o:p></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">例如，假设您在运行<span lang="EN-US">C编译器时总是使用‘-g’开关，但您允许用户像往常一样使用命令参数指定其它开关，您就可以使用override指令:<o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">override CFLAGS += -g<o:p></o:p></span></pre>

<p><span style="font-size: 10.5pt;">您也可以在<span lang="EN-US">define指令中使用override指令，下面的例子也许就是您想要得： <o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">override define foo<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">bar<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">endef<o:p></o:p></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">关于<span lang="EN-US">define指令的信息参阅下节。<o:p></o:p></span></span></pre>

<h2><a name="_6.8定义多行变量"></a><span lang="EN-US" style="font-family: 宋体;">6.8定义多行变量<o:p></o:p></span></h2>

<pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">设置变量值的另一种方法时使用<span lang="EN-US">define指令。这个指令有一个特殊的用法，既可以定义包含多行字符的变量。这使得定义命令的固定次序十分方便（参阅<b><i>定义固定次序命令</i></b>）。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">在<span lang="EN-US">define指令同一行的后面一般是变量名，当然，也可以什么也没有。变量的值由下面的几行给出，值的结束由仅仅包含endef的一行标示出。除了上述在语法上的不同之外，define指令象‘=’一样工作：它创建了一个递归调用型变量（参阅<b><i>变量的两个特色</i></b>）。变量的名字可以包括函数调用和变量引用，它们在指令读入时扩展，以便能够计算出实际的变量名。<o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">define two-lines<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">echo foo<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">echo $(bar)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">endef<o:p></o:p></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">变量的值在通常的赋值语句中只能在一行中完成，但在<span lang="EN-US">define指令中在define指令行以后endef行之前中间所有的行都是变量值的一部分（最后一行除外，因为标示endef那一行不能认为是变量值的一部分）。前面的例子功能上等同于：<o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">two-lines = echo foo; echo $(bar)<o:p></o:p></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">因为两命令之间用分号隔开，其行为很接近于两个分离的<span lang="EN-US">shell命令。然而，注意使用两个分离的行，意味着make请求shell两次，每一行都在独立的子shell中运行。参阅<b><i>执行命令</i></b>。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">如果您希望使用<span lang="EN-US">define指令的变量定义比使用命令行定义的变量优先，您可以把define指令和override指令一块使用：<o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">override define two-lines<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">foo<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">$(bar)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">endef<o:p></o:p></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">参阅<b><i><span lang="EN-US">override指令</span></i></b>。<span lang="EN-US"><o:p></o:p></span></span></pre>

<h2><a name="_6.9_环境变量"></a><span lang="EN-US" style="font-family: 宋体;">6.9 环境变量<o:p></o:p></span></h2>

<pre style="text-indent: 21pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">make使用的变量可以来自make的运行环境。任何make能够看见的环境变量，在make开始运行时都转变为同名同值的make变量。但是，在makefile文件中对变量的具体赋值，或使用带有参数的命令，都可以对环境变量进行重载（如果明确使用‘-e’标志，环境变量的值可以对makefile文件中的赋值进行重载，参阅<b><i>选项概要</i></b>，但是这在实际中不推荐使用。）<o:p></o:p></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">这样，通过在环境中设置变量<span lang="EN-US">CFLAGS，您可以实现在绝大多数makefile文件中的所有C源程序的编译使用您选择的开关。因为您知道没有makefile将该变量用于其它任务，所以这种使用标准简洁含义的变量是安全的（但这也是不可靠的，一些makefile文件可能设置变量CFLAGS，从而使环境中变量CFLAGS的值失效）。当使用递归调用的make时，在外层make环境中定义的变量，可以传递给内层的make（参阅<b><i>递归调用make</i></b>）。缺省方式下，只有环境变量或在命令行中定义的变量才能传递给内层make。您可以使用export指令传递其它变量，参阅<b><i>与子make通讯的变量</i></b>。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">环境变量的其它使用方式都不推荐使用。将<span lang="EN-US">makefile的运行完全依靠环境变量的设置、超出makefile文件的控制范围，这种做法是不明智的，因为不同的用户运行同一个makefile文件有可能得出不同的结果。这和大部分makefile文件的意图相违背。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">变量<span lang="EN-US">SHELL在环境中存在，用来指定用户对交互的shell的选择，因此使用变量SHELL也存字类似的问题。这种根据选定值影响make运行的方式是很不受欢迎的。所以，make将忽略环境中变量SHELL的值（在MS-DOS 和 MS-Windows中运行例外，但此时变量SHELL通常不设置值，参阅<b><i>执行命令</i></b>）。<o:p></o:p></span></span></pre>

<h2><a name="_6.10_特定目标变量的值"></a><span lang="EN-US" style="font-family: 宋体;">6.10 特定目标变量的值<o:p></o:p></span></h2>

<pre style="text-indent: 21pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">make中变量的值一般是全局性的；既，无论它们在任何地方使用，它们的值是一样的（当然，您重新设置除外）；自动变量是一个例外（参阅<b><i>自动变量</i></b>）。<o:p></o:p></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">另一个例外是特定目标变量的值，这个特点允许您可以根据<span lang="EN-US">make建造目标的变化改变变量的定义。象自动变量一样，这些值只能在一个目标的命令脚本的上下文起作用。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">可以象这样设置特定目标变量的值：<span lang="EN-US"><o:p></o:p></span></span></pre><pre><var><span lang="EN-US" style="font-family: 宋体;">target</span></var><span lang="EN-US" style="font-family: 宋体;"> ... : <var>variable-assignment</var><o:p></o:p></span></pre>

<p><span style="font-size: 10.5pt;">或这样：<span lang="EN-US"><o:p></o:p></span></span></p>

<pre><var><span lang="EN-US" style="font-family: 宋体;">target</span></var><span lang="EN-US" style="font-family: 宋体;"> ... : override <var>variable-assignment</var><o:p></o:p></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">‘</span><var><span lang="EN-US" style="font-family: 宋体;">target</span></var><span lang="EN-US" style="font-family: 宋体;"> ...</span><span style="font-size: 10.5pt; font-family: 宋体;">’中可含有多个目标，如此，则设置的特定目标变量的值可在目标列表中的任一个目标中使用。‘</span><var><span lang="EN-US" style="font-family: 宋体;">variable-assignment</span></var><span style="font-size: 10.5pt; font-family: 宋体;">’使用任何赋值方式都是有效的：递归调用型（‘<span lang="EN-US">=’）、静态（‘:=’）、追加（‘+=’）或条件（‘?=’）。所有出现在‘</span></span><var><span lang="EN-US" style="font-family: 宋体;">variable-assignment</span></var><span style="font-size: 10.5pt; font-family: 宋体;">’中的变量能够在特定目标</span><var><span lang="EN-US" style="font-family: 宋体;">target</span></var><span lang="EN-US" style="font-family: 宋体;"> ...</span><span style="font-size: 10.5pt; font-family: 宋体;">的上下文中使用：也就是任何以前为特定目标</span><var><span lang="EN-US" style="font-family: 宋体;">target</span></var><span lang="EN-US" style="font-family: 宋体;"> ...</span><span style="font-size: 10.5pt; font-family: 宋体;">定义的特定目标变量的值在这些特定目标中都是有效的。注意这种变量值和全局变量值相比是局部的值：这两种类型的变量不必有相同的类型（递归调用<span lang="EN-US">vs.静态）。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">特定目标变量的值和其它<span lang="EN-US">makefile变量具有相同的优先权。一般在命令行中定义的变量（和强制使用‘-e’情况下的环境变量）的值占据优先的地位，而使用override指令定义的特定目标变量的值则占据优先地位。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">特定目标变量的值有另外一个特点：当您定义一个特定目标变量时，该变量的值对特定目标</span><var><span lang="EN-US" style="font-family: 宋体;">target</span></var><span lang="EN-US" style="font-family: 宋体;"> ...的</span><span style="font-size: 10.5pt; font-family: 宋体;">所有依赖有效，除非这些依赖用它们自己的特定目标变量的值将该变量重载。例如：<span lang="EN-US"><o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">prog : CFLAGS = -g<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">prog : prog.o foo.o bar.o<o:p></o:p></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">将在目标<span lang="EN-US">prog的命令脚本中设置变量CFLAGS的值为‘-g’，同时在创建<tt><span style="">`prog.o'</span></tt>, <tt><span style="">`foo.o'</span></tt>, 和 <tt><span style="">`bar.o'的命令脚本中变量CFLAGS的值也是</span></tt>‘-g’，以及<tt><span style="">prog.o'</span></tt>,<tt><span style="">‘foo.o'</span></tt>, 和<tt><span style="">‘bar.o'的依赖的创建命令脚本中变量CFLAGS的值也是</span></tt>‘-g’。<o:p></o:p></span></span></pre>

<h2><a name="_6.11_特定格式变量的值"></a><span lang="EN-US" style="font-family: 宋体;">6.11 特定格式变量的值<o:p></o:p></span></h2>

<pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">除了特定目标变量的值（参阅上小节）外，<span lang="EN-US">GNU make也支持特定格式变量的值。使用特定格式变量的值，可以为匹配指定格式的目标定义变量。在为目标定义特定目标变量后将搜寻按特定格式定义的变量，在为该目标的父目标定义的特定目标变量前也要搜寻按特定格式定义的变量。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">设置特定格式变量格式如下：<span lang="EN-US"><o:p></o:p></span></span></pre><pre><var><span lang="EN-US" style="font-family: 宋体;">pattern</span></var><span lang="EN-US" style="font-family: 宋体;"> ... : <var>variable-assignment</var><o:p></o:p></span></pre>

<p><span style="font-size: 10.5pt;">或这样：<span lang="EN-US"><o:p></o:p></span></span></p>

<pre><var><span lang="EN-US" style="font-family: 宋体;">pattern</span></var><span lang="EN-US" style="font-family: 宋体;"> ... : override <var>variable-assignment</var><o:p></o:p></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">这里的‘<span lang="EN-US">pattern’是%-格式。象特定目标变量的值一样，‘pattern</span></span><span lang="EN-US" style="font-family: 宋体;"> ...</span><span style="font-size: 10.5pt; font-family: 宋体;">’中可含有多个格式，如此，则设置的特定格式变量的值可在匹配列表中的任一个格式中的目标中使用。‘</span><var><span lang="EN-US" style="font-family: 宋体;">variable-assignment</span></var><span style="font-size: 10.5pt; font-family: 宋体;">’使用任何赋值方式都是有效的，在命令行中定义的变量的值占据优先的地位，而使用<span lang="EN-US">override指令定义的特定格式变量的值则占据优先地位。例如：<o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">%.o : CFLAGS = -O<o:p></o:p></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">搜寻所有匹配格式<span lang="EN-US">%.o的目标，并将它的变量CFLAGS的值设置为‘-0’。<o:p></o:p></span></span></pre>

<h1><a name="_7_makefile文件的条件语句"></a><span lang="EN-US" style="font-size: 18pt; font-family: 宋体;">7 makefile文件的条件语句<o:p></o:p></span></h1>

<pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">一个条件语句可以导致根据变量的值执行或忽略<span lang="EN-US">makefile文件中一部分脚本。条件语句可以将一个变量与其它变量的值相比较，或将一个变量与一字符串常量相比较。条件语句用于控制make实际看见的makefile文件部分，不能用于在执行时控制shell命令。<o:p></o:p></span></span></pre>

<h2><a name="_7.1条件语句的例子"></a><span lang="EN-US" style="font-family: 宋体;">7.1条件语句的例子<o:p></o:p></span></h2>

<pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">下述的条件语句的例子告诉<span lang="EN-US">make如果变量CC的值是‘gcc’时使用一个数据库，如不是则使用其它数据库。它通过控制选择两命令行之一作为该规则的命令来工作。‘CC=gcc’作为make改变的参数的结果不仅用于决定使用哪一个编译器，而且决定连接哪一个数据库。<o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">libs_for_gcc = -lgnu<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">normal_libs =<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">foo: $(objects)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">ifeq ($(CC),gcc)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(CC) -o foo $(objects) $(libs_for_gcc)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">else<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(CC) -o foo $(objects) $(normal_libs)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">endif<o:p></o:p></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">该条件语句使用三个指令：<span lang="EN-US">ifeq、else和endif。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">Ifeq指令是条件语句的开始，并指明条件。它包含两个参数，它们被逗号分开，并被扩在圆括号内。运行时首先对两个参数变量替换，然后进行比较。在makefile中跟在ifeq后面的行是符合条件时执行的命令；否则，它们将被忽略。<o:p></o:p></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">如果前面的条件失败，<span lang="EN-US">else指令将导致跟在其后面的命令执行。在上述例子中，意味着当第一个选项不执行时，和第二个选项连在一起的命令将执行。在条件语句中，else指令是可选择使用的。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">Endif指令结束条件语句。任何条件语句必须以endif指令结束，后跟makefile文件中的正常内容。<o:p></o:p></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">上例表明条件语句工作在原文水平：条件语句的行根据条件要么被处理成<span lang="EN-US">makefile文件的一部分或要么被忽略。这是makefile文件重大的语法单位（例如规则）可以跨越条件语句的开始或结束的原因。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">当变量<span lang="EN-US">CC的值是gcc，上例的效果为：<o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">foo: $(objects)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(CC) -o foo $(objects) $(libs_for_gcc)<o:p></o:p></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">当变量<span lang="EN-US">CC的值不是gcc而是其它值的时候，上例的效果为：<o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">foo: $(objects)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(CC) -o foo $(objects) $(normal_libs)<o:p></o:p></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">相同的结果也能使用另一种方法获得：先将变量的赋值条件化，然后再使用变量：<span lang="EN-US"><o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">libs_for_gcc = -lgnu<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">normal_libs =<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">ifeq ($(CC),gcc)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160; </span>libs=$(libs_for_gcc)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">else<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160; </span>libs=$(normal_libs)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">endif<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">foo: $(objects)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(CC) -o foo $(objects) $(libs)<o:p></o:p></span></pre>

<h2><a name="_7.2条件语句的语法"></a><span lang="EN-US" style="font-family: 宋体;">7.2条件语句的语法<o:p></o:p></span></h2>

<pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">对于没有<span lang="EN-US">else指令的条件语句的语法为：<o:p></o:p></span></span></pre><pre><var><span lang="EN-US" style="font-family: 宋体;">conditional-directive</span></var><span lang="EN-US" style="font-family: 宋体;"><o:p></o:p></span></pre><pre><var><span lang="EN-US" style="font-family: 宋体;">text-if-true</span></var><span lang="EN-US" style="font-family: 宋体;"><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">endif<o:p></o:p></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">‘</span><var><span lang="EN-US" style="font-family: 宋体;">text-if-true</span></var><span style="font-size: 10.5pt; font-family: 宋体;">’可以是任何文本行，在条件为‘真’时它被认为是<span lang="EN-US">makefile文件的一部分；如果条件为‘假’，将被忽略。完整的条件语句的语法为：<o:p></o:p></span></span></pre><pre><var><span lang="EN-US" style="font-family: 宋体;">conditional-directive</span></var><span lang="EN-US" style="font-family: 宋体;"><o:p></o:p></span></pre><pre><var><span lang="EN-US" style="font-family: 宋体;">text-if-true</span></var><span lang="EN-US" style="font-family: 宋体;"><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">else<o:p></o:p></span></pre><pre><var><span lang="EN-US" style="font-family: 宋体;">text-if-false</span></var><span lang="EN-US" style="font-family: 宋体;"><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">endif<o:p></o:p></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">如果条件为‘真’，使用‘</span><var><span lang="EN-US" style="font-family: 宋体;">text-if-true</span></var><span style="font-size: 10.5pt; font-family: 宋体;">’；如果条件为‘假’，使用‘</span><var><span lang="EN-US" style="font-family: 宋体;">text-if-false</span></var><span style="font-size: 10.5pt; font-family: 宋体;">’。‘</span><var><span lang="EN-US" style="font-family: 宋体;">text-if-false</span></var><span style="font-size: 10.5pt; font-family: 宋体;">’可以是任意多行的文本。<span lang="EN-US"><o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">关于‘</span><var><span lang="EN-US" style="font-family: 宋体;">conditional-directive</span></var><span style="font-size: 10.5pt; font-family: 宋体;">’的语法对于简单条件语句和复杂条件语句完全一样。有四种不同的指令用于测试不同的条件。下面是指令表：<span lang="EN-US"><o:p></o:p></span></span></pre>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">ifeq (</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">arg1</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">,
</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">arg2</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">ifeq '</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">arg1</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">'
'</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">arg2</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">'</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">ifeq "</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">arg1</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">"
"</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">arg2</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">"</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">ifeq "</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">arg1</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">"
'</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">arg2</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">'</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">ifeq '</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">arg1</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">'
"</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">arg2</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">"</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<pre style=""><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><span style=""> </span>扩展参数arg1、arg2中的所有变量引用，并且比较它们。如果它们完全一致，则使用‘</span><var><span lang="EN-US" style="font-family: 宋体;">text-if-true</span></var><span style="font-size: 10.5pt; font-family: 宋体;">’，否则使用‘</span><var><span lang="EN-US" style="font-family: 宋体;">text-if-false</span></var><span style="font-size: 10.5pt; font-family: 宋体;">’（如果存在的话）。您经常要测试一个变量是否有非空值，当经过复杂的变量和函数扩展得到一个值，对于您认为是空值，实际上有可能由于包含空格而被认为不是空值，由此可能造成混乱。对于此，您可以使用<span lang="EN-US">strip函数从而避免空格作为非空值的干扰。例如：<o:p></o:p></span></span></pre><pre style=""><span lang="EN-US" style="font-family: 宋体;">ifeq ($(strip $(foo)),)<o:p></o:p></span></pre><pre style=""><var><span lang="EN-US" style="font-family: 宋体;">text-if-empty</span></var><span lang="EN-US" style="font-family: 宋体;"><o:p></o:p></span></pre><pre style=""><span lang="EN-US" style="font-family: 宋体;">endif<o:p></o:p></span></pre><pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">即使<span lang="EN-US">$(foo)中含有空格，也使用‘</span></span><var><span lang="EN-US" style="font-family: 宋体;">text-if-empty</span></var><span style="font-size: 10.5pt; font-family: 宋体;">’。<span lang="EN-US"><o:p></o:p></span></span></pre>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">ifneq (</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">arg1</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">,
</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">arg2</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">ifneq '</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">arg1</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">'
'</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">arg2</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">'</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">ifneq "</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">arg1</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">"
"</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">arg2</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">"</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">ifneq "</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">arg1</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">"
'</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">arg2</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">'</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">ifneq '</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">arg1</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">'
"</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">arg2</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">"</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">扩展参数<span lang="EN-US">arg1、arg2中的所有变量引用，并且比较它们。如果它们不同，则使用‘</span></span><var><span lang="EN-US" style="font-family: 宋体;">text-if-true</span></var><span style="font-size: 10.5pt; font-family: 宋体;">’，否则使用‘</span><var><span lang="EN-US" style="font-family: 宋体;">text-if-false</span></var><span style="font-size: 10.5pt; font-family: 宋体;">’（如果存在的话）。<span lang="EN-US"><o:p></o:p></span></span></pre>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">ifdef </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">variable-name</span></var><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">如果变量‘</span><var><span lang="EN-US" style="font-family: 宋体;">variable-name</span></var><span style="font-size: 10.5pt; font-family: 宋体;">’是非空值，‘</span><var><span lang="EN-US" style="font-family: 宋体;">text-if-true</span></var><span style="font-size: 10.5pt; font-family: 宋体;">’有效，否则，‘</span><var><span lang="EN-US" style="font-family: 宋体;">text-if-false</span></var><span style="font-size: 10.5pt; font-family: 宋体;">’有效（如果存在的话）。变量从没有被定义过则变量是空值。<b>注意<span lang="EN-US">ifdef仅仅测试变量是否有值。它不能扩展到看变量是否有非空值。因而，使用ifdef测试所有定义过的变量都返回‘真’，但那些象‘foo=’情况除外。测试空值请使用ifeq($(foo),)。例如：<o:p></o:p></span></b></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">bar =<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">foo = $(bar)<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">ifdef foo<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">frobozz = yes<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">else<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">frobozz = no<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">endif<o:p></o:p></span></pre>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">设置<samp><span style="">‘<span lang="EN-US">frobozz'</span></span></samp>的值为<samp><span style="">‘<span lang="EN-US">yes'</span></span></samp><span lang="EN-US">, 而：: <o:p></o:p></span></span></p>

<pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">foo =<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">ifdef foo<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">frobozz = yes<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">else<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">frobozz = no<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">endif<o:p></o:p></span></pre>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">设置<samp><span style="">‘<span lang="EN-US">frobozz'</span></span></samp><span lang="EN-US"> 为<samp><span style="">‘no'</span></samp>。<o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">ifndef </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">variable-name</span></var><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">如果变量‘</span><var><span lang="EN-US" style="font-family: 宋体;">variable-name</span></var><span style="font-size: 10.5pt; font-family: 宋体;">’是空值，‘</span><var><span lang="EN-US" style="font-family: 宋体;">text-if-true</span></var><span style="font-size: 10.5pt; font-family: 宋体;">’有效，否则，‘</span><var><span lang="EN-US" style="font-family: 宋体;">text-if-false</span></var><span style="font-size: 10.5pt; font-family: 宋体;">’有效（如果存在的话）。<span lang="EN-US"><o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">在指令行前面允许有多余的空格，它们在处理时被忽略，但是不允许有<span lang="EN-US">Tab（如果一行以Tab开始，那么该行将被认为是规则的命令行）。除此之外，空格和Tab可以插入到行的任何地方，当然指令名和参数中间除外。以‘#’开始的注释可以在行的结尾。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">在条件语句中另两个有影响的指令是<span lang="EN-US">else和endif。这两个指令以一个单词的形式出现，没有任何参数。在指令行前面允许有多余的空格，空格和Tab可以插入到行的中间，以‘#’开始的注释可以在行的结尾。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">条件语句影响<span lang="EN-US">make使用的makefile文件。如果条件为‘真’，make读入‘</span></span><var><span lang="EN-US" style="font-family: 宋体;">text-if-true</span></var><span style="font-size: 10.5pt; font-family: 宋体;">’包含的行；如果条件为‘假’，<span lang="EN-US">make读入‘</span></span><var><span lang="EN-US" style="font-family: 宋体;">text-if-false</span></var><span style="font-size: 10.5pt; font-family: 宋体;">’包含的行（如果存在的话）；<span lang="EN-US">makefile文件的语法单位，例如规则，可以跨越条件语句的开始或结束。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">当读入<span lang="EN-US">makefile文件时，Make计算条件的值。因而您不能在测试条件时使用自动变量，因为他们是命令执行时才被定义（参阅<b><i>自动变量</i></b>）。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">为了避免不可忍受的混乱，在一个<span lang="EN-US">makefile文件中开始一个条件语句，而在另外一个makefile文件中结束这种情况是不允许的。然而如果您试图引入包含的makefile文件不中断条件语句，您可以在条件语句中编写include指令。<o:p></o:p></span></span></pre>

<h2><a name="_7.3测试标志的条件语句"></a><span lang="EN-US" style="font-family: 宋体;">7.3测试标志的条件语句<o:p></o:p></span></h2>

<pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">您可以使用变量<span lang="EN-US">MAKEFLAGS和findstring函数编写一个条件语句，用它来测试例如‘-t’等的make命令标志（参阅<b><i>字符串替换和分析的函数</i></b>）。这适用于仅使用touch标志不能完全更改文件的时间戳的场合。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">findstring函数检查一个字符串是否为另一个字符串的子字符串。如果您要测试‘-t’标志，使用‘-t’作为第一个字符串，将变量MAKEFLAGS的值作为另一个字符串。例如下面的例子是安排使用‘ranlib Ct’完成一个档案文件的更新：<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">archive.a: ...<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">ifneq (,$(findstring t,$(MAKEFLAGS)))<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>+touch archive.a<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>+ranlib -t archive.a<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">else<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>ranlib archive.a<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">endif<o:p></o:p></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">前缀‘<span lang="EN-US">+’表示这些命令行是递归调用行，即使是用‘-t’标志它们一样要执行。参阅<b><i>递归调用make</i></b>。<o:p></o:p></span></span></pre>

<h1><a name="_8_文本转换函数"></a><span lang="EN-US" style="font-size: 18pt; font-family: 宋体;">8 文本转换函数<o:p></o:p></span></h1>

<pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">函数允许您在<span lang="EN-US">makefile文件中处理文本、计算文件、操作使用命令等。在函数调用时您必须指定函数名以及函数操作使用的参数。函数处理的结果将返回到makefile文件中的调用点，其方式和变量替换一样。<o:p></o:p></span></span></pre>

<h2><a name="_8.1函数调用语法"></a><span lang="EN-US" style="font-family: 宋体;">8.1函数调用语法<o:p></o:p></span></h2>

<pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">函数调用和变量引用类似，它的格式如下：<span lang="EN-US"><o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">$(<var>function</var> <var>arguments</var>)<o:p></o:p></span></pre>

<p><span style="font-size: 10.5pt;">或这样：<span lang="EN-US"><o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">${<var>function</var> <var>arguments</var>}<o:p></o:p></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">这里‘<span lang="EN-US">function’是函数名，是make内建函数列表中的一个。当然您也可以使用创建函数call创建的您自己的函数。‘</span></span><var><span lang="EN-US" style="font-family: 宋体;">arguments</span></var><span style="font-size: 10.5pt; font-family: 宋体;">’是该函数的参数。参数和函数名之间是用空格或<span lang="EN-US">Tab隔开，如果有多个参数，它们之间用逗号隔开。这些空格和逗号不是参数值的一部分。包围函数调用的定界符，无论圆括号或大括号，可以在参数中成对出现，在一个函数调用中只能有一种定界符。如果在参数中包含变量引用或其它的函数调用，最好使用同一种定界符，如写为<samp><span style="">‘$(subst a,b,$(x))'</span></samp>, 而不是 <samp><span style="">`$(subst a,b,${x})'。这是因为这种方式不但比较清楚，而且也有</span></samp>在一个函数调用中只能有一种定界符的规定。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">为每一个参数写的文本经过变量替换或函数调用处理，最终得到参数的值，这些值是函数执行必须依靠的文本。另外，变量替换是按照变量在参数中出现的次序进行处理的。<span lang="EN-US"><o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">逗号和不成对出现的圆括号、大括号不能作为文本出现在参数中，前导空格也不能出现在第一个参数中。这些字符不能被变量替换处理为参数的值。如果需要使用这些字符，首先定义变量<span lang="EN-US">comma和space，它们的值是单独的逗号和空格字符，然后在需要的地方因用它们，如下例：<o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">comma:= ,<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">empty:=<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">space:= $(empty) $(empty)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">foo:= a b c<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">bar:= $(subst $(space),$(comma),$(foo))<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"># bar is now `a,b,c'.<o:p></o:p></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">这里函数<span lang="EN-US">subst的功能是将变量foo中的空格用逗号替换，然后返回结果。<o:p></o:p></span></span></pre>

<h2><a name="_8.2字符串替换和分析函数"></a><span lang="EN-US" style="font-family: 宋体;">8.2字符串替换和分析函数<o:p></o:p></span></h2>

<pre><span style="font-size: 10.5pt; font-family: 宋体;">这里有一些用于操作字符串的函数：<span lang="EN-US"><o:p></o:p></span></span></pre>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(subst </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">from</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">,</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">to</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">,</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">text</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">在文本‘</span><var><span lang="EN-US" style="font-family: 宋体;">text</span></var><span style="font-size: 10.5pt; font-family: 宋体;">’中使用‘</span><var><span lang="EN-US" style="font-family: 宋体;">to</span></var><span style="font-size: 10.5pt; font-family: 宋体;">’替换每一处‘</span><var><span lang="EN-US" style="font-family: 宋体;">from</span></var><span style="font-size: 10.5pt; font-family: 宋体;">’。例如：<span lang="EN-US"><o:p></o:p></span></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">$(subst ee,EE,feet on the street)<o:p></o:p></span></pre><pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">结果为‘</span><samp><span lang="EN-US" style="font-family: 宋体;">fEEt on the street’。<o:p></o:p></span></samp></pre>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(patsubst </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">pattern</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">,</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">replacement</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">,</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">text</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style=""><span style="font-family: 宋体;">寻找‘<span lang="EN-US">text’中符合格式‘pattern’的字，用‘replacement’替换它们。这里‘pattern’中包含通配符‘%’，它和一个字中任意个数的字符相匹配。如果‘replacement’中也含有通配符‘%’，则这个‘%’被和‘pattern’中通配符‘%’匹配的文本代替。在函数patsubst中的‘%’可以用反斜杠(‘\’)引用。引用字符‘%’的反斜杠可以被更多反斜杠引用。引用字符‘%’和其它反斜杠的反斜杠在比较文件名或有一个stem（径）代替它之前从格式中移出。使用反斜杠引用字符‘%’不会带来其它麻烦。例如，格式</span></span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">the\%weird\\%pattern\\'是</span></span></tt><samp><span style="font-family: 宋体;">‘<span lang="EN-US">the%weird\'</span></span></samp><span lang="EN-US" style="font-family: 宋体;"> 加上通配符<samp><span style="">‘%'</span></samp>然后和字符串<samp><span style="">‘pattern\\'连接。最后的两个反斜杠由于不能影响任何统配符‘%’所以保持不变。在字之间的空格间被压缩为单个空格，前导以及结尾空格被丢弃。例如：<o:p></o:p></span></samp></span></p>

<pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">$(patsubst %.c,%.o,x.c.c bar.c)<o:p></o:p></span></pre><pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">的结果为：<samp><span style="">‘<span lang="EN-US">x.c.o bar.o'。替换引用是实现函数patsubst功能一个简单方法：</span></span></samp></span><samp><span lang="EN-US" style="font-family: 宋体;"><o:p></o:p></span></samp></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">$(<var>var</var>:<var>pattern</var>=<var>replacement</var>)<o:p></o:p></span></pre>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">等同于 ：<span lang="EN-US"><o:p></o:p></span></span></p>

<pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">$(patsubst <var>pattern</var>,<var>replacement</var>,$(<var>var</var>))<o:p></o:p></span></pre><pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">另一个通常使用的函数<span lang="EN-US">patsubst的简单方法是：替换文件名的后缀。<o:p></o:p></span></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">$(<var>var</var>:<var>suffix</var>=<var>replacement</var>)<o:p></o:p></span></pre>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">等同于：<span lang="EN-US"><o:p></o:p></span></span></p>

<pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">$(patsubst %<var>suffix</var>,%<var>replacement</var>,$(<var>var</var>))<o:p></o:p></span></pre><pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">例如您可能有一个<span lang="EN-US">OBJ文件的列表：<o:p></o:p></span></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">objects = foo.o bar.o baz.o<o:p></o:p></span></pre>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">要得到这些文件的源文件，您可以简单的写为：<span lang="EN-US"> <o:p></o:p></span></span></p>

<pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">$(objects:.o=.c)<o:p></o:p></span></pre>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">代替规范的格式：<span lang="EN-US"><o:p></o:p></span></span></p>

<pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">$(patsubst %.o,%.c,$(objects))<o:p></o:p></span></pre>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(strip </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">string</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">去掉前导和结尾空格，并将中间的多个空格压缩为单个空格。这样，<samp><span style="">‘<span lang="EN-US">$(strip a b c )'结果为‘a b c’。函数strip和条件语句连用非常有用。当使用ifeq或ifneq把一些值和空字符串‘’比较时，您通常要将一些仅由空格组成的字符串认为是空字符串（参阅<b><i>makefile中的条件语句</i></b>）。如此下面的例子在实现预期结果时可能失败：<o:p></o:p></span></span></samp></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">.PHONY: all<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">ifneq<span style="">&#160;&#160; </span>"$(needs_made)" ""<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">all: $(needs_made)<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">else<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">all:;@echo 'Nothing to make!'<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">endif<o:p></o:p></span></pre><pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">在条件指令<span lang="EN-US">ifneq中用函数调用<samp><span style="">‘$(strip $(needs_made))'代替变量引用‘$(needs_made)'将不再出现问题。<o:p></o:p></span></samp></span></span></pre>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(findstring </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">find</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">,</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">in</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">在字符串‘<span lang="EN-US">in’中搜寻‘find’，如果找到，则返回值是‘find’，否则返回值为空。您可以在一个条件中使用该函数测试给定的字符串中是否含有特定的子字符串。这样，下面两个例子：<o:p></o:p></span></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">$(findstring a,a b c)<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">$(findstring a,b c)<o:p></o:p></span></pre><pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">将分别产生值‘<span lang="EN-US">a’和‘’。对于函数findstring的特定用法参阅<b><i>测试标志的条件语句</i></b>。<o:p></o:p></span></span></pre>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(filter </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">pattern</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">...,</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">text</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">返回在‘<span lang="EN-US">text’中由空格隔开且匹配格式‘pattern...’的字，对于不符合格式‘pattern...’的字移出。格式用‘%’写出，和前面论述过的函数patsubst的格式相同。函数filter可以用来变量分离类型不同的字符串。例如：<o:p></o:p></span></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">sources := foo.c bar.c baz.s ugh.h<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">foo: $(sources)<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>cc $(filter %.c %.s,$(sources)) -o foo<o:p></o:p></span></pre><pre style=""><span style="font-family: 宋体;">表明<tt><span style="">‘<span lang="EN-US">foo'</span></span></tt><span lang="EN-US"> 依靠<tt><span style="">‘foo.c'</span></tt>,<tt><span style="">‘bar.c'</span></tt>,<tt><span style="">‘baz.s'</span></tt> 和<tt><span style="">‘ugh.h'；</span></tt>但仅有<tt><span style="">‘foo.c'</span></tt>,<tt><span style="">‘bar.c'</span></tt> 和 <tt><span style="">‘baz.s'</span></tt> 指明用命令编译。<o:p></o:p></span></span></pre>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(filter-out </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">pattern</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">...,</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">text</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">返回在‘<span lang="EN-US">text’中由空格隔开且不匹配格式‘pattern...’的字，对于符合格式‘pattern...’的字移出。只是函数filter的反函数。例如：<o:p></o:p></span></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">objects=main1.o foo.o main2.o bar.o<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">mains=main1.o main2.o<o:p></o:p></span></pre>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">下面产生不包含在变量‘<span lang="EN-US">mains’中的OBJ文件的文件列表： <o:p></o:p></span></span></p>

<pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">$(filter-out $(mains),$(objects))<o:p></o:p></span></pre>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(sort </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">list</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">将‘<span lang="EN-US">list’中的字按字母顺序排序，并取掉重复的字。输出是由单个空格隔开的字的列表。<o:p></o:p></span></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">$(sort foo bar lose)<o:p></o:p></span></pre><pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">返回值是‘<span lang="EN-US">bar foo lose’。顺便提及，由于函数sort可以取掉重复的字，您就是不关心排序也可以使用它的这个特点。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">这里有一个实际使用函数<span lang="EN-US">subst和patsubst的例子。假设一个makefile文件使用变量VPATH指定make搜寻依赖文件的一系列路径（参阅<b><i>VPATH:依赖搜寻路径</i></b>）。这个例子表明怎样告诉C编译器在相同路径列表中搜寻头文件。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">变量<span lang="EN-US">VPATH的值是一列用冒号隔开的路径名，如<samp><span style="">‘src:../headers'。首先，函数subst将冒号变为空格：<o:p></o:p></span></samp></span></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">$(subst :, ,$(VPATH))<o:p></o:p></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">这产生值<samp><span style="">‘<span lang="EN-US">src ../headers'。然后，函数patsubst为每一个路径名加入‘-|’标志，这样这些路径可以加到变量CFLAGS中，就可以自动传递给C编译器：<o:p></o:p></span></span></samp></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">override CFLAGS += $(patsubst %,-I%,$(subst :, ,$(VPATH)))<o:p></o:p></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">结果是在以前给定的变量<span lang="EN-US">CFLAGS的值后追加文本‘</span></span><samp><span lang="EN-US" style="font-family: 宋体;">-Isrc -I../headers</span></samp><span style="font-size: 10.5pt; font-family: 宋体;">’。<span lang="EN-US">Override指令的作用是即使以前使用命令参数指定变量CFLAGS的值，新值也能起作用。参阅<b><i>override指令</i></b>。<o:p></o:p></span></span></pre>

<h2><a name="_8.3文件名函数"></a><span lang="EN-US" style="font-family: 宋体;">8.3文件名函数<o:p></o:p></span></h2>

<pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">其中几个内建的扩展函数和拆分文件名以及列举文件名相关联。下面列举的函数都能执行对文件名的特定转换。函数的参数是一系列的文件名，文件名之间用空格隔开（前导和结尾空格被忽略）。列表中的每一个文件名都采用相同的方式转换，而且结果用单个空格串联在一起。<span lang="EN-US"><o:p></o:p></span></span></pre>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(dir </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">names</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">...)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">抽取‘<span lang="EN-US">names’中每一个文件名的路径部分，文件名的路径部分包括从文件名的开始到最后一个斜杠（含斜杠）之前的一切字符。如果文件名中没有斜杠，路径部分是‘./’。如：<o:p></o:p></span></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">$(dir src/foo.c hacks)<o:p></o:p></span></pre>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">产生的结果为
‘<samp><span lang="EN-US" style="">src/ ./’</span></samp>。<span lang="EN-US"> <o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(notdir </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">names</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">...)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">抽取‘<span lang="EN-US">names’中每一个文件名中除路径部分外一切字符（真正的文件名）。如果文件名中没有斜杠，则该文件名保持不变，否则，将路径部分移走。一个文件名如果仅包含路径部分（以斜杠结束的文件名）将变为空字符串。这是非常不幸的，因为这意味着在结果中如果有这种文件名存在，两文件名之间的空格将不是由相同多的空格隔开。但现在我们并不能看到其它任何有效的代替品。例如：<o:p></o:p></span></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">$(notdir src/foo.c hacks)<o:p></o:p></span></pre><pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">产生的结果为‘</span><samp><span lang="EN-US" style="font-family: 宋体;">foo.c hacks</span></samp><span style="font-size: 10.5pt; font-family: 宋体;">’。<span lang="EN-US"><o:p></o:p></span></span></pre>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(suffix </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">names</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">...)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">抽取‘<span lang="EN-US">names’中每一个文件名的后缀。如果文件名中（或含有斜杠，且在最后一个斜杠后）含有句点，则后缀是最后那个句点以后的所有字符，否则，后缀是空字符串。如果结果为空意味着‘names’没有带后缀文件名，如果文件中含有多个文件名，则结果列出的后缀数很可能比原文件名数目少。例如：<o:p></o:p></span></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">$(suffix src/foo.c src-1.0/bar.c hacks)<o:p></o:p></span></pre><pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">产生的结果是‘<span lang="EN-US">.c .c’。<o:p></o:p></span></span></pre>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(basename </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">names</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">...)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">抽取‘<span lang="EN-US">names’中每一个文件名中除后缀外一切字符。如果文件名中（或含有斜杠，且在最后一个斜杠后）含有句点，则基本名字是从开始到最后一个句点（不包含）间的所有字符。如果没有句点，基本名字是整个文件名。例如：<o:p></o:p></span></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">$(basename src/foo.c src-1.0/bar hacks)<o:p></o:p></span></pre>

<p class="MsoNormal" style=""><span style="font-family: 宋体;">产生的结果为‘<samp><span lang="EN-US" style="">src/foo
src-1.0/bar hacks’。</span></samp><span lang="EN-US"> <o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(addsuffix </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">suffix</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">,</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">names</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">...)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">参数‘<span lang="EN-US">names’作为一系列的文件名，文件名之间用空格隔开；suffix作为一个单位。将Suffix（后缀）的值附加在每一个独立文件名的后面，完成后将文件名串联起来，它们之间用单个空格隔开。例如：<o:p></o:p></span></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">$(addsuffix .c,foo bar)<o:p></o:p></span></pre>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">结果为‘<samp><span lang="EN-US" style="">foo.c bar.c’。</span></samp><span lang="EN-US"> <o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(addprefix </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">prefix</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">,</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">names</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">...)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">参数‘<span lang="EN-US">names’作为一系列的文件名，文件名之间用空格隔开；</span></span><var><span lang="EN-US" style="font-family: 宋体; font-style: normal;">prefix</span></var><span style="font-size: 10.5pt; font-family: 宋体;">作为一个单位。将<span lang="EN-US">preffix（前缀）的值附加在每一个独立文件名的前面，完成后将文件名串联起来，它们之间用单个空格隔开。例如：<o:p></o:p></span></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">$(addprefix src/,foo bar)<o:p></o:p></span></pre>

<p class="MsoNormal" style=""><span style="font-family: 宋体;">结果为‘<samp><span lang="EN-US" style="">src/foo
src/bar’。</span></samp><span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(join </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">list1</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">,</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">list2</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">将两个参数串联起来：两个参数的第一个字串联起来形成结果的第一个字，两个参数的第二个字串联起来形成结果的第二个字，以此类推。如果一个参数比另一个参数的字多，则多余的字原封不动的拷贝到结果上。例如，<samp><span style="">‘<span lang="EN-US">$(join a b,.c .o)'</span></span></samp>产生<samp><span style="">‘<span lang="EN-US">a.c b.o'</span></span></samp>。字之间多余的空格不再保留，它们由单个空格代替。该函数可将函数<span lang="EN-US">dir、notdir的结果合并，产生原始给定的文件列表。<o:p></o:p></span></span></pre>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(word </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">,</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">text</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">返回‘<span lang="EN-US">text’中的第n个字。N的合法值从1开始。如果n比‘text’中的字的数目大，则返回空值。例如：<o:p></o:p></span></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">$(word 2, foo bar baz)<o:p></o:p></span></pre>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">返回 <samp><span style="">‘<span lang="EN-US">bar’。</span></span></samp><span lang="EN-US"> <o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(wordlist </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">s</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">,</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">e</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">,</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">text</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">返回‘<span lang="EN-US">text’中的从第s个字开始到第e个字结束的一列字。S、e的合法值从1开始。如果s比‘text’中的字的数目大，则返回空值；如果e比‘text’中的字的数目大，则返回从第s个字开始到‘text’结束的所有字；如果s比e大，不返回任何值。例如：<o:p></o:p></span></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">$(wordlist 2, 3, foo bar baz)<o:p></o:p></span></pre>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">返回<samp><span lang="EN-US" style="">`bar baz'。</span></samp><span lang="EN-US"> <o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(words </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">text</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">返回‘<span lang="EN-US">text’中字的数目。这样‘text’中的最后一个字是‘</span></span><code><span lang="EN-US" style="font-family: 宋体;">$(word $(words </span></code><var><span lang="EN-US" style="font-family: 宋体;">text</span></var><code><span lang="EN-US" style="font-family: 宋体;">),</span></code><var><span lang="EN-US" style="font-family: 宋体;">text</span></var><code><span lang="EN-US" style="font-family: 宋体;">)</span></code><span style="font-size: 10.5pt; font-family: 宋体;">’。<span lang="EN-US"><o:p></o:p></span></span></pre>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(firstword </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">names</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">...)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">参数‘<span lang="EN-US">names’作为一系列的文件名，文件名之间用空格隔开；返回第一个文件名，其余的忽略。例如：<o:p></o:p></span></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">$(firstword foo bar)<o:p></o:p></span></pre>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">产生结果‘<samp><span lang="EN-US" style="">foo’。</span></samp>
虽然 </span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(firstword </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">text</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">)</span></code><span lang="EN-US" style="font-family: 宋体;"> 和 </span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(word
1,</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">text</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">)</span></code><span style="font-family: 宋体;">的作用相同，但第一个函数因为简单而保留下来。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(wildcard </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">pattern</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">参数‘<span lang="EN-US">pattern’是一个文件名格式，典型的包含通配符（和shel中的文件名一样）。函数wildcard的结果是一列和格式匹配的且文件存在的文件名，文件名之间用一个空格隔开，参阅<b><i>在文件名中使用通配符</i></b>。<o:p></o:p></span></span></pre>

<h2><a name="_8.4函数foreach"></a><span lang="EN-US" style="font-family: 宋体;">8.4函数foreach<o:p></o:p></span></h2>

<pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">函数<span lang="EN-US">foreach和其它函数非常不同，它导致一个文本块重复使用，而且每次使用该文本块进行不同的替换；它和shell sh中的命令for及C-shell csh中的命令foreach类似。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">函数<span lang="EN-US">foreach语法如下：<o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">$(foreach <var>var</var>,<var>list</var>,<var>text</var>)<o:p></o:p></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">前两个参数，‘<span lang="EN-US">var’和‘list’，将首先扩展，注意最后一个参数‘text’此时不扩展；接着，对每一个‘list’扩展产生的字，将用来为‘var’扩展后命名的变量赋值；然后‘text’引用该变量扩展；因此它每次扩展都不相同。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">结果是由空格隔开的‘<span lang="EN-US">text’ 在‘list’中多次扩展的字组成的新的‘list’。‘text’多次扩展的字串联起来，字与字之间由空格隔开，如此就产生了函数foreach的返回值。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">这是一个简单的例子，将变量‘<span lang="EN-US">files’的值设置为 ‘dirs’中的所有目录下的所有文件的列表：<o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">dirs := a b c d<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">files := $(foreach dir,$(dirs),$(wildcard $(dir)/*))<o:p></o:p></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">这里‘<span lang="EN-US">text’是‘$(wildcard $(dir)/*)’。第一个为变量dir发现的值是‘a’，所以产生函数foreach结果的第一个字为‘$(wildcard a/*)’；第二个重复的值是‘b’，所以产生函数foreach结果的第二个字为‘$(wildcard b/*)’；第三个重复的值是‘c’，所以产生函数foreach结果的第三个字为‘$(wildcard c/*)’；等等。该例子和下例有共同的结果：<o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">files := $(wildcard a/* b/* c/* d/*)<o:p></o:p></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">如果‘<span lang="EN-US">text’比较复杂，您可以使用附加变量为它命名，这样可以提高程序的可读性：<o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">find_files = $(wildcard $(dir)/*)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">dirs := a b c d<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">files := $(foreach dir,$(dirs),$(find_files))<o:p></o:p></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">这里我们使用变量<span lang="EN-US">find_file。我们定义变量find_file时，使用了‘=’，因此该变量为递归调用型变量，这样变量find_file所包含的函数调用将在函数foreach控制下在扩展；对于简单扩展型变量将不是这样，在变量find_file定义时就调用函数wildcard。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">函数<span lang="EN-US">foreach对变量‘var’没有长久的影响，它的值和变量特色在函数foreach调用结束后将和前面一样，其它从‘list’得到的值仅在函数foreach执行时起作用，它们是暂时的。变量‘var’在函数foreach执行期间是简单扩展型变量，如果在执行函数foreach之前变量‘var’没有定义，则函数foreach调用后也没有定义。参阅<b><i>变量的两个特色</i></b>。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">当使用复杂变量表达式产生变量名时应特别小心，因为许多奇怪的字符作为变量名是有效的，但很可能不是您所需要的，例如：<span lang="EN-US"><o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">files := $(foreach Esta escrito en espanol!,b c ch,$(find_files))<o:p></o:p></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">如果变量<span lang="EN-US">find_file扩展引用名为‘</span></span><span lang="EN-US" style="font-family: 宋体;">Esta escrito en espanol!</span><span style="font-size: 10.5pt; font-family: 宋体;">’变量，上例是有效的，但它极易带来错误。<span lang="EN-US"><o:p></o:p></span></span></pre>

<h2><a name="_8.5函数if"></a><span lang="EN-US" style="font-family: 宋体;">8.5函数if<o:p></o:p></span></h2>

<pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">函数<span lang="EN-US">if对在函数上下文中扩展条件提供了支持（相对于GNU make makefile文件中的条件语句，例如ifeq指令，参阅<b><i>条件语句的语法</i></b>）。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">一个函数<span lang="EN-US">if的调用，可以包含两个或三个参数：<o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">$(if <var>condition</var>,<var>then-part</var>[,<var>else-part</var>])<o:p></o:p></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">第一个参数‘<span lang="EN-US">condition’，首先把前导、结尾空格去掉，然后扩展。如果扩展为非空字符串，则条件‘condition’为‘真’；如果扩展为空字符串，则条件‘condition’为‘假’。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">如果条件‘<span lang="EN-US">condition’为‘真’,那么计算第二个参数‘then-part’的值，并将该值作为整个函数if的值。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">如果条件<span lang="EN-US">‘condition’为‘假’,第三个参数如果存在，则计算第三个参数‘else-part’的值，并将该值作为整个函数if的值；如果第三个参数不存在，函数if将什么也不计算，返回空值。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">注意仅能计算‘<span lang="EN-US">then-part’和‘else-part’二者之一，不能同时计算。这样有可能产生副作用（例如函数shell的调用）。<o:p></o:p></span></span></pre>

<h2><a name="_8.6函数call"></a><span lang="EN-US" style="font-family: 宋体;">8.6函数call<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">函数<span lang="EN-US">call是唯一的创建新的带有参数函数的函数。您可以写一个复杂的表达是作为一个变量的值，然后使用函数call用不同的参数调用它。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">函数<span lang="EN-US">call的语法为：<o:p></o:p></span></span></p>

<pre style="text-indent: 21pt;"><span lang="EN-US" style="font-family: 宋体;">$(call <var>variable</var>,<var>param</var>,<var>param</var>,...)<o:p></o:p></span></pre>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">当<span lang="EN-US">make扩展该函数时，它将每一个参数‘param’赋值给临时变量$(1)、$(2)等；变量$(0)的值是变量‘variable’。对于参数‘param’的数量无没有最大数目限制，也没有最小数目限制，但是如果使用函数call而没有任何参数，其意义不大。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">变量‘<span lang="EN-US">variable’在这些临时变量的上下文中被扩展为一个make变量，这样，在变量‘variable’中对变量‘$(1)’的引用决定了调用函数call时对第一个参数‘param’的使用。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">注意变量‘<span lang="EN-US">variable’是一个变量的名称，不是对该变量的引用，所以，您不能采用‘$’和圆括号的格式书写该变量，当然，如果您需要使用非常量的文件名，您可以在文件名中使用变量引用。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">如果变量名是内建函数名，则该内建函数将被调用（即使使用该名称的<span lang="EN-US">make变量已经存在）。函数call在给临时变量赋值以前首先扩展参数，这意味着，变量‘variable’对内建函数的调用采用特殊的规则进行扩展，象函数foreach或if，它们的扩展结果和您预期的结果可能不同。下面的一些例子能够更清楚的表达这一点。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">该例子时使用宏将参数的顺序翻转：<span lang="EN-US"><o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">reverse = $(2) $(1)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">foo = $(call reverse,a,b)<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">这里变量<span lang="EN-US">foo的值是‘b a’。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">下面是一个很有意思的例子：它定义了一个宏，使用该宏可以搜寻变量<span lang="EN-US">PATH包含的所有目录中的第一个指定类型的程序：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">pathsearch = $(firstword $(wildcard $(addsufix /$(1),$(subst :, ,$(PATH)))))<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">LS := $(call pathsearch,ls)<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">现在变量<span lang="EN-US">LS的值是‘/bin/ls’或其它的类似的值。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">在函数<span lang="EN-US">call中可以使用嵌套。每一次递归调用都可以为它自己的局部变量‘$(1)’等赋值，从而代替上一层函数call赋的值。例如：这实现了映像函数功能。<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">map = $(foreach a,$(2),$(call $(1),$(a)))<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">现在您可以映像（<span lang="EN-US">map）仅有一个参数的函数，如函数origin，一步得到多个值：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">o = $(call map,origin,o map MAKE)<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">最后变量<span lang="EN-US">o包含诸如‘file
file default’这样的值。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 20.6pt;"><b><span style="font-family: 宋体;">警告：在函数<span lang="EN-US">call的参数中使用空格一定要十分小心</span></span></b><span style="font-family: 宋体;">。因为在其它函数中，第二个或接下来的参数中的空格是不删除的，这有可能导致非常奇怪的结果。当您使用函数<span lang="EN-US">call时，去掉参数中任何多余的空格才是最安全的方法。<o:p></o:p></span></span></p>

<h2><a name="_8.7函数origin"></a><span lang="EN-US" style="font-family: 宋体;">8.7函数origin<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">函数<span lang="EN-US">origin不想一般函数，它不对任何变量的值操作；它仅仅告诉您一些关于一个变量的信息；它特别的告诉您变量的来源。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">函数<span lang="EN-US">origin的语法：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">$(origin <var>variable</var>)<o:p></o:p></span></pre>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">注意变量‘<span lang="EN-US">variable’是一个查询变量的名称，不是对该变量的引用所以，您不能采用‘$’和圆括号的格式书写该变量，当然，如果您需要使用非常量的文件名，您可以在文件名中使用变量引用。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">函数<span lang="EN-US">origin的结果是一个字符串，该字符串变量是怎样定义的：<o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span style="font-family: 宋体;">‘<span lang="EN-US">undefined'</span></span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">如果变量‘<span lang="EN-US">variable’从没有定义。<o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span style="font-family: 宋体;">‘<span lang="EN-US">default'</span></span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style=""><span style="font-family: 宋体;">变量‘<span lang="EN-US">variable’是缺省定义，通常和命令CC等一起使用，参阅<b><i>隐含规则使用的变量</i></b>。注意如果您对一个缺省变量重新进行了定义，函数origin将返回后面的定义。<o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span style="font-family: 宋体;">‘<span lang="EN-US">environment'</span></span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">变量‘<span lang="EN-US">variable’作为环境变量定义，选项‘-e’没有打开（参阅<b><i>选项概要</i></b>）</span></span><span style="font-family: 宋体;">。<span lang="EN-US"><o:p></o:p></span></span></pre>

<p class="MsoNormal"><samp><span style="font-family: 宋体;">‘<span lang="EN-US">environment override'</span></span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">变量‘<span lang="EN-US">variable’作为环境变量定义，选项‘-e’已打开（参阅<b><i>选项概要</i></b>）。<o:p></o:p></span></span></pre>

<p class="MsoNormal"><samp><span style="font-family: 宋体;">‘<span lang="EN-US">file'</span></span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<pre style=""><span style="font-family: 宋体;">变量‘<span lang="EN-US">variable’在makefile中定义。<o:p></o:p></span></span></pre>

<p class="MsoNormal"><samp><span style="font-family: 宋体;">‘<span lang="EN-US">command line'</span></span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style=""><span style="font-family: 宋体;">变量‘<span lang="EN-US">variable’在命令行中定义。 <o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span style="font-family: 宋体;">‘<span lang="EN-US">override'</span></span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style=""><span style="font-family: 宋体;">变量‘<span lang="EN-US">variable’在makefile中用override指令定义（参阅<b><i>override指令</i></b>）。<o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span style="font-family: 宋体;">‘<span lang="EN-US">automatic'</span></span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">变量‘<span lang="EN-US">variable’是自动变量，定义它是为了执行每个规则中的命令（参阅<b><i>自动变量</i></b>）。<o:p></o:p></span></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">这种信息的基本用途（其它用途是满足您的好奇心）是使您要了解变量值的依据。例如，假设您有一个名为‘<span lang="EN-US">foo’的makefile文件，它包含了另一个名为‘bar’的makefile文件，如果在环境变量中已经定义变量‘bletch’，您希望运行命令‘make Cf bar’在makefile文件‘bar’中重新定义变量‘bletch’。但是makefile文件‘foo’在包括makefile文件‘bar’之前已经定义了变量‘bletch’，而且您也不想使用override指令定义，那么您可以在makefile文件‘foo’中使用override指令，因为override指令将会重载任何命令行中的定义，所以其定义的优先权超越以后在makefile文件‘bar’中的定义。因此makefile文件‘bar’可以包含：<o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">ifdef bletch<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">ifeq "$(origin bletch)" "environment"<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">bletch = barf, gag, etc.<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">endif<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">endif<o:p></o:p></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">如果变量‘<span lang="EN-US">bletch’在环境中定义，这里将重新定义它。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">即使在使用选项‘<span lang="EN-US">-e’的情况下，您也要对来自环境的变量‘bletch’重载定义，则您可以使用如下内容：<o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">ifneq "$(findstring environment,$(origin bletch))" ""<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">bletch = barf, gag, etc.<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">endif<o:p></o:p></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">如果‘</span><samp><span lang="EN-US" style="font-family: 宋体;">$(origin bletch)</span></samp><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">’返回‘</span><samp><span lang="EN-US" style="font-family: 宋体;">environment</span></samp><span style="font-size: 10.5pt; font-family: 宋体;">’或‘</span><samp><span lang="EN-US" style="font-family: 宋体;">environment override</span></samp><span style="font-size: 10.5pt; font-family: 宋体;">’，这里将对变量‘<span lang="EN-US">bletch’重新定义。参阅<b><i>字符串替换和分析函数</i></b>。<o:p></o:p></span></span></pre>

<h2><a name="_8.8_函数shell"></a><span lang="EN-US" style="font-family: 宋体;">8.8 函数shell<o:p></o:p></span></h2>

<pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">除了函数<span lang="EN-US">wildcard之外，函数shell和其它函数不同，它是make与外部环境的通讯工具。函数shell和在大多数shell中后引号（’）执行的功能一样：它用于命令的扩展。这意味着它起着调用shell命令和返回命令输出结果的参数的作用。Make仅仅处理返回结果，再返回结果替换调用点之前，make将每一个换行符或者一对回车/换行符处理为单个空格；如果返回结果最后是换行符（和回车符），make将把它们去掉。由函数shell调用的命令，一旦函数调用展开，就立即执行。在大多数情况下，当makefile文件读入时函数shell调用的命令就已执行。例外情况是在规则命令行中该函数的调用，因为这种情况下只有在命令运行时函数才能扩展，其它调用函数shell的情况和此类似。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">这里有一些使用函数<span lang="EN-US">shell的例子：<o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">contents := $(shell cat foo)<o:p></o:p></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">将含有文件<span lang="EN-US">foo的目录设置为变量contents的值，是用空格（而不是换行符）分离每一行。<o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">files := $(shell echo *.c)<o:p></o:p></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">将‘<span lang="EN-US">*.c’的扩展设置为变量files的值。除非make使用非常怪异的shell，否则这条语句和‘</span></span><samp><span lang="EN-US" style="font-family: 宋体;">wildcard *.c</span></samp><span style="font-size: 10.5pt; font-family: 宋体;">’的结果相同。<span lang="EN-US"><o:p></o:p></span></span></pre>

<h2><a name="_8.9_控制make的函数"></a><span lang="EN-US" style="font-family: 宋体;">8.9 控制make的函数<o:p></o:p></span></h2>

<pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">这些函数控制<span lang="EN-US">make的运行方式。通常情况下，它们用来向用户提供makefile文件的信息或在侦测到一些类型的环境错误时中断make运行。<o:p></o:p></span></span></pre>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(error </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">text</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">...)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">通常‘<span lang="EN-US">text’是致命的错误信息。注意错误是在该函数计算时产生的，因此如果您将该函数放在命令的脚本中或递归调用型变量赋值的右边，它直到过期也不能计算。‘text’将在错误产生之前扩展，例如：<o:p></o:p></span></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">ifdef ERROR1<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">$(error error is $(ERROR1))<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">endif<o:p></o:p></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">如果变量<span lang="EN-US">ERROR01已经定义，在将makefile文件读入时产生致命的错误。或，<o:p></o:p></span></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">ERR = $(error found an error!)<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">.PHONY: err<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">err: ; $(ERR)<o:p></o:p></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">如果<span lang="EN-US">err目标被调用，在make运行时产生致命错误。<o:p></o:p></span></span></pre>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(warning </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">text</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">...)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">该函数和函数<span lang="EN-US">error工作的方式类似，但此时make不退出，即虽然‘text’扩展并显示结果信息，但make仍然继续执行。扩展该函数的结果是空字符串。<o:p></o:p></span></span></pre>

<h1><a name="_9_运行make"></a><span lang="EN-US" style="font-size: 18pt; font-family: 宋体;">9 运行make<o:p></o:p></span></h1>

<pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">讲述编译程序的<span lang="EN-US">makefile文件，可以由多种方式实现。最简单的方式是编译所有过期的文件，对于通常所写的makefile文件，如果不使用任何参数运行make，那么将这样执行。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">但是您也许仅仅更新一部分文件；您也许需要使用不同的编译器或不同的编译选项；您也许仅仅希望找出过时的文件而不更新它们。这些只有通过在运行<span lang="EN-US">make时给出参数才能实现。退出make状态有三种情况：<o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">0<o:p></o:p></span></pre><pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">表示<span lang="EN-US">make成功完成退出。<o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">2<o:p></o:p></span></pre><pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">退出状态为<span lang="EN-US">2表示make运行中遇到错误，它将打印信息描述错误。<o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">1<o:p></o:p></span></pre><pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">退出状态为<span lang="EN-US">1表示您运行make时使用了‘-q’标志，并且make决定一些文件没有更新。参阅<b><i>代替执行命令</i></b>。<o:p></o:p></span></span></pre>

<h2><a name="_9.1_指定makefile文件的参数"></a><span lang="EN-US" style="font-family: 宋体;">9.1 指定makefile文件的参数<o:p></o:p></span></h2>

<pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">指定<span lang="EN-US">makefile文件名的方法是使用‘-f’或‘--file’选项（‘--makefile’也能工作）。例如，‘-f altmake’说明名为‘altmake’的文件作为makefile文件。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">如果您连续使用‘<span lang="EN-US">-f’标志几次，而且每一个‘-f’后面都带有参数，则所有指定的文件将连在一起作为makefile文件。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">如果您不使用‘<span lang="EN-US">-f’或‘--file’选项，缺省的是按次序寻找</span></span><tt><span style="font-family: 宋体;">‘<span lang="EN-US">GNUmakefile'</span></span></tt><span lang="EN-US" style="font-family: 宋体;">, <tt><span style="">‘makefile'</span></tt>, </span><span style="font-size: 10.5pt; font-family: 宋体;">和</span><span style="font-family: 宋体;"> <tt><span style="">‘<span lang="EN-US">Makefile'</span></span></tt>，</span><span style="font-size: 10.5pt; font-family: 宋体;">使用这三个中第一个能够找到的存在文件或能够创建的文件，参阅<b><i>编写<span lang="EN-US">makefile文件</span></i></b>。<span lang="EN-US"><o:p></o:p></span></span></pre>

<h2><a name="_9.2指定最终目标的参数"></a><span lang="EN-US" style="font-family: 宋体;">9.2指定最终目标的参数<o:p></o:p></span></h2>

<pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">最终目标（<span lang="EN-US">gaol）是make最终努力更新的目标。其它更新的目标是因为它们作为最终目标的依赖，或依赖的依赖，等等以此类推。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">缺省情况下，<span lang="EN-US">makefile文件中的第一个目标是最终目标（不计算那些以句点开始的目标）。因此，makefile文件的第一个编译目标是对整个程序或程序组描述。如果第一个规则同时拥有几个目标，只有该规则的第一个目标是缺省的最终目标。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">您可以使用<span lang="EN-US">make的参数指定最终目标。方法是使用目标的名字作为参数。如果您指定几个最终目标，make按您命名时的顺序一个接一个的处理它们。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">任何在<span lang="EN-US">makefile文件中出现的目标都能作为最终目标（除了以‘-’开始或含有‘=’的目标，它们一种解析为开关，另一种是变量定义）。即使在makefile文件中没有出现的目标，按照隐含规则可以说明怎样生成，也能指定为最终目标。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">Make将在命令行中使用特殊变量MAKECMGOALS设置您指定的最终目标。如果没有在命令行指定最终目标，该变量的值为空值。注意该变量值能在特殊场合下使用。<o:p></o:p></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">一个合适的例子是在清除规则中避免删除包括‘<span lang="EN-US">.d’的文件（参阅<b><i>自动产生依赖</i></b>），因这样make不会一创建它们，就立即又删除它们：<o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">sources = foo.c bar.c<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">ifneq ($(MAKECMDGOALS),clean)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">include $(sources:.c=.d)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">endif<o:p></o:p></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">指定最终目标的一个用途是仅仅编译程序的一部分或程序组中的几个程序。如是这样，您可以将您希望变异的文件指定为最终目标。例如，在一个路径下包含几个程序，一个<span lang="EN-US">makefile文件以下面的格式开始：<o:p></o:p></span></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">.PHONY: all<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">all: size nm ld ar as<o:p></o:p></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">如果您仅对程序<span lang="EN-US">size编译，则您可以使用‘make size’命令，这样就只有您指定的程序才重新编译。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">指定最终目标的另一个用途是编译产生哪些没有正常生成的文件。例如，又一个文件需要调试，或一个版本的程序需要编译进行测试，然而该文件不是<span lang="EN-US">makefile文件规则中缺省最终目标的依赖，此时，可以使用最终目标参数指定它们。<o:p></o:p></span></span></pre><pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">指定最终目标的另一个用途是运行和一个假想目标（参阅<b><i>假想目标</i></b>）或空目标（<b><i>使用空目标记录事件</i></b>）相联系的命令。许多<span lang="EN-US">makefile文件包含一个假想目标‘clean’删除除了原文件以外的所有文件。正常情况下，只有您具体指明使用‘make clean’命令，make才能执行上述任务。下面列出典型的假想目标和空目标的名称。对GNU make软件包使用的所有标准目标名参阅<b><i>用户标准目标</i>：<o:p></o:p></b></span></span></pre>

<p class="MsoNormal"><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">all'</span></span></tt><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">创建<span lang="EN-US">makefile文件的所有顶层目标。<o:p></o:p></span></span></p>

<p class="MsoNormal"><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">`clean'</span></tt><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">删除所有<span lang="EN-US">make正常创建的文件。<o:p></o:p></span></span></p>

<p class="MsoNormal"><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">`mostlyclean'</span></tt><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">象假象目标‘<span lang="EN-US">clean’，但避免删除人们正常情况下不重新建造的一少部分文件。例如，用于GCC的目标‘</span></span><tt><span lang="EN-US" style="font-family: 宋体;">mostlyclean</span></tt><span style="font-size: 10.5pt; font-family: 宋体;">’不删除‘</span><tt><span lang="EN-US">libgcc.a</span></tt><span style="font-size: 10.5pt; font-family: 宋体;">’，因为重建它的情况十分稀少，而且创建它又需要很多时间。<span lang="EN-US"><o:p></o:p></span></span></pre>

<p class="MsoNormal"><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">`distclean'</span></tt><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">`realclean'</span></tt><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">`clobber'</span></tt><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">这些目标可能定义为比目标‘<span lang="EN-US">clean’ 删除更多的文件。例如，删除配置文件或为编译正常创建的准备文件，甚至makefile文件自身不能创建的文件。<o:p></o:p></span></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">‘<span lang="EN-US">install’<o:p></o:p></span></span></pre><pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">向命令搜寻目录下拷贝可执行文件；向可执行文件寻找目录下拷贝可执行文件使用的辅助文件。<span lang="EN-US"><o:p></o:p></span></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">‘<span lang="EN-US">print’<o:p></o:p></span></span></pre><pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">打印发生变化的文件列表。<span lang="EN-US"><o:p></o:p></span></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">‘<span lang="EN-US">tar’<o:p></o:p></span></span></pre><pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">创建源文件的压缩‘<span lang="EN-US">tar’文件。<o:p></o:p></span></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">‘<span lang="EN-US">shar’<o:p></o:p></span></span></pre><pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">为源文件创建一个<span lang="EN-US">shell的档案文件。<o:p></o:p></span></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">‘<span lang="EN-US">dist’<o:p></o:p></span></span></pre><pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">为源文件创建一个发布文件。这可能是‘<span lang="EN-US">tar’文件， ‘shar’文件，或多个上述的压缩版本文件。<o:p></o:p></span></span></pre><pre><span style="font-size: 10.5pt; font-family: 宋体;">‘<span lang="EN-US">TAGS’<o:p></o:p></span></span></pre><pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">更新该程序的‘<span lang="EN-US">tags’标签。<o:p></o:p></span></span></pre>

<p class="MsoNormal"><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">`check'</span></tt><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">`test'</span></tt><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">对该<span lang="EN-US">makefile文件创建的程序执行自我测试。<o:p></o:p></span></span></pre>

<h2><a name="_9.3_代替执行命令"></a><span lang="EN-US" style="font-family: 宋体;">9.3 代替执行命令<o:p></o:p></span></h2>

<pre style="text-indent: 21pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">makefile文件告诉make怎样识别一个目标是否需要更新以及怎样更新每一个目标。但是更新目标并不是您一直需要的，一些特定的选项可以用来指定make的其它活动：<o:p></o:p></span></pre>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`-n'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--just-print'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--dry-run'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--recon'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<pre style="text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: 宋体;">‘<span lang="EN-US">No-op’。make的这项活动是打印用于创建目标所使用的命令，但并不执行它们。<o:p></o:p></span></span></pre>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`-t'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--touch'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">‘<span lang="EN-US">touch’。这项活动是做更新标志，实际却不更改它们。换句话说，make假装编译了目标，但实际对它们没有一点儿改变。<o:p></o:p></span></span></pre>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`-q'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--question'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">‘<span lang="EN-US">question’。这项活动是暗中察看目标是否已经更新；但是任何情况下也不执行命令。换句话说，即不编译也不输出。<o:p></o:p></span></span></pre>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`-W </span></samp><var><span lang="EN-US" style="font-family: 宋体;">file</span></var><samp><span lang="EN-US" style="font-family: 宋体;">'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--what-if=</span></samp><var><span lang="EN-US" style="font-family: 宋体;">file</span></var><samp><span lang="EN-US" style="font-family: 宋体;">'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--assume-new=</span></samp><var><span lang="EN-US" style="font-family: 宋体;">file</span></var><samp><span lang="EN-US" style="font-family: 宋体;">'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--new-file=</span></samp><var><span lang="EN-US" style="font-family: 宋体;">file</span></var><samp><span lang="EN-US" style="font-family: 宋体;">'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<pre style=""><span style="font-size: 10.5pt; font-family: 宋体;">‘<span lang="EN-US">What if’。每一个‘-W’标志后跟一个文件名。所有文件名的更改时间被make记录为当前时间，但实际上更改时间保持不变。如果您要更新文件，您可以使用‘-W’标志和‘-n’标志连用看看将发生什么。<o:p></o:p></span></span></pre>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">使用标志‘<span lang="EN-US">-n’，make打印那些正常执行的命令，但却不执行它们。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">使用标志‘<span lang="EN-US">-t’，make忽略规则中的命令，对那些需要更新的目标使用‘touch’命令。如果不使用‘-s’或.SILENT，‘touch’命令同样打印。为了提高执行效率，make并不实际调用程序touch，而是使touch直接运行。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">使用标志‘<span lang="EN-US">-q’，make不打印输出也不执行命令，如果所有目标都已经更新到最新，make的退出状态是0；如果一部分需要更新，退出状态是1；如果make遇到错误，退出状态是2，因此您可以根据没有更新的目标寻找错误。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">在运行<span lang="EN-US">make时对以上三个标志如果同时两个或三个将产生错误。标志‘-n’、‘-t’和‘-s’对那些以字符‘+’开始的命令行和包含字符串‘<samp><span style="">$(MAKE)'</span></samp> 或‘<samp><span style="">${MAKE}'命令行不起作用。注意仅有这些</span></samp>以字符‘+’开始的命令行和包含字符串‘<samp><span style="">$(MAKE)'</span></samp> 或‘<samp><span style="">${MAKE}'命令行运行时不注意这些选项。参阅<b><i>变量MAKE的工作方式</i>。</b><o:p></o:p></span></samp></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><samp><span style="font-family: 宋体;">‘<span lang="EN-US">-W’标志有一下两个特点：<o:p></o:p></span></span></samp></p>

<p class="MsoNormal" style="margin-left: 42pt; text-indent: -21pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: Wingdings;">l<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><!--[endif]--><span style="font-family: 宋体;">如果同时使用标志‘<span lang="EN-US">-n’或‘-q’，如果您更改一部分文件，看看make将会做什么。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 42pt; text-indent: -21pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: Wingdings;">l<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><!--[endif]--><span style="font-family: 宋体;">没有使用标志‘<span lang="EN-US">-n’或‘-q’，如果make运行时采用标志‘-W’，则make假装所有文件已经更新，但实际上不更改任何文件。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">注意选项‘<span lang="EN-US">-p’和‘-v’允许您得到更多的make信息或正在使用的makefile文件的信息（参阅<b><i>选项概要</i></b>）。<o:p></o:p></span></span></p>

<h2><a name="_9.4避免重新编译一些文件"></a><span lang="EN-US" style="font-family: 宋体;">9.4避免重新编译文件<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">有时您可能改变了一个源文件，但您并不希望编译所有依靠它的文件。例如，假设您在一个许多文件都依靠的头文件种添加了一个宏或一个声明，按照保守的规则，<span lang="EN-US">make认为任何对于该头文件的改变，需要编译所有依靠它的文件，但是您知道那是不必要的，并且您没有等待它们完全编译的时间。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">如果您提前了解改变头文件以前的问题，您可以使用‘<span lang="EN-US">-t’选项。该标志告诉make不运行规则中的命令，但却将所有目标的时间戳改到最新。您可按下述步骤实现上述计划：<o:p></o:p></span></span></p>

<p class="MsoNormal" style=""><span lang="EN-US" style="font-family: 宋体;">1、用make命令重新编译那些需要编译的源文件；<o:p></o:p></span></p>

<p class="MsoNormal" style=""><span lang="EN-US" style="font-family: 宋体;">2、更改头文件；<o:p></o:p></span></p>

<p class="MsoNormal" style=""><span lang="EN-US" style="font-family: 宋体;">3、使用‘make Ct’命令改变所有目标文件的时间戳，这样下次运行make时就不会因为头文件的改变而编译任何一个文件。<o:p></o:p></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">如果在重新编译那些需要编译的源文件前已经改变了头文件，则按上述步骤做已显得太晚了；作为补救措施，您可以使用‘<span lang="EN-US">-o file’标志，它能将指定的文件的时间戳假装改为以前的时间戳（参阅<b><i>选项概要</i></b>）。这意味着该文件没有更改，因此您可按下述步骤进行：<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span lang="EN-US" style="font-family: 宋体;">1、使用‘make
-o file’命令重新编译那些不是因为改变头文件而需要更新的文件。如果涉及几个头文件，您可以对每个头文件都使用‘-o’标志进行指定。<o:p></o:p></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span lang="EN-US" style="font-family: 宋体;">2、使用‘make Ct’命令改变所有目标文件的时间戳。<o:p></o:p></span></p>

<h2><a name="_9.5重载变量"></a><span lang="EN-US" style="font-family: 宋体;">9.5变量重载<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">使用‘<span lang="EN-US">=’定义的变量：‘v=x’将变量v的值设为x。如果您用该方法定义了一个变量，
在makefile文件后面任何对该变量的普通赋值都将被make忽略，要使它们生效应在命令行将它们重载。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">最为常见的方法是使用传递附加标志给编译器的灵活性。例如，在一个<span lang="EN-US">makefile文件中，变量CFLAGS已经包含了运行C编译器的每一个命令，因此，如果仅仅键入命令make时，文件‘foo.c’将按下面的方式编译：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">cc -c $(CFLAGS) foo.c<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">这样您在<span lang="EN-US">makefile文件中对变量CFALAGS设置的任何影响编译器运行的选项都能生效，但是每次运行make时您都可以将该变量重载，例如：如果您说‘<samp><span style="">make CFLAGS='-g -O'</span></samp>’，任何C编译器都将使用‘<samp><span style="">cc -c -g -O</span></samp>’编译程序。这还说明了在重载变量时，怎样使用shell命令中的引用包括空格和其它特殊字符在内的变量的值。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">变量<span lang="EN-US">CFALAGS仅仅是您可以使用这种方式重载的许多标准变量中的一个，这些标准变量的完整列表见<b><i>隐含规则使用的变量</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">您也可以编写<span lang="EN-US">makefile察看您自己的附加变量，从而使用户可通过更改这些变量控制make运行时的其它面貌。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">当您使用命令参数重载变量时，您可以定义递归调用扩展型变量或简单扩展型变量。上例中定义的是递归调用扩展型变量，如果定义简单扩展型变量，请使用‘<span lang="EN-US">:=’代替‘=’。注意除非您在变量值中使用变量引用或函数调用，这两种变量没有任何差异。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">利用这种方式也可以改变您在<span lang="EN-US">makfile文件中重载的变量。在makfile文件中重载的变量是使用override指令，是和‘<samp><span style="">override </span></samp><var>variable</var><samp><span style=""> = </span></samp><var>value</var>’相似的命令行。详细内容参阅<b><i>override指令</i></b>。<o:p></o:p></span></span></p>

<h2><a name="_9.6_测试编译程序"></a><span lang="EN-US" style="font-family: 宋体;">9.6 测试编译程序<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">正常情况下，在执行<span lang="EN-US">shell命令时一旦有错误发生，make立即退出返回非零状态；不会为任何目标继续运行命令。错误表明make不能正确的创建最终目标，并且make一发现错误就立即报告。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">当您编译您修改过的程序时，这不是您所要的结果。您希望<span lang="EN-US">make能够经可能的试着编译每一个程序，并尽可能的显示每一个错误。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">这种情况下，您可以使用‘<span lang="EN-US">-k’或‘--keep-going’选项。这种选项告诉make遇到错误返回非零状态之前，继续寻找该目标的依赖，如果有必要则重新创建它们。例如，在编译一个目标文件时发现错误，即使make已经知道连接它们已是不可能的,
‘make Ck’也将继续编译其它目标文件。除在shell命令失败后继续运行外，即使发在make不知道如何创建的目标和依赖文件以后，‘make Ck’也将尽可能的继续运行。在没有‘-k’选项时，这些错误将是致命的（参阅<b><i>选项概要</i></b>）。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">通常情况下，<span lang="EN-US">make的行为是基于假设您的目标是使最终目标更新；一旦它发现这是不可能的它就立即报告错误。选项‘-k’说真正的目标是尽可能测试改变对程序的影响，发现存在的问题，以便在下次运行之前您可以纠正它们。这是Emacs
M-x compile命令缺省传递‘-k’选项的原因。<o:p></o:p></span></span></p>

<h2><a name="_9.7_选项概要"></a><span lang="EN-US" style="font-family: 宋体;">9.7 选项概要<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">下面是所有<span lang="EN-US">make能理解的选项列表：<o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`-b'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`-m'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">和其它版本<span lang="EN-US">make兼容时，这些选项被忽略。<o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`-C </span></samp><var><span lang="EN-US" style="font-family: 宋体;">dir</span></var><samp><span lang="EN-US" style="font-family: 宋体;">'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--directory=</span></samp><var><span lang="EN-US" style="font-family: 宋体;">dir</span></var><samp><span lang="EN-US" style="font-family: 宋体;">'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style=""><span style="font-family: 宋体;">在将<span lang="EN-US">makefile读入之前，把路径切换到‘dir’下。如果指定多个‘-C’选项，每一个都是相对于前一个的解释：‘-C/-C etc’等同于‘-C/etc’。该选项典型用在递归调用make过程中，参阅<b><i>递归调用make</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal"><span style="font-family: 宋体;">‘<span lang="EN-US">-d’<o:p></o:p></span></span></p>

<p class="MsoNormal" style=""><span style="font-family: 宋体;">在正常处理后打印调试信息。调试信息说明哪些文件用于更新，哪个文件作为比较时间戳的标准以及比较的结果，哪些文件实际上需要更新，需要考虑、使用哪些隐含规则等等<span lang="EN-US">----一切和make决定最终干什么有关的事情。‘-d’选项等同于‘--debug=a’选项（参见下面内容）。<o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--debug[=</span></samp><var><span lang="EN-US" style="font-family: 宋体;">options</span></var><samp><span lang="EN-US" style="font-family: 宋体;">]'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoBodyTextIndent">在正常处理后打印调试信息。可以选择各种级别和类型的输出。如果没有参数，打印‘基本’级别的调试信息。以下是可能的参数，仅仅考虑第一个字母，各个值之间使用逗号或空格隔开：</p>

<p class="MsoNormal" style="margin-left: 36pt;"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">a
(<i>all</i>)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">显示所有调试信息，该选项等同于‘<span lang="EN-US">-d’选项。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">b
(<i>basic</i>)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">基本调试信息打印每一个已经过时的目标，以及它们重建是否成功。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">v
(<i>verbose</i>)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style=""><span style="font-family: 宋体;">比‘基本’级高一个的等级的调试信息。包括<span lang="EN-US">makefile文件的语法分析结果，没有必要更新的依赖等。该选项同时包含基本调试信息。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">i
(<i>implicit</i>)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">打印隐含规则搜寻目标的信息。该选项同时包含基本调试信息。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">j
(<i>jobs</i>)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">打印各种子命令调用的详细信息。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">m
(<i>makefile</i>)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style=""><span style="font-family: 宋体;">以上选项不包含重新创建<span lang="EN-US">makefile文件的信息。该选项包含了这方面的信息。注意，选项‘all’也不包含这方面信息。该选项同时包含基本调试信息。<o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`-e'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--environment-overrides'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style=""><span style="font-family: 宋体;">设置从环境中继承来的变量的优先权高于<span lang="EN-US">makefile文件中的变量的优先权。参阅<b><i>环境变量</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`-f </span></samp><var><span lang="EN-US" style="font-family: 宋体;">file</span></var><samp><span lang="EN-US" style="font-family: 宋体;">'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--file=</span></samp><var><span lang="EN-US" style="font-family: 宋体;">file</span></var><samp><span lang="EN-US" style="font-family: 宋体;">'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--makefile=</span></samp><var><span lang="EN-US" style="font-family: 宋体;">file</span></var><samp><span lang="EN-US" style="font-family: 宋体;">'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">将名为‘<span lang="EN-US">file’的文件设置为makefile文件。参阅<b><i>编写makefile文件</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`-h'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--help'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">向您提醒<span lang="EN-US">make 能够理解的选项，然后退出。<o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`-i'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--ignore-errors'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">忽略重建文件执行命令时产生的所有错误。<span lang="EN-US"> <o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`-I </span></samp><var><span lang="EN-US" style="font-family: 宋体;">dir</span></var><samp><span lang="EN-US" style="font-family: 宋体;">'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--include-dir=</span></samp><var><span lang="EN-US" style="font-family: 宋体;">dir</span></var><samp><span lang="EN-US" style="font-family: 宋体;">'<o:p></o:p></span></samp></p>

<p class="MsoNormal" style=""><samp><span style="font-family: 宋体;">指定搜寻包含<span lang="EN-US">makefile文件的路径‘dir’。参阅<b><i>包含其它makefile文件</i></b>。如果同时使用几个‘-I’选项用于指定路径，则按照指定的次序搜寻这些路径。<o:p></o:p></span></span></samp></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`-j [</span></samp><var><span lang="EN-US" style="font-family: 宋体;">jobs</span></var><samp><span lang="EN-US" style="font-family: 宋体;">]'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--jobs[=</span></samp><var><span lang="EN-US" style="font-family: 宋体;">jobs</span></var><samp><span lang="EN-US" style="font-family: 宋体;">]'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style=""><span style="font-family: 宋体;">指定同时执行的命令数目。如果没有参数<span lang="EN-US">make将同时执行尽可能多的任务；如果有多个‘-j’选项，则仅最后一个选项有效。详细内容参阅<b><i>并行执行</i></b>。注意在MS-DOS下，该选项被忽略。<o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`-k'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--keep-going'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style=""><span style="font-family: 宋体;">在出现错误后，尽可能的继续执行。当一个目标创建失败，则所有依靠它的目标文件将不能重建，而这些目标的其它依赖则可继续处理。参阅<b><i>测试编译程序</i></b>。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`-l [</span></samp><var><span lang="EN-US" style="font-family: 宋体;">load</span></var><samp><span lang="EN-US" style="font-family: 宋体;">]'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--load-average[=</span></samp><var><span lang="EN-US" style="font-family: 宋体;">load</span></var><samp><span lang="EN-US" style="font-family: 宋体;">]'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--max-load[=</span></samp><var><span lang="EN-US" style="font-family: 宋体;">load</span></var><samp><span lang="EN-US" style="font-family: 宋体;">]'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style=""><span style="font-family: 宋体;">指定如果有其它任务正在运行，并且平均负载已接近或超过‘<span lang="EN-US">load’（一个浮点数），则此时不启动新任务。如果没有参数则取消以前关于负载的限制。参阅<b><i>并行执行</i>。<o:p></o:p></b></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`-n'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--just-print'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--dry-run'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--recon'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style=""><span style="font-family: 宋体;">打印要执行的命令，但却不执行它们。参阅<b><i>代替执行命令</i></b>。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`-o </span></samp><var><span lang="EN-US" style="font-family: 宋体;">file</span></var><samp><span lang="EN-US" style="font-family: 宋体;">'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--old-file=</span></samp><var><span lang="EN-US" style="font-family: 宋体;">file</span></var><samp><span lang="EN-US" style="font-family: 宋体;">'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--assume-old=</span></samp><var><span lang="EN-US" style="font-family: 宋体;">file</span></var><samp><span lang="EN-US" style="font-family: 宋体;">'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style=""><span style="font-family: 宋体;">即使文件<span lang="EN-US">file比它的依赖‘旧’，也不重建该文件。不要因为文件file的改变而重建任何其它文件。该选项本质上是假装将该文件的时间戳改为旧的时间戳，以至于依靠它的规则被忽略。参阅<b><i>避免重新编译文件</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`-p'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--print-data-base'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style=""><span style="font-family: 宋体;">打印数据库（规则和变量的值），这些数据来自读入<span lang="EN-US">makefile文件的结果；然后象通常那样执行或按照别的指定选项执行。如果同时给出‘-v’开关，则打印版本信息（参阅下面内容）。使用‘make
Cqp’则打印数据库后不试图重建任何文件。使用‘make Cp Cf/dev/null’则打印预定义的规则和变量的数据库。数据库输出中包含文件名，以及命令和变量定义的行号信息。它是在复杂环境中很好的调试工具。<o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`-q'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--question'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style=""><span style="font-family: 宋体;">‘问题模式’。不打印输出也不执行命令，如果所有目标都已经更新到最新，<span lang="EN-US">make的退出状态是0；如果一部分需要更新，退出状态是1；如果make遇到错误，退出状态是2，参阅<b><i>代替执行命令</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`-r'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--no-builtin-rules'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style=""><span style="font-family: 宋体;">排除使用内建的隐含规则（参阅<b><i>使用隐含规则</i></b>）。您仍然可以定义您自己的格式规则（参阅<b><i>定义和重新定义格式规则</i></b>）。选项‘<span lang="EN-US">-r’同时也清除了缺省的后缀列表和后缀规则（参阅<b><i>过时的后缀规则</i></b>）。但是您可以使用.SUFFIXES规则定义您自己的后缀。注意，使用选项‘-r’仅仅影响规则；缺省变量仍然有效（参阅<b><i>隐含规则使用的变量</i></b>）；参阅下述的选项‘-R’。<o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`-R'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--no-builtin-variables'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style=""><span style="font-family: 宋体;">排除使用内建的规则变量（参阅<b><i>隐含规则使用的变量</i></b>）。当然，您仍然可以定义自己的变量。选项‘<span lang="EN-US">-R’自动使选项‘-r’生效；因为它去掉了隐含规则所使用的变量的定义，所以隐含规则也就失去了存在的意义。<o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`-s'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--silent'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--quiet'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style=""><span style="font-family: 宋体;">沉默选项。不回显那些执行的命令。参阅<b><i>命令回显</i></b>。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`-S'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--no-keep-going'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--stop'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style=""><span style="font-family: 宋体;">使选项‘<span lang="EN-US">-k’失效。除非在递归调用make时，通过变量MAKEFLAGS从上层make继承选项‘-k’，或您在环境中设置了选项‘-k’，否则没有必要使用该选项。<o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`-t'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--touch'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style=""><span style="font-family: 宋体;">标志文件已经更新到最新，但实际没有更新它们。这是假装那些命令已经执行，用于愚弄将来的<span lang="EN-US">make调用。参阅<b><i>代替执行命令</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`-v'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--version'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style=""><span style="font-family: 宋体;">打印<span lang="EN-US">make程序的版本信息，作者列表和没有担保的注意信息，然后退出。<o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`-w'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--print-directory'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style=""><span style="font-family: 宋体;">打印执行<span lang="EN-US">makefile文件时涉及的所有工作目录。这对于跟踪make递归调用时复杂嵌套产生的错误非常有用。参阅<b><i>递归调用make</i></b>。实际上，您很少需要指定该选项，因为make已经替您完成了指定。参阅<b><i>‘<samp><span style="">--print-directory</span></samp>’选项</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--no-print-directory'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style=""><span style="font-family: 宋体;">在指定选项‘<span lang="EN-US">-w’的情况下，禁止打印工作路径。这个选项在选项‘-w’自动打开而且您不想看多余信息时比较有用。参阅<b><i>‘<samp><span style="">--print-directory</span></samp>’选项</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`-W </span></samp><var><span lang="EN-US" style="font-family: 宋体;">file</span></var><samp><span lang="EN-US" style="font-family: 宋体;">'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--what-if=</span></samp><var><span lang="EN-US" style="font-family: 宋体;">file</span></var><samp><span lang="EN-US" style="font-family: 宋体;">'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--new-file=</span></samp><var><span lang="EN-US" style="font-family: 宋体;">file</span></var><samp><span lang="EN-US" style="font-family: 宋体;">'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--assume-new=</span></samp><var><span lang="EN-US" style="font-family: 宋体;">file</span></var><samp><span lang="EN-US" style="font-family: 宋体;">'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style=""><span style="font-family: 宋体;">假装目标文件已经更新。在使用标志‘<span lang="EN-US">n’时，它将向您表明更改该文件会发生什么。如果没有标志‘n’它和在运行make之前对给定的文件使用touch命令的结果几乎一样，但使用该选项make只是在的想象中更改该文件的时间戳。参阅<b><i>代替执行命令</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`--warn-undefined-variables'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style=""><span style="font-family: 宋体;">当<span lang="EN-US">make看到引用没有定义的变量时，发布一条警告信息。如果您按照复杂方式使用变量，当您调试您的makefile文件时，该选项非常有用。<o:p></o:p></span></span></p>

<h1><a name="_10_使用隐含规则"></a><span lang="EN-US" style="font-size: 18pt; font-family: 宋体;">10 使用隐含规则<o:p></o:p></span></h1>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">重新创建目标文件的一些标准方法是经常使用的。例如，一个传统的创建<span lang="EN-US">OBJ文件的方法是使用C编译器，如cc，编译C语言源程序。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">隐含规则能够告诉<span lang="EN-US">make怎样使用传统的技术完成任务，这样，当您使用它们时，您就不必详细指定它们。例如，有一条编译C语言源程序的隐含规则，文件名决定运行哪些隐含规则；另如，编译C语言程序一般是使用‘.c’文件，产生‘.o’文件。因此，
make据此和文件名的后缀就可以决定使用编译C语言源程序的隐含规则。一系列的隐含规则可按顺序应用；例如，make可以从一个‘.y’文件，借助‘.c’文件，重建一个‘.o’文件，参阅<b><i>隐含规则链</i></b>。内建隐含规则的命令需要使用变量，通过改变这些变量的值，您就可以改变隐含规则的工作方式。例如，变量CFLAGS控制隐含规则用于编译C程序传递给C编译器的标志，参阅<b><i>隐含规则使用的变量</i></b>。通过编写格式规则，您可以创建您自己的隐含规则。参阅<b><i>定义和重新定义格式规则</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">后缀规则是对定义隐含规则最有限制性。格式规则一般比较通用和清楚，但是后缀规则却要保持兼容性。参阅<b><i>过时的后缀规则</i></b>。<span lang="EN-US"><o:p></o:p></span></span></p>

<h2><a name="_10.1_使用隐含规则"></a><span lang="EN-US" style="font-family: 宋体;">10.1 使用隐含规则<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">允许<span lang="EN-US">make对一个目标文件寻找传统的更新方法，您所有做的是避免指定任何命令。可以编写没有命令行的规则或根本不编写任何规则。这样，make将根据存在的源文件的类型或要生成的文件类型决定使用何种隐含规则。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">例如，假设<span lang="EN-US">makefile文件是下面的格式：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">foo : foo.o bar.o<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>cc -o foo foo.o bar.o $(CFLAGS) $(LDFLAGS)<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">因为您提及了文件‘<span lang="EN-US">foo.o’，但是您没有给出它的规则，make将自动寻找一条隐含规则，该规则能够告诉make怎样更新该文件。无论文件‘foo.o’存在与否，make都会这样执行。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">如果能够找到一条隐含规则，则它就能够对命令和一个或多个依赖（源文件）提供支持。如果您要指定附加的依赖，例如头文件，但隐含规则不能支持，您需要为目标‘<span lang="EN-US">foo.o’写一条不带命令行的规则。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">每一条隐含规则都有目标格式和依赖格式；也许多条隐含规则有相同的目标格式。例如，有数不清的规则产生‘<span lang="EN-US">.o’文件：使用C编译器编译‘.C’文件；使用Pascal编译器编译‘.p’文件；等等。实际应用的规则是那些依赖存在或可以创建的规则。所以，如果您有一个‘.C’文件，make将运行C编译器；如果您有一个‘.p’文件，make将运行Pascal编译器；等等。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">当然，您编写一个<span lang="EN-US">makefile文件时，您知道您要make使用哪一条隐含规则，以及您知道make将选择哪一条规则，因为您知道那个依赖文件是假设存在的。预定义的隐含规则列表的详细内容参阅<b><i>隐含规则目录</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">首先，我们说一条隐含规则可以应用，该规则的依赖必须‘存在或可以创建’。一个文件‘可以创建’是说该文件在<span lang="EN-US">makefile中作为目标或依赖被提及，或者该文件可以经过一条隐含规则的递归调用后能够创建。如果一条隐含规则的依赖是另一条隐含规则的结果，我们说产生了‘链’。参阅<b><i>隐含规则链</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">总体上说，<span lang="EN-US">make为每一个目标搜寻隐含规则，为没有命令行的双冒号规则搜寻隐含规则。仅作为依赖被提及的文件，将被认为是一个目标，如果该目标的规则没有指定任何内容，
make将为它搜寻隐含规则。对于详细的搜寻过程参阅<b><i>隐含规则的搜寻算法</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">注意，任何具体的依赖都不影响对隐含规则的搜寻。例如，认为这是一条具体的规则：<span lang="EN-US"><o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">foo.o: foo.p<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">文件<span lang="EN-US">foo.p不是首要条件，这意味着make按照隐含规则可以从一个Pascal源程序（‘.p’文件）创建OBJ文件，也就是说一个‘.o’文件可根据‘.p’文件进行更新。但文件foo.p并不是绝对必要的；例如，如果文件foo.c也存在，按照隐含规则则是从文件foo.c重建foo.o，这是因为C编译规则在预定义的隐含规则列表中比Pascal规则靠前，参阅<b><i>隐含规则目录</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">如果您不希望使用隐含规则创建一个没有命令行的目标，您可以通过添加分号为该目标指定空命令。参阅<b><i>使用空命令</i></b>。<span lang="EN-US"><o:p></o:p></span></span></p>

<h2><a name="_10.2隐含规则目录"></a><span lang="EN-US" style="font-family: 宋体;">10.2隐含规则目录<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">这里列举了预定义的隐含规则的目录，这些隐含规则是经常应用的，当然如果您在<span lang="EN-US">makefile文件中重载或删除后，这些隐含规则将会失去作用，详细内容参阅<b><i>删除隐含规则</i></b>。选项‘-r’或‘<samp><span style="">--no-builtin-rules</span></samp>’将删除所有预定义的隐含规则。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">并不是所有的隐含规则都是预定义的，在<span lang="EN-US">make中很多预定义的隐含规则是后缀规则的扩展，因此，那些预定义的隐含规则和后缀规则的列表相关（特殊目标.SUFFIXES的依赖列表）。缺省的后缀列表为：</span></span><code><span lang="EN-US" style="">.out</span></code><span lang="EN-US">,<span style="">&#160; </span><code><span style="">.a</span></code>,
<code><span style="">.ln</span></code>,<span style="">&#160;
</span><code><span style="">.o</span></code>,<span style="">&#160;
</span><code><span style="">.c</span></code>,<span style="">&#160;
</span><code><span style="">.cc</span></code>,<span style="">&#160;
</span><code><span style="">.C</span></code>,<span style="">&#160;
</span><code><span style="">.p</span></code>,<span style="">&#160;
</span><code><span style="">.f</span></code>,<span style="">&#160;
</span><code><span style="">.F</span></code>, <code><span style="">.r</span></code>,<span style="">&#160; </span><code><span style="">.y</span></code>,<span style="">&#160; </span><code><span style="">.l</span></code>,
<code><span style="">.s</span></code>,<span style="">&#160;
</span><code><span style="">.S</span></code>,<span style="">&#160;
</span><code><span style="">.mod</span></code>,<span style="">&#160;
</span><code><span style="">.sym</span></code>, <code><span style="">.def</span></code>,<span style="">&#160; </span><code><span style="">.h</span></code>,<span style="">&#160; </span><code><span style="">.info</span></code>,<span style="">&#160; </span><code><span style="">.dvi</span></code>,<span style="">&#160; </span><code><span style="">.tex</span></code>,<span style="">&#160; </span><code><span style="">.texinfo</span></code>,<span style="">&#160; </span><code><span style="">.texi</span></code>,<span style="">&#160; </span><code><span style="">.txinfo</span></code>,<span style="">&#160; </span><code><span style="">.w</span></code>,<span style="">&#160; </span><code><span style="">.ch</span></code></span><code><span style="font-family: 宋体;">，</span></code>
<code><span lang="EN-US" style="">.web</span></code><span lang="EN-US">,<span style="">&#160; </span><code><span style="">.sh</span></code>,<span style="">&#160; </span><code><span style="">.elc</span></code>,<span style="">&#160; </span><code><span style="">.el</span></code></span><code><span style="font-family: 宋体;">。所有下面描述的隐含规则，如果它们的依赖中有一个出现在这个后缀列表中，则是后缀规则。如果您更改这个后缀列表，则只有那些由一个或两个出现在您指定的列表中的后缀命名的预定义后缀规则起作用；那些后缀没有出现在列表中的规则被禁止。对于详细的关于后缀规则的描述参阅<b><i>过时的后缀规则</i></b>。<span lang="EN-US"><o:p></o:p></span></span></code></p>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;">Compiling C programs（编译C程序）
<o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.o'</span></tt><span lang="EN-US" style="font-family: 宋体;"> 自动由</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.c'</span></tt><span lang="EN-US" style="font-family: 宋体;"> 使用命令 <samp><span style="">‘$(CC) -c $(CPPFLAGS) $(CFLAGS)'</span></samp>生成 。<o:p></o:p></span></p>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;">Compiling C++
programs （编译C++程序）<o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.o'</span></tt><span style="font-family: 宋体;">自动由</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.cc'</span></tt><span lang="EN-US" style="font-family: 宋体;"> 或</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.C'</span></tt><span style="font-family: 宋体;">使用命令<samp><span style="">‘<span lang="EN-US">$(CXX) -c $(CPPFLAGS) $(CXXFLAGS)’生成。</span></span></samp> 我们鼓励您对<span lang="EN-US">C++源文件使用后缀</span></span><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><samp><span lang="EN-US" style="font-family: 宋体;">.cc'</span></samp><span lang="EN-US" style="font-family: 宋体;"> 代替后缀‘<samp><span style="">.C’。</span></samp><o:p></o:p></span></p>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;">Compiling Pascal
programs （编译Pascal程序）<o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.o'</span></tt><span style="font-family: 宋体;">自动由</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.p'</span></tt><span style="font-family: 宋体;">使用命令</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><samp><span lang="EN-US" style="font-family: 宋体;">$(PC) -c
$(PFLAGS)'</span></samp><span style="font-family: 宋体;">生成。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;">Compiling Fortran
and Ratfor programs （编译Fortran 和 Ratfor程序）<o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.o'</span></tt><span style="font-family: 宋体;">自动由</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.r'</span></tt><span lang="EN-US" style="font-family: 宋体;">,</span><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">
‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.F'</span></tt><span style="font-family: 宋体;">或</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.f'</span></tt><span lang="EN-US" style="font-family: 宋体;"> 运行Fortran编译器生成。使用的精确命令如下：<o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><samp><span lang="EN-US" style="font-family: 宋体;">`.f'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><samp><span lang="EN-US" style="font-family: 宋体;">`$(FC) -c
$(FFLAGS)'</span></samp><span lang="EN-US" style="font-family: 宋体;">. <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><samp><span lang="EN-US" style="font-family: 宋体;">`.F'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><samp><span lang="EN-US" style="font-family: 宋体;">`$(FC) -c
$(FFLAGS) $(CPPFLAGS)'</span></samp><span lang="EN-US" style="font-family: 宋体;">. <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><samp><span lang="EN-US" style="font-family: 宋体;">`.r'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><samp><span lang="EN-US" style="font-family: 宋体;">`$(FC) -c
$(FFLAGS) $(RFLAGS)'</span></samp><span lang="EN-US" style="font-family: 宋体;">. <o:p></o:p></span></p>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;">Preprocessing Fortran
and Ratfor programs （预处理Fortran 和 Ratfor程序）<o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.f'</span></tt><span lang="EN-US" style="font-family: 宋体;"> 自动从 </span><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.r'</span></tt><span style="font-family: 宋体;">或‘</span><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.F'</span></tt><span style="font-family: 宋体;">得到。该规则仅仅是与处理器把一个<span lang="EN-US">Ratfor 程序或能够预处理的
Fortran 程序转变为标准的 Fortran 程序。使用的精确命令如下： <o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><samp><span lang="EN-US" style="font-family: 宋体;">`.F'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><samp><span lang="EN-US" style="font-family: 宋体;">`$(FC) -F
$(CPPFLAGS) $(FFLAGS)'</span></samp><span lang="EN-US" style="font-family: 宋体;">. <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><samp><span lang="EN-US" style="font-family: 宋体;">`.r'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><samp><span lang="EN-US" style="font-family: 宋体;">`$(FC) -F
$(FFLAGS) $(RFLAGS)'</span></samp><span lang="EN-US" style="font-family: 宋体;">. <o:p></o:p></span></p>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;">Compiling Modula-2
programs（编译Modula-2程序） <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.sym'</span></tt><span style="font-family: 宋体;">自动由</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.def'</span></tt><span style="font-family: 宋体;">使用命令<samp><span style="">‘<span lang="EN-US">$(M2C) $(M2FLAGS) $(DEFFLAGS)'生成。</span></span></samp> </span><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.o'</span></tt><span lang="EN-US" style="font-family: 宋体;"> 从</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.mod'生成；</span></tt><span style="font-family: 宋体;">命令为<span lang="EN-US">:<samp><span style="">‘$(M2C) $(M2FLAGS) $(MODFLAGS)'。</span></samp> <o:p></o:p></span></span></p>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;">Assembling and
preprocessing assembler programs （汇编以及预处理汇编程序）<o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.o'</span></tt><span style="font-family: 宋体;">自‘</span><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.S'</span></tt><span style="font-family: 宋体;">运行<span lang="EN-US">C编译器，</span></span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">cpp</span></code><span style="font-family: 宋体;">，生成。命令为<span lang="EN-US">:<samp><span style="">‘$(CPP) $(CPPFLAGS)'</span></samp>。<o:p></o:p></span></span></p>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;">Linking a single
object file （连接一个简单的OBJ文件）<o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">'</span></tt><span lang="EN-US" style="font-family: 宋体;"> 自动由</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.o'</span></tt><span lang="EN-US" style="font-family: 宋体;"> 运行C编译器中的连接程序 linker (通常称为 </span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">ld</span></code><span lang="EN-US" style="font-family: 宋体;">)生成。命令为: <samp><span style="">‘$(CC) $(LDFLAGS) </span></samp><var>n</var><samp><span style="">.o $(LOADLIBES) $(LDLIBS)'</span></samp>。该规则对仅有一个源程序的简单程序或对同时含有多个OBJ文件（可能来自于不同的源文件）的程序都能正常工作。如果同时含有多个OBJ文件，则其中必有一个OBJ文件的名字和可执行文件名匹配。例如：<o:p></o:p></span></p>

<pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">x: y.o z.o<o:p></o:p></span></pre>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">当</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">x.c'</span></span></tt><span lang="EN-US" style="font-family: 宋体;">, </span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">y.c'</span></span></tt><span lang="EN-US" style="font-family: 宋体;"> 和</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">z.c'</span></span></tt><span lang="EN-US" style="font-family: 宋体;"> 都存在时则执行：
<o:p></o:p></span></p>

<pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">cc -c x.c -o x.o<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">cc -c y.c -o y.o<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">cc -c z.c -o z.o<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">cc x.o y.o z.o -o x<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">rm -f x.o<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">rm -f y.o<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">rm -f z.o<o:p></o:p></span></pre>

<p class="MsoNormal" style=""><span style="font-family: 宋体;">对于更复杂的情况，例如没有一个<span lang="EN-US">OBJ文件的名字和可执行文件名匹配，您必须为连接写一条具体的命令。每一种能自动生成‘.o’的文件，可以在没有‘-c’选项的情况下使用编译器(<samp><span style="">‘$(CC)'</span></samp>,<samp><span style="">‘$(FC)'</span></samp>或‘<samp><span style="">$(PC)'</span></samp>； C编译器<samp><span style="">‘$(CC)'</span></samp>也适用于汇编程序)自动连接。当然也可以使用OBJ文件作为中间文件，但编译、连接一步完成速度将快很多。<o:p></o:p></span></span></p>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;">Yacc for C programs （由Yacc生成C程序）<o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.c'</span></tt><span style="font-family: 宋体;">自动由</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.y'</span></tt><span style="font-family: 宋体;">使用命令<samp><span style="">‘<span lang="EN-US">$(YACC) $(YFLAGS)'</span></span></samp>运行<span lang="EN-US"> Yacc生成。<o:p></o:p></span></span></p>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;">Lex for C programs （由Lex生成C程序）<o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.c'</span></tt><span style="font-family: 宋体;">自动由‘</span><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.l'</span></tt><span lang="EN-US" style="font-family: 宋体;"> 运行 Lex生成。命令为：<samp><span style="">‘$(LEX) $(LFLAGS)'</span></samp>。 <o:p></o:p></span></p>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;">Lex for Ratfor
programs （由Lex生成Rator程序）<o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.r'</span></tt><span style="font-family: 宋体;">自动由‘</span><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.l'</span></tt><span lang="EN-US" style="font-family: 宋体;"> 运行 Lex生成。命令为：<samp><span style="">‘$(LEX) $(LFLAGS)'</span></samp>。 对于所有的Lex文件，无论它们产生C代码或Ratfor
代码，都使用相同的后缀‘<samp><span style="">.l</span></samp>’进行转换，在特定场合下，使用make自动确定您使用哪种语言是不可能的。如果make使用‘<samp><span style="">.l</span></samp>’文件重建一个OBJ文件，它必须猜想使用哪种编译器。它很可能猜想使用的是
C 编译器, 因为C 编译器更加普遍。如果您使用 Ratfor语言, 请确保在makefile文件中提及了</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.r'</span></tt><span style="font-family: 宋体;">，使<span lang="EN-US">make知道您的选择。否则，如果您专用Ratfor语言，不使用任何C 文件,
请在隐含规则后缀列表中将‘<samp><span style="">.c’</span></samp>剔除：<o:p></o:p></span></span></p>

<pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">.SUFFIXES:<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">.SUFFIXES: .o .r .f .l ...<o:p></o:p></span></pre>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;">Making Lint
Libraries from C, Yacc, or Lex programs（由C, Yacc, 或 Lex程序创建Lint库）<o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><tt><span style="font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-family: 宋体;">.ln'</span></tt><span lang="EN-US" style="font-family: 宋体;"> 可以从<tt><span style="">‘</span></tt><var>n</var><tt><span style="">.c'</span></tt>
运行<code><span style="">lint</span></code>产生。命令为：‘<samp><span style=""> $(LINT) $(LINTFLAGS) $(CPPFLAGS) Ci’。</span></samp>用于C程序的命令和用于<tt><span style="">‘</span></tt><var>n</var><tt><span style="">.y'</span></tt>或<tt><span style="">‘</span></tt><var>n</var><tt><span style="">.l'程序相同。</span></tt><o:p></o:p></span></p>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;">TeX and Web（TeX 和
Web）<o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.dvi'</span></tt><span style="font-family: 宋体;">可以从</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.tex'</span></tt><span lang="EN-US" style="font-family: 宋体;"> 使用命令<samp><span style="">‘$(TEX)'</span></samp>得到。</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.tex'</span></tt><span style="font-family: 宋体;">可以从</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.web'</span></tt><span style="font-family: 宋体;">使用命令<samp><span style="">‘<span lang="EN-US">$(WEAVE)'得到；</span></span></samp>或者从</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.w'</span></tt><span lang="EN-US" style="font-family: 宋体;"> (和</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.ch'，</span></tt><span style="font-family: 宋体;">如果<tt><span style="">‘</span></tt><var><span lang="EN-US">n</span></var><tt><span lang="EN-US" style="">.ch'存在或可以建造</span></tt><span lang="EN-US">) 使用命令<samp><span style="">‘$(CWEAVE)'</span></samp>。</span></span><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.p'</span></tt><span lang="EN-US" style="font-family: 宋体;"> 可以从</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.web'</span></tt><span style="font-family: 宋体;">使用命令<samp><span style="">‘<span lang="EN-US">$(TANGLE)'产生。</span></span></samp></span><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.c'</span></tt><span lang="EN-US" style="font-family: 宋体;"> 可以从</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.w'</span></tt><span lang="EN-US" style="font-family: 宋体;"> (和</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.ch'，</span></tt><span style="font-family: 宋体;">如果<tt><span style="">‘</span></tt><var><span lang="EN-US">n</span></var><tt><span lang="EN-US" style="">.ch'存在或可以建造</span></tt><span lang="EN-US">) 使用命令<samp><span style="">‘$(CTANGLE)'</span></samp>得到。
<o:p></o:p></span></span></p>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;">Texinfo and Info（Texinfo和Info）
<o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.dvi'</span></tt><span style="font-family: 宋体;">可以从</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.texinfo'</span></tt><span lang="EN-US" style="font-family: 宋体;">,</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.texi'</span></tt><span lang="EN-US" style="font-family: 宋体;">, 或</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.txinfo'</span></tt><span lang="EN-US" style="font-family: 宋体;">, 使用命令<samp><span style="">‘$(TEXI2DVI) $(TEXI2DVI_FLAGS)'</span></samp>得到。</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.info'</span></tt><span style="font-family: 宋体;">可以从</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.texinfo'</span></tt><span lang="EN-US" style="font-family: 宋体;">,</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.texi'</span></tt><span lang="EN-US" style="font-family: 宋体;">, 或</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.txinfo'</span></tt><span lang="EN-US" style="font-family: 宋体;">, 使用命令<samp><span style="">‘$(MAKEINFO) $(MAKEINFO_FLAGS)'</span></samp>创建。 <o:p></o:p></span></p>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;">RCS <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">文件</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">'</span></tt><span style="font-family: 宋体;">必要时可以从名为</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">,v'</span></tt><span style="font-family: 宋体;">或</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">RCS/</span></span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">,v</span></tt><tt><span lang="EN-US" style="font-family: 宋体;">'的</span></tt><span lang="EN-US" style="font-family: 宋体;">RCS文件中提取。具体命令是：<samp><span style="">‘$(CO) $(COFLAGS)'</span></samp>。文件</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">'</span></tt><tt><span style="font-family: 宋体;">如果已经存在，</span></tt><span style="font-family: 宋体;">即使<span lang="EN-US">RCS文件比它新，<tt><span style="">它不能从</span></tt>RCS文件中提取。用于RCS的规则是最终的规则，参阅<b><i>万用规则</i></b>，所以RCS不能够从任何源文件产生，它们必须存在。<o:p></o:p></span></span></p>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;">SCCS <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">文件</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">'</span></tt><span style="font-family: 宋体;">必要时可以从名为</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">s.</span></span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">'</span></tt><span style="font-family: 宋体;">或</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">SCCS/s.</span></span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">'</span></tt><tt><span style="font-family: 宋体;">的</span></tt><span lang="EN-US" style="font-family: 宋体;">SCCS文件中提取。具体命令是：<samp><span style="">‘$(GET) $(GFLAGS)'</span></samp>。用于SCCS的规则是最终的规则，参阅<b><i>万用规则</i></b>，所以SCCS不能够从任何源文件产生，它们必须存在。SCCS的优点是，文件
</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">'</span></tt><span lang="EN-US" style="font-family: 宋体;"> 可以从文件 </span><tt><span style="font-size: 10pt; font-family: 宋体;">‘</span></tt><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.sh'</span></tt><tt><span style="font-family: 宋体;">拷贝</span></tt><span style="font-family: 宋体;">并生成可执行文件<span lang="EN-US">(任何人都可以)。这用于shell的脚本，该脚本在SCCS内部检查。因为RCS
允许保持文件的可执行性，所以您没有必要将该特点用于RCS文件。我们推荐您避免使用SCCS，RCS不但使用广泛，而且是免费的软件。选择自由软件代替相当的（或低劣的）收费软件，是您对自由软件的支持。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">通常情况下，您要仅仅改变上表中的变量，需要参阅下面的文档。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">隐含规则的命令实际使用诸如</span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">COMPILE.c</span></code><span lang="EN-US" style="font-family: 宋体;">, </span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">LINK.p</span></code><span lang="EN-US" style="font-family: 宋体;">, 和 </span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">PREPROCESS.S</span></code><span style="font-family: 宋体;">等等变量，它们的值包含以上列出的命令。<span lang="EN-US">Make按照惯例进行处理，如，编译‘.x’源文件的规则使用变量‘</span></span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">COMPILE.</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">x</span></var><span style="font-family: 宋体;">’；从‘<span lang="EN-US">.x’源文件生成可执行文件使用变量‘</span></span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">LINK.</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">x</span></var><span style="font-family: 宋体;">’；预处理‘<span lang="EN-US">.x’源文件使用变量‘</span></span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">PREPROCESS.</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">x</span></var><span style="font-family: 宋体;">’。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">任何产生<span lang="EN-US">OBJ文件的规则都使用变量‘</span></span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">OUTPUT_OPTION</span></code><span style="font-family: 宋体;">’；<span lang="EN-US">make依据编译时间选项定义该变量的值是‘</span></span><samp><span lang="EN-US" style="font-family: 宋体;">-o $@</span></samp><span style="font-family: 宋体;">’或空值。当源文件分布在不同的目录中，您应该使用‘<span lang="EN-US">-O’选项保证输出到正确的文件中；使用变量VPATH时同样（参阅为<b><i>依赖搜寻目录</i></b>）。一些系统的编译器不接受针对OBJ文件的‘-o’开关；如果您在这样的系统上运行，并使用了变量VPATH，一些文件的编译输出可能会放到错误的地方。解决办法是将变量OUTPUT_OPTION值设为：‘</span></span><samp><span lang="EN-US" style="font-family: 宋体;">; mv $*.o $@</span></samp><span style="font-family: 宋体;">’。<span lang="EN-US"><o:p></o:p></span></span></p>

<h2><a name="_10.3隐含规则使用的变量"></a><span lang="EN-US" style="font-family: 宋体;">10.3隐含规则使用的变量<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">内建隐含规则的命令对预定义变量的使用是开放的；您可以在<span lang="EN-US">makefile文件中改变变量的值，也可以使用make的运行参数或在环境中改变，如此，在不对这些规则本身重新定义的情况下，就可以改变这些规则的工作方式。您还可以使用选项‘-R’或‘</span></span><samp><span lang="EN-US" style="font-family: 宋体;">--no-builtin-variables</span></samp><span style="font-family: 宋体;">’删除所有隐含规则使用的变量。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">例如，编译<span lang="EN-US">C程序的命令实际是‘</span></span><samp><span lang="EN-US" style="font-family: 宋体;">$(CC) -c $(CFLAGS) $(CPPFLAGS)</span></samp><span style="font-family: 宋体;">’，变量缺省的值是‘<span lang="EN-US">cc’或空值，该命令实际是‘cc
Cc’。如重新定义变量‘CC’的值为‘ncc’，则所有隐含规则将使用‘ncc’作为编译C语言源程序的编译器。通过重新定义变量‘CFLAGS’的值为‘-g’，则您可将‘-g’选项传递给每个编译器。所有的隐含规则编译C程序时都使用‘$CC’获得编译器的名称，并且都在传递给编译器的参数中都包含‘$(CFLAGS)’。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">隐含规则使用的变量可分为两类：一类是程序名变量（象<span lang="EN-US">cc），另一类是包含程序运行参数的变量（象CFLAGS）。(‘程序名’可能也包含一些命令参数，但是它必须以一个实际可以执行的程序名开始。)
如果一个变量值中包含多个参数，它们之间用空格隔开。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">这里是内建规则中程序名变量列表：<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">AR</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">档案管理程序；缺省为：</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">ar'</span></span></samp><span lang="EN-US" style="font-family: 宋体;">. <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">AS</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">汇编编译程序；缺省为：</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">as'</span></span></samp><span lang="EN-US" style="font-family: 宋体;">. <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">CC</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">C语言编译程序；缺省为：</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">cc'</span></span></samp><span lang="EN-US" style="font-family: 宋体;">. <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">CXX</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">C++编译程序；缺省为：</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">g++'</span></span></samp><span lang="EN-US" style="font-family: 宋体;">. <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">CO</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">从<span lang="EN-US">RCS文件中解压缩抽取文件程序；缺省为：</span></span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">co'</span></span></samp><span lang="EN-US" style="font-family: 宋体;">. <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">CPP</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">带有标准输出的<span lang="EN-US">C语言预处理程序；缺省为：</span></span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">$(CC) -E'</span></span></samp><span lang="EN-US" style="font-family: 宋体;">. <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">FC</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">Fortran 以及 Ratfor 语言的编译和预处理程序；缺省为：</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">f77'</span></span></samp><span lang="EN-US" style="font-family: 宋体;">. <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">GET</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">从<span lang="EN-US">SCCS文件中解压缩抽取文件程序；缺省为：</span></span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">get'</span></span></samp><span lang="EN-US" style="font-family: 宋体;">. <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">LEX</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">将<span lang="EN-US"> Lex 语言转变为 C 或 Ratfor程序的程序；缺省为：</span></span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">lex'</span></span></samp><span lang="EN-US" style="font-family: 宋体;">. <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">PC</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">Pascal 程序编译程序；缺省为：</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">pc'</span></span></samp><span lang="EN-US" style="font-family: 宋体;">. <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">YACC</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">将<span lang="EN-US"> Yacc语言转变为 C程序的程序；缺省为：</span></span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">yacc'</span></span></samp><span lang="EN-US" style="font-family: 宋体;">. <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">YACCR</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">将<span lang="EN-US"> Yacc语言转变为 Ratfor程序的程序；缺省为：</span></span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">yacc -r'</span></span></samp><span lang="EN-US" style="font-family: 宋体;">. <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">MAKEINFO</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">将<span lang="EN-US">Texinfo 源文件转换为信息文件的程序；缺省为：</span></span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">makeinfo'</span></span></samp><span lang="EN-US" style="font-family: 宋体;">. <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">TEX</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">从<span lang="EN-US">TeX源产生TeX DVI文件的程序；缺省为：</span></span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">tex'</span></span></samp><span lang="EN-US" style="font-family: 宋体;">. <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">TEXI2DVI</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">从<span lang="EN-US">Texinfo源产生TeX DVI 文件的程序；缺省为：</span></span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">texi2dvi'</span></span></samp><span lang="EN-US" style="font-family: 宋体;">. <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">WEAVE</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">将<span lang="EN-US">Web翻译成TeX的程序；缺省为：</span></span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">weave'</span></span></samp><span lang="EN-US" style="font-family: 宋体;">.
<o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">CWEAVE</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">将<span lang="EN-US">CWeb翻译成TeX的程序；缺省为：</span></span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">cweave'</span></span></samp><span lang="EN-US" style="font-family: 宋体;">. <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">TANGLE</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">将<span lang="EN-US">Web翻译成 Pascal的程序；缺省为：</span></span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">tangle'</span></span></samp><span lang="EN-US" style="font-family: 宋体;">. <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">CTANGLE</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">将<span lang="EN-US">Web翻译成C的程序；缺省为：</span></span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">ctangle'</span></span></samp><span lang="EN-US" style="font-family: 宋体;">. <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">RM</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">删除文件的命令；缺省为：</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">rm -f'</span></span></samp><span lang="EN-US" style="font-family: 宋体;">.<o:p></o:p></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">这里是值为上述程序附加参数的变量列表。在没有注明的情况下，所有变量的值为空值。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">ARFLAGS</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">用于档案管理程序的标志，缺省为：</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">rv'</span></span></samp><span lang="EN-US" style="font-family: 宋体;">. <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">ASFLAGS</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">用于汇编编译器的额外标志<span lang="EN-US"> (当具体调用</span></span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">.s'</span></span></samp><span style="font-family: 宋体;">或</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">.S'</span></span></samp><span style="font-family: 宋体;">文件时<span lang="EN-US">)。<o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">CFLAGS</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">用于<span lang="EN-US">C编译器的额外标志。<o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">CXXFLAGS</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">用于<span lang="EN-US">C++编译器的额外标志。 <o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">COFLAGS</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">用于<span lang="EN-US">RCS </span></span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">co</span></code><span style="font-family: 宋体;">程序的额外标志。<span lang="EN-US"> <o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">CPPFLAGS</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">用于<span lang="EN-US">C预处理以及使用它的程序的额外标志 (C和 Fortran 编译器)。 <o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">FFLAGS</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">用于<span lang="EN-US">Fortran编译器的额外标志。 <o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">GFLAGS</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">用于<span lang="EN-US">SCCS </span></span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">get</span></code><span style="font-family: 宋体;">程序的额外标志。<span lang="EN-US"> <o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">LDFLAGS</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">用于调用<span lang="EN-US">linker（‘ld’）的编译器的额外标志。 <o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">LFLAGS</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">用于<span lang="EN-US">Lex的额外标志。<o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">PFLAGS</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">用于<span lang="EN-US">Pascal编译器的额外标志。<o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">RFLAGS</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">用于处理<span lang="EN-US">Ratfor程序的Fortran编译器的额外标志。 <o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">YFLAGS</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">用于<span lang="EN-US">Yacc的额外标志。Yacc。 <o:p></o:p></span></span></p>

<h2><a name="_10.4_隐含规则链"></a><span lang="EN-US" style="font-family: 宋体;">10.4 隐含规则链<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">有时生成一个文件需要使用多个隐含规则组成的序列。例如，从文件‘<span lang="EN-US">n.y’生成文件‘n.o’，首先运行隐含规则Yacc，其次运行规则cc。这样的隐含规则序列称为隐含规则链。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">如果文件‘<span lang="EN-US">n.c’存在或在makefile文件中提及，则不需要任何特定搜寻：make首先发现通过C编译器编译‘n.c’可生成该OBJ文件，随后，考虑生成‘n.c’时，则使用运行Yacc的规则。这样可最终更新‘n.c’和‘n.o’。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">即使在文件‘<span lang="EN-US">n.c’不存在或在makefile文件中没有提及的情况下，make也能想象出在文件‘n.y’和‘n.o’缺少连接！这种情况下，‘n.c’称为<b>中间文件</b>。一旦make决定使用中间文件，它将把中间文件输入数据库，好像中间文件在makefile文件中提及一样；按照隐含规则的描述创建中间文件。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">中间文件和其它文件一样使用自己的规则重建，但是中间文件和其它文件相比有两种不同的处理方式。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">第一个不同的处理方式是如果中间文件不存在<span lang="EN-US">make的行为不同：平常的文件b如果不存在，make认为一个目标依靠文件b，它总是创建文件b，然后根据文件b更新目标；但是文件b若是中间文件，make很可能不管它而进行别的工作，即不创建文件b，也不更新最终目标。只有在文件b的依赖比最终目标‘新’时或有其它原因时，才更新最终目标。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">第二个不同点是<span lang="EN-US">make在更新目标创建文件b后，如果文件b不再需要，make将把它删除。所以一个中间文件在make运行之前和make运行之后都不存在。Make向您报告删除时打印一条‘rm
Cf’命令，表明有文件被删除。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">通常情况下，任何在<span lang="EN-US">makefile文件中提及的目标和依赖都不是中间文件。但是，您可以特别指定一些文件为中间文件，其方法为：将要指定为中间文件的文件作为特殊目标
.INTERMEDIATE的依赖。这种方法即使对采用别的方法具体提及的文件也能生效。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">您通过将文件标志为<span lang="EN-US">secondary文件可以阻止自动删除中间文件。这时，您将您需要保留的中间文件指定为特殊目标 .SECONDARY的依赖即可。对于secondary文件，make不会因为它不存在而去创建它，也不会自动删除它。secondary文件必须也是中间文件。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">您可以列举一个隐含规则的目标格式（例如<span lang="EN-US">%.o）作为特殊目标 .PRECIOUS的依赖，这样您就可以保留那些由隐含规则创建的文件名匹配该格式的中间文件。参阅<b><i>中断和关闭make</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">一个隐含规则链至少包含两个隐含规则。例如，从‘</span><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">RCS/foo.y,v</span></tt><span style="font-family: 宋体;">’创建文件‘<span lang="EN-US">foo’需要运行RCS、Yacc和cc，文件foo.y和foo.c是中间文件，在运行结束后将被删掉。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">没有一条隐含规则可以在隐含规则链中出现两次以上（含两次）。这意味着，<span lang="EN-US">make不会简单的认为从文件‘foo.o.o’创建文件foo不是运行linker两次。这还可以强制make在搜寻一个隐含规则链时阻止无限循环。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">一些特殊的隐含规则可优化隐含规则链控制的特定情况。例如，从文件<span lang="EN-US">foo.c创建文件foo可以被拥有编译和连接的规则链控制，它使用foo.o作为中间文件。但是对于这种情况存在一条特别的规则，使用简单的命令cc可以同时编译和连接。因为优化规则在规则表中的前面，所以优化规则和一步一步的规则链相比，优先使用优化规则。<o:p></o:p></span></span></p>

<h2><a name="_10.5定义与重新定义格式规则"></a><span lang="EN-US" style="font-family: 宋体;">10.5定义与重新定义格式规则<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">您可以通过编写格式规则定义隐含规则。该规则看起来和普通规则类似，不同之处在于格式规则的目标中包含字符‘<span lang="EN-US">%’（只有一个）。目标是匹配文件名的格式；字符‘%’可以匹配任何非空的字符串，而其它字符仅仅和它们自己相匹配。依赖用‘%’表示它们的名字和目标名关联。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">格式‘</span><samp><span lang="EN-US" style="font-family: 宋体;">%.o : %.c</span></samp><span style="font-family: 宋体;">’是说将任何‘<span lang="EN-US">stem.c’文件编译为‘stem.o’文件。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">在格式规则中使用的‘<span lang="EN-US">%’扩展是在所有变量和函数扩展以后进行的，它们是在makefile文件读入时完成的。参阅<b><i>使用变量</i></b>和<b><i>转换文本函数</i></b>。<o:p></o:p></span></span></p>

<h3><a name="_10.5.1个是规则简介"></a><span lang="EN-US" style="font-size: 14pt; font-family: 宋体;">10.5.1格式规则简介<o:p></o:p></span></h3>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">格式规则是在目标中包含字符‘<span lang="EN-US">%’（只有一个）的规则，其它方面看起来和普通规则相同。目标是可以匹配文件名的格式，字符‘%’可以匹配任何非空的字符串，而其它字符仅仅和它们自己相匹配。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">例如‘<span lang="EN-US">%.c’匹配任何以‘.c’结尾的文件名；‘s.%.c’匹配以‘s.’开始并且以‘.c’结尾的文件名，该文件名至少包含5个字符（因为‘%’至少匹配一个字符）。匹配‘%’的子字符串称为stem(径)。依赖中使用‘%’表示它们的名字中含有和目标名相同的stem。要使用格式规则，文件名必须匹配目标的格式，而且符合依赖格式的文件必须存在或可以创建。下面规则：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">%.o : %.c ; <var>command</var>...<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">表明要创建文件‘<span lang="EN-US">n.o’，使用‘n.c’作为它的依赖，而且文件‘n.c’
必须存在或可以创建。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">在格式规则中，依赖有时不含有‘<span lang="EN-US">%’。这表明采用该格式规则创建的所有文件都是采用相同的依赖。这种固定依赖的格式规则在有些场合十分有用。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">格式规则的依赖不必都包含字符‘<span lang="EN-US">%’，这样的规则是一个有力的常规通配符，它为任何匹配该目标格式规则的文件提供创建方法。参阅<b><i>定义最新类型的缺省规则</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">格式规则可以有多个目标，不象正常的规则，这种规则不能扮演具有相同依赖和命令的多条不同规则。如果一格式规则具有多个目标，<span lang="EN-US">make知道规则的命令对于所有目标来说都是可靠的，这些命令只有在创建所目标时才执行。当为匹配一目标搜寻格式规则时，规则的目标格式和规则要匹配的目标不同是十分罕见的，所以make仅仅担心目前对文件给出命令和依赖是否有问题。注意该文件的命令一旦执行，所有目标的时间戳都会更新。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">格式规则在<span lang="EN-US">makefile文件中的次序很重要，因为这也是考虑它们的次序。对于多个都能使用的规则，使用最先出现的规则。您亲自编写的规则比内建的规则优先。注意依赖存在或被提及的规则优先于依赖需要经过隐含规则链生成的规则。<o:p></o:p></span></span></p>

<h3><a name="_10.5.2格式规则的例子"></a><span lang="EN-US" style="font-size: 14pt; font-family: 宋体;">10.5.2格式规则的例子<o:p></o:p></span></h3>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">这里有一些实际在<span lang="EN-US">make中预定义的格式规则例子，第一个，编译‘.c’文件生成‘.o’文件的规则：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">%.o : %.c<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">定义了一条编译‘<span lang="EN-US">x.c’文件生成‘x.o’文件的规则，命令使用自动变量‘$@’和‘$&lt;’
替换任何情况使用该规则的目标文件和源文件。参阅<b><i>自动变量</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">第二个内建的例子：<span lang="EN-US"><o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">% :: RCS/%,v<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(CO) $(COFLAGS) $&lt;<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">定义了在子目录‘<span lang="EN-US">RCS’中根据相应文件‘x.v’生成文件‘x’的规则。因为目标是‘%’，只要相对应的依赖文件存在，该规则可以应用于任何文件。双冒号表示该规则是最终规则，它意味着不能是中间文件。参阅<b><i>万用规则</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">下面的格式规则有两个目标：<span lang="EN-US"><o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">%.tab.c %.tab.h: %.y<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>bison -d $&lt;<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">这告诉<span lang="EN-US">make执行命令‘</span></span><samp><span lang="EN-US" style="font-family: 宋体;">bison -d </span></samp><var><span lang="EN-US" style="font-family: 宋体;">x</span></var><samp><span lang="EN-US" style="font-family: 宋体;">.y</span></samp><span style="font-family: 宋体;">’将创建‘<span lang="EN-US">x.tab.c’和‘x.tab.h’。如果文件foo依靠文件‘</span></span><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">parse.tab.o</span></tt><span style="font-family: 宋体;">’和‘</span><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">scan.o</span></tt><span style="font-family: 宋体;">’，而文件‘</span><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">scan.o</span></tt><span style="font-family: 宋体;">’又依靠文件‘</span><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">parse.tab.h</span></tt><span style="font-family: 宋体;">’，当‘</span><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">parse.y</span></tt><span style="font-family: 宋体;">’发生变化，命令‘</span><samp><span lang="EN-US" style="font-family: 宋体;">bison -d parse.y</span></samp><span style="font-family: 宋体;">’执行一次。‘</span><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">parse.tab.o</span></tt><span style="font-family: 宋体;">’和‘</span><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">scan.o</span></tt><span style="font-family: 宋体;">’的依赖也随之更新。（假设文件‘</span><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">parse.tab.o</span></tt><span style="font-family: 宋体;">’由文件‘</span><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">parse.tab.c</span></tt><span style="font-family: 宋体;">’编译生成，文件‘</span><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">scan.o</span></tt><span style="font-family: 宋体;">’由文件‘</span><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">scan.c</span></tt><span style="font-family: 宋体;">’生成，当连接‘</span><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">parse.tab.o</span></tt><span style="font-family: 宋体;">’、‘</span><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">scan.o</span></tt><span style="font-family: 宋体;">’和其它依赖生成文件<span lang="EN-US">foo时，上述规则能够很好执行。）<o:p></o:p></span></span></p>

<h3><a name="_10.5.3自动变量"></a><span lang="EN-US" style="font-size: 14pt; font-family: 宋体;">10.5.3自动变量<o:p></o:p></span></h3>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">假设您编写一个编译‘<span lang="EN-US">.c’文件生成‘.o’文件的规则：您怎样编写命令‘CC’，使它能够操作正确的文件名？您当然不能将文件名直接写进命令中，因为每次使用隐含规则操作的文件名都不一样。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">您应该使用<span lang="EN-US">make的另一个特点，自动变量。这些变量在规则每次执行时都基于目标和依赖产生新值。例如您可以使用变量‘$@’代替目标文件名，变量‘$&lt;’代替依赖文件名。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">下面是自动变量列表：<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$@</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">规则的目标文件名。如果目标是一个档案成员，则变量‘</span><samp><span lang="EN-US" style="font-family: 宋体;">$@’</span></samp><span style="font-family: 宋体;"> 档案文件的文件名。对于有多个目标的格式规则（参阅<b><i>格式规则简介</i></b>），变量‘</span><samp><span lang="EN-US" style="font-family: 宋体;">$@’</span></samp><span style="font-family: 宋体;">是那个导致规则命令运行的目标文件名。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$%</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">当目标是档案成员时，该变量是目标成员名，参阅<b><i>使用<span lang="EN-US">make更新档案文件</span></i></b>。例如，如果目标是</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">foo.a(bar.o)'</span></span></tt><span style="font-family: 宋体;">，则</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">$%'</span></span></samp><span style="font-family: 宋体;">的值是</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">bar.o'</span></span></tt><span style="font-family: 宋体;">，</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">$@'</span></span></samp><span style="font-family: 宋体;">的值是</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">foo.a'</span></span></tt><span style="font-family: 宋体;">。如果目标不是档案成员，则</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">$%'</span></span></samp><span style="font-family: 宋体;">是空值。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$&lt;</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">第一个依赖的文件名。如果目标更新命令来源于隐含规则，该变量的值是隐含规则添加的第一个依赖。参阅<b><i>使用隐含规则</i></b>。<span lang="EN-US"> <o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$?</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">所有比目标‘新’的依赖名，名字之间用空格隔开。对于为档案成员的依赖，只能使用已命名的成员。参阅<b><i>使用<span lang="EN-US">make更新档案文件</span></i></b>。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$^</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">所有依赖的名字，名字之间用空格隔开。对于为档案成员的依赖，只能使用已命名的成员。参阅<b><i>使用<span lang="EN-US">make更新档案文件</span></i></b>。对同一个目标来说，一个文件只能作为一个依赖，不管该文件的文件名在依赖列表中出现多少次。
所以，如果在依赖列表中，同一个文件名出现多次，变量‘<span lang="EN-US">$^’的值仍然仅包含该文件名一次。 <o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$+</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">该变量象</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">$^'</span></span></samp><span style="font-family: 宋体;">，但是，超过一次列出的依赖将按照它们在<span lang="EN-US">makefile文件中出现的次序复制。这主要的用途是对于在按照特定顺序重复库文件名很有意义的地方使用连接命令。<o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$*</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">和隐含规则匹配的<span lang="EN-US">stem(径)，参阅<b><i>格式匹配</i></b>。如果一个目标为</span></span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">dir/a.foo.b'</span></span></tt><span style="font-family: 宋体;">，目标格式规则为：</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">a.%.b'</span></span></tt><span lang="EN-US" style="font-family: 宋体;"> ，则stem为</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">dir/foo'</span></span></tt><span style="font-family: 宋体;">。在构建相关文件名时<span lang="EN-US">stem 十分有用。在静态格式规则中，stem是匹配目标格式中字符‘%’的文件名中那一部分。在一个没有stem具体规则中；变量</span></span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">$*'</span></span></samp><span lang="EN-US" style="font-family: 宋体;"> 不能以该方法设置。如果目标名以一种推荐的后缀结尾（参阅<b><i>过时的后缀规则</i></b>），变量</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">$*'</span></span></samp><span style="font-family: 宋体;">设置为目标去掉该后缀后的部分。例如，如果目标名是</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">foo.c'</span></span></samp><span style="font-family: 宋体;">，则变量</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">$*'</span></span></samp><span lang="EN-US" style="font-family: 宋体;"> 设置为</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">foo'</span></span></samp><span lang="EN-US" style="font-family: 宋体;">, 因为</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">.c'</span></span></samp><span lang="EN-US" style="font-family: 宋体;"> 是一个后缀。GNU </span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">make</span></code><span lang="EN-US" style="font-family: 宋体;"> 处理这样奇怪的事情是为了和其它版本的</span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">make</span></code><code><span style="font-family: 宋体;">兼容。在隐含规则和静态格式规则以外，您应该尽量避免使用变量</span></code><samp><span style="font-family: 宋体;">‘<span lang="EN-US">$*'。</span></span></samp><span style="font-family: 宋体;">在具体规则中如果目标名不以推荐的后缀结尾，则变量‘<span lang="EN-US">$*’在该规则中设置为空值。
<o:p></o:p></span></span></p>

<p style="text-indent: 21pt;"><samp><span style="font-size: 10.5pt;">当您希望仅仅操作那些改变的依赖，变量‘<span lang="EN-US">$?'</span></span></samp><span lang="EN-US" style="font-size: 10.5pt;"> 即使在具体的规则中也很有用。例如，假设名为‘lib’的档案文件包含几个OBJ文件的拷贝，则下面的规则仅将发生变化的OBJ文件拷贝到档案文件：
<o:p></o:p></span></p>

<pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">lib: foo.o bar.o lose.o win.o<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>ar r lib $?<o:p></o:p></span></pre>

<p><span style="font-size: 10.5pt;">在上面列举的变量中，有四个变量的值是单个文件名。三个变量的值是文件名列表。这七个变量都有仅仅存放文件的路径名或仅仅存放目录下文件名的变体。变量的变体名是由变量名追加字母‘<span lang="EN-US">D’或‘F’构成。这些变体在GNU make中处于半废状态，原因是使用函数T </span></span><code><span lang="EN-US" style="font-size: 10.5pt;">dir</span></code><span style="font-size: 10.5pt;">和</span><code><span lang="EN-US" style="font-size: 10.5pt;">notdir</span></code><span lang="EN-US" style="font-size: 10.5pt;"> 能够得到相同的结果。参阅<b><i>文件名函数</i></b>。注意，</span><samp><span style="font-size: 10.5pt;">‘<span lang="EN-US">F'</span></span></samp><span style="font-size: 10.5pt;">变体省略所有在<span lang="EN-US">dir函数中总是输出的结尾斜杠
这里是这些变体的列表： <o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`$(@D)'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">目标文件名中的路径部分，结尾斜杠已经移走。如果变量</span><samp><span lang="EN-US" style="font-family: 宋体;">`$@'的值</span></samp><span style="font-family: 宋体;">是</span><tt><span lang="EN-US" style="font-family: 宋体;">`dir/foo.o'</span></tt><span style="font-family: 宋体;">，变体 </span><samp><span lang="EN-US" style="font-family: 宋体;">`$(@D)'的值</span></samp><span style="font-family: 宋体;">是</span><tt><span lang="EN-US" style="font-family: 宋体;">`dir'</span></tt><span style="font-family: 宋体;">。 如果变量</span><samp><span lang="EN-US" style="font-family: 宋体;">`$@'的值不包含斜杠，则变体的值是</span></samp><tt><span lang="EN-US" style="font-family: 宋体;">`.'</span></tt><span style="font-family: 宋体;">。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`$(@F)'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">目标文件名中的真正文件名部分。如果变量</span><samp><span lang="EN-US" style="font-family: 宋体;">`$@'的值</span></samp><span style="font-family: 宋体;">是</span><tt><span lang="EN-US" style="font-family: 宋体;">`dir/foo.o'</span></tt><span style="font-family: 宋体;">，变体<span lang="EN-US"><span style="">&#160; </span></span></span><samp><span lang="EN-US" style="font-family: 宋体;">`$(@F)'的值</span></samp><span style="font-family: 宋体;">是</span><tt><span lang="EN-US" style="font-family: 宋体;">` foo.o '。</span></tt><samp><span lang="EN-US" style="font-family: 宋体;">`$(@F)'</span></samp><span lang="EN-US" style="font-family: 宋体;"> 等同于 </span><samp><span lang="EN-US" style="font-family: 宋体;">`$(notdir $@)'</span></samp><span style="font-family: 宋体;">。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`$(*D)'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`$(*F)'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">stem（径）中的路径名和文件名；在这个例子中它们的值分别为：</span><tt><span lang="EN-US" style="font-family: 宋体;">`dir'</span></tt><span lang="EN-US" style="font-family: 宋体;"> 和 </span><tt><span lang="EN-US" style="font-family: 宋体;">`foo'</span></tt><span lang="EN-US" style="font-family: 宋体;"> 。 <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`$(%D)'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`$(%F)'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">档案成员名中的路径名和文件名；这仅对采用‘<var><span lang="EN-US">archive</span></var></span><tt><span lang="EN-US" style="font-family: 宋体;">(</span></tt><var><span lang="EN-US" style="font-family: 宋体;">member</span></var><tt><span lang="EN-US" style="font-family: 宋体;">)</span></tt><span style="font-family: 宋体;">’形式的档案成员目标有意义，并且当成员包含路径名时才有用。
参阅<b><i>档案成员目标</i></b>。<span lang="EN-US"> <o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`$(&lt;D)'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`$(&lt;F)'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">第一个依赖名中的路径名和文件名。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`$(^D)'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`$(^F)'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">所有依赖名中的路径名和文件名列表。<span lang="EN-US"> <o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`$(?D)'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`$(?F)'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">所有比目标‘新’的依赖名中的路径名和文件名列表。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">注意，在我们讨论自动变量时，我们使用了特殊格式的惯例；我们写<span lang="EN-US">"the value of</span></span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">$&lt;'</span></span></samp><span lang="EN-US" style="font-family: 宋体;">",
而不是"the variable </span><code><span lang="EN-US" style="font-family: 宋体;">&lt;</span></code><span lang="EN-US" style="font-family: 宋体;">" ；和我们写普通变量，例如变量 </span><code><span lang="EN-US" style="font-family: 宋体;">objects</span></code><span lang="EN-US" style="font-family: 宋体;"> 和 </span><code><span lang="EN-US" style="font-family: 宋体;">CFLAGS</span></code><span style="font-family: 宋体;">一样。我们认为这种惯例在这种情况下看起来更加自然。这并没有其它意义，变量</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">$&lt;'</span></span></samp><span style="font-family: 宋体;">的变量名为 </span><code><span lang="EN-US" style="font-family: 宋体;">&lt;</span></code><span lang="EN-US" style="font-family: 宋体;"> 和变量</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">$(CFLAGS)'</span></span></samp><span lang="EN-US" style="font-family: 宋体;"> 实际变量名为</span><code><span lang="EN-US" style="font-family: 宋体;">CFLAGS</span></code><span style="font-family: 宋体;">一样。您也可以使用</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">$(&lt;)'</span></span></samp><span style="font-family: 宋体;">代替</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">$&lt;'</span></span></samp><span style="font-family: 宋体;">。<span lang="EN-US"><o:p></o:p></span></span></p>

<h3><a name="_10.5.4格式匹配"></a><span lang="EN-US" style="font-size: 14pt; font-family: 宋体;">10.5.4格式匹配<o:p></o:p></span></h3>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">目标格式是由前缀、后缀和它们之间的通配符<span lang="EN-US">%组成，它们中的任一个或两个都可以是空值。格式匹配一个文件名只有该文件名是以前缀开始，后缀结束，而且两者不重叠的条件下，才算匹配。前缀、后缀之间的文本成为径（stem）。当格式‘%.o’匹配文件名‘test.o’时，径（stem）是‘test’。格式规则中的依赖将径（stem）替换字符%，从而得出文件名。对于上例中，如果一个依赖为‘%.c’，则可扩展为‘test.c’。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">当目标格式中不包含斜杠（实际并不是这样），则文件名中的路径名首先被去除，然后，将其和格式中的前缀和后缀相比较。在比较之后，以斜杠结尾的路径名，将会加在根据格式规则的依赖规则产生的依赖前面。只有在寻找隐含规则时路径名才被忽略，在应用时路径名绝不能忽略。例如，‘<span lang="EN-US">e%t’和文件名‘src/eat’匹配，stem(径)是‘src/a’。当依赖转化为文件名时，stem中的路径名将加在前面，stem(径)的其余部分替换‘%’。使用stem（径）
‘src/a’和依赖格式规则‘c%r’匹配得到文件名‘src/car’。<o:p></o:p></span></span></p>

<h3><a name="_10.5.5万用规则"></a><span lang="EN-US" style="font-size: 14pt; font-family: 宋体;">10.5.5万用规则<o:p></o:p></span></h3>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">一个格式规则的目标仅仅包含‘<span lang="EN-US">%’，它可以匹配任何文件名，我们称这些规则为万用规则。它们非常有用，但是make使用它们的耗时也很多，因为make必须为作为目标和作为依赖列出的每一个文件都考虑这样的规则。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">假设<span lang="EN-US">makefile文件提及了文件foo.c。为了创建该目标，make将考虑是通过连接一个OBJ文件‘foo.c.o’创建，或是通过使用一步的C编译连接程序从文件foo.c.c创建，或是编译连接Pascal程序foo.c.p创建，以及其它的可能性等。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">我们知道<span lang="EN-US">make考虑的这些可能性是很可笑的，因为foo.c就是一个C语言源程序，不是一个可执行程序。如果make考虑这些可能性，它将因为这些文件诸如foo.c.o和foo.c.p等都不存在最终拒绝它们。但是这些可能性太多，所以导致make的运行速度极慢。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">为了加快速度，我们为<span lang="EN-US">make考虑匹配万用规则的方式设置了限制。有两种不同类型的可以应用的限制，在您每次定义一个万用规则时，您必须为您定义的规则在这两种类型中选择一种。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">一种选择是标志该万用规则是最终规则，即在定义时使用双冒号定义。一个规则为最终规则时，只有在它的依赖存在时才能应用，即使依赖可以由隐含规则创建也不行。换句话说，在最终规则中没有进一步的链。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">例如，从<span lang="EN-US">RCS和SCCS文件中抽取原文件的内建的隐含规则是最终规则，则如果文件</span></span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">foo.c,v'</span></span></tt><span lang="EN-US" style="font-family: 宋体;"> 不存在，</span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">make</span></code><span style="font-family: 宋体;">绝不会试图从一个中间文件‘</span><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">foo.c,v.o</span></tt><span style="font-family: 宋体;">’或‘</span><tt><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">RCS/SCCS/s.foo.c,v</span></tt><span style="font-family: 宋体;">’在创建它。<span lang="EN-US"> RCS 和 SCCS 文件一般都是最终源文件，它不能从其它任何文件重新创建，所以，make可以记录时间戳，但不寻找重建它们的方式。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">如果您不将万用规则标志为最终规则，那么它就是非最终规则。一个非最终万用规则不能用于指定特殊类型数据的文件。如果存在其它规则（非万用规则）的目标匹配一文件名，则该文件名就是指定特殊类型数据的文件名。<span lang="EN-US"><o:p></o:p></span></span></p>

<p style="margin: 0cm 0cm 1e-04pt; text-indent: 21pt;"><span style="font-size: 10.5pt;">例如，文件名</span><tt><span style="font-size: 10.5pt;">‘<span lang="EN-US">foo.c'</span></span></tt><span lang="EN-US" style="font-size: 10.5pt;"> 和格式规则 </span><samp><span lang="EN-US" style="font-size: 10.5pt;">`%.c : %.y'</span></samp><span lang="EN-US" style="font-size: 10.5pt;"> (该规则运行Yacc)。无论该规则是否实际使用(如果碰巧存在文件</span><tt><span style="font-size: 10.5pt;">‘<span lang="EN-US">foo.y’，该规则将运行</span></span></tt><span lang="EN-US" style="font-size: 10.5pt;">)，和目标匹配的事实就能足够阻止任何非最终万用规则在文件foo.c上使用。这样，</span><code><span lang="EN-US" style="font-size: 10.5pt;">make</span></code><span lang="EN-US" style="font-size: 10.5pt;"> 考虑就不试图从文件</span><tt><span style="font-size: 10.5pt;">‘<span lang="EN-US">foo.c.o'</span></span></tt><span lang="EN-US" style="font-size: 10.5pt;">,</span><tt><span style="font-size: 10.5pt;">‘<span lang="EN-US">foo.c.c'</span></span></tt><span lang="EN-US" style="font-size: 10.5pt;">, </span><tt><span style="font-size: 10.5pt;">‘<span lang="EN-US">foo.c.p'</span></span></tt><span style="font-size: 10.5pt;">等创建可执行的</span><tt><span style="font-size: 10.5pt;">‘<span lang="EN-US">foo.c'</span></span></tt><span style="font-size: 10.5pt;">。<span lang="EN-US"><o:p></o:p></span></span></p>

<p style="margin: 0cm 0cm 1e-04pt; text-indent: 21pt;"><span style="font-size: 10.5pt;">内建的特殊伪格式规则是用来认定一些特定的文件名，处理这些文件名的文件时不能使用非最终万用规则。这些伪格式规则没有依赖和命令，它们用于其它目的时被忽略。例如，内建的隐含规则：<span lang="EN-US"> <o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">%.p :<o:p></o:p></span></pre>

<p style="margin: 0cm 0cm 1e-04pt;"><span style="font-size: 10.5pt;">存在可以保证<span lang="EN-US">Pascal源程序如</span></span><tt><span style="font-size: 10.5pt;">‘<span lang="EN-US">foo.p'</span></span></tt><span lang="EN-US" style="font-size: 10.5pt;"> 匹配特定的目标格式，从而阻止浪费时间寻找</span><tt><span style="font-size: 10.5pt;">‘<span lang="EN-US">foo.p.o'</span></span></tt><span lang="EN-US" style="font-size: 10.5pt;"> 或</span><tt><span style="font-size: 10.5pt;">‘<span lang="EN-US">foo.p.c'</span></span></tt><span style="font-size: 10.5pt;">。<span lang="EN-US"> <o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">在后缀规则中，为后缀列表中的每一个有效后缀都创建了伪格式规则，如<samp><span style="">‘<span lang="EN-US">%.p'</span></span></samp><span lang="EN-US"> 。参阅<b><i>过时的后缀规则</i></b>。<o:p></o:p></span></span></p>

<h3><a name="_10.5.6删除隐含规则"></a><span lang="EN-US" style="font-size: 14pt; font-family: 宋体;">10.5.6删除隐含规则<o:p></o:p></span></h3>

<p style="margin: 0cm 0cm 1e-04pt; text-indent: 21pt;"><span style="font-size: 10.5pt;">通过定义新的具有相同目标和依赖但不同命令的规则，您可以重载内建的隐含规则（或重载您自己定义的规则）。一旦定义新的规则，内建的规则就被代替。 新规则在隐含规则次序表中的位置由您编写规则的地方决定。<span lang="EN-US"> <o:p></o:p></span></span></p>

<p style="margin: 0cm 0cm 1e-04pt; text-indent: 21pt;"><span style="font-size: 10.5pt;">通过定义新的具有相同目标和依赖但不含命令的规则，您可以删除内建的隐含规则。例如，下面的定义规则将删除运行汇编编译器的隐含规则：<span lang="EN-US"> <o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">%.o : %.s<o:p></o:p></span></pre>

<h2><a name="_10.6_定义最新类型的缺省规则"></a><span lang="EN-US" style="font-family: 宋体;">10.6
定义最新类型的缺省规则<o:p></o:p></span></h2>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">您通过编写不含依赖的最终万用格式规则，您可以定义最新类型的缺省规则。参阅<b><i>万用规则</i></b>。这和其它规则基本一样，特别之处在于它可以匹配任何目标。因此，这样的规则的命令可用于所有没有自己的命令的目标和依赖，以及用于那些没有其它隐含规则可以应用的目标和依赖。<span lang="EN-US"><o:p></o:p></span></span></p>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">例如，在测试<span lang="EN-US">makefile时，您可能不关心源文件是否含有真实数据，仅仅关心它们是否存在。那么，您可以这样做：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">%::<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>touch $@<o:p></o:p></span></pre>

<p><span style="font-size: 10.5pt;">这导致所有必需的源文件（作为依赖）都自动创建。<span lang="EN-US"> <o:p></o:p></span></span></p>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">您可以为没有规则的目标以及那些没有具体指定命令的目标定义命令。要完成上述任务，您需要为特殊目标</span><code><span lang="EN-US" style="font-size: 10.5pt;">.DEFAULT</span></code><span lang="EN-US" style="font-size: 10.5pt;"> 编写规则。这样的规则可以在所有具体规则中用于没有作为目标出现以及不能使用隐含规则的依赖。自然，如果您不编写定义则没有特殊目标</span><code><span lang="EN-US" style="font-size: 10.5pt;">.DEFAULT</span></code><span lang="EN-US" style="font-size: 10.5pt;"> 的规则。<o:p></o:p></span></p>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">如果您使用特殊目标</span><code><span lang="EN-US" style="font-size: 10.5pt;">.DEFAULT</span></code><span lang="EN-US" style="font-size: 10.5pt;"> 而不带任何规则和命令: <o:p></o:p></span></p>

<pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">.DEFAULT:<o:p></o:p></span></pre>

<p><span style="font-size: 10.5pt;">则以前为目标</span><code><span lang="EN-US" style="font-size: 10.5pt;">.DEFAULT</span></code><span style="font-size: 10.5pt;">定义的命令被清除。如此</span><code><span lang="EN-US" style="font-size: 10.5pt;">make</span></code><span style="font-size: 10.5pt;">的行为和您从来没有定义目标</span><code><span lang="EN-US" style="font-size: 10.5pt;">.DEFAULT一样。</span></code><span lang="EN-US" style="font-size: 10.5pt;"> <o:p></o:p></span></p>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">如果您不需要一个目标从万用规则和目标</span><code><span lang="EN-US" style="font-size: 10.5pt;">.DEFAULT</span></code><span lang="EN-US" style="font-size: 10.5pt;"> 中得到命令，也不想为该目标执</span>行任何命<span style="font-size: 10.5pt;">令，您可以在定义时使用空命令。参阅<b><i>使用空命令</i></b>。<span lang="EN-US"><o:p></o:p></span></span></p>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">您可以使用最新类型规则重载另外一个<span lang="EN-US">makefile文件的一部分内容。参阅<b><i>重载其它makefile文件</i></b>。<o:p></o:p></span></span></p>

<h2><a name="_10.7_过时的后缀规则"></a><span lang="EN-US" style="font-family: 宋体;">10.7 过时的后缀规则<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">后缀规则是定义隐含规则的过时方法。后缀规则因为格式规则更为普遍和简洁而被废弃。它们在<span lang="EN-US">GNU make中得到支持是为了和早期的makefile文件兼容。它们分为单后缀和双后缀规则。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">双后缀规则被一对后缀定义：目标后缀和源文件后缀。它可以匹配任何文件名以目标后缀结尾的文件。相应的隐含依赖通过在文件名中将目标后缀替换为源文件后缀得到。一个目标和源文件后缀分别为‘<span lang="EN-US">.o’和‘.c’双后缀规则相当于格式规则</span></span><samp><span lang="EN-US" style="font-family: 宋体;">`%.o : %.c'</span></samp><span style="font-family: 宋体;">。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">单后缀规则被单后缀定义，该后缀是源文件的后缀。它匹配任何文件名，其相应的依赖名是将文件名添加源文件后缀得到。源文件后缀为‘<span lang="EN-US">.c’的单后缀规则相当于格式规则‘</span></span><samp><span lang="EN-US" style="font-family: 宋体;">% : %.c</span></samp><span style="font-family: 宋体;">’。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">通过比较规则目标和定义的已知后缀列表识别后追规则。当<span lang="EN-US">make见到一个目标后缀是已知后缀的规则时，该规则被认为是一个单后缀规则。当make见到一个目标后缀包含两个已知后缀的规则时，该规则被认为是一个双后缀规则。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">例如，‘<span lang="EN-US">.o’和‘.c’都是缺省列表中的已知后缀。所以，如果您定义一个规则，其目标是‘.c.o’，则make认为是一个双后缀规则，源文件后缀是‘.c’，目标后缀是‘.o’。这里有一个采用过时的方法定义编译C语言程序的规则：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">.c.o:<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt;<o:p></o:p></span></pre>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">后缀规则不能有任何属于它们自己的依赖。如果它们有依赖，它们将不是作为后缀规则使用，而是以令人啼笑皆非的方式处理正常的文件。例如，规则：<span lang="EN-US"><o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">.c.o: foo.h<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt;<o:p></o:p></span></pre>

<p><span style="font-size: 10.5pt;">告诉从依赖<span lang="EN-US">foo.h生成文件名为‘</span></span><span lang="EN-US">.c.o</span><span style="font-size: 10.5pt;">’的文件，并不是象格式规则：<span lang="EN-US"> <o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">%.o: %.c foo.h<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt;<o:p></o:p></span></pre>

<p><span style="font-size: 10.5pt;">告诉从</span><samp><span style="font-size: 10.5pt;">‘<span lang="EN-US">.c'</span></span></samp><span style="font-size: 10.5pt;">文件生成 </span><samp><span style="font-size: 10.5pt;">‘<span lang="EN-US">.o'</span></span></samp><span lang="EN-US" style="font-size: 10.5pt;"> 文件</span><samp><span style="font-size: 10.5pt;">‘<span lang="EN-US">.c'的方法</span></span></samp><span style="font-size: 10.5pt;">：创建所有</span><samp><span style="font-size: 10.5pt;">‘<span lang="EN-US">.o'</span></span></samp><span lang="EN-US" style="font-size: 10.5pt;"> 文件使用该格式规则，而且同时使用依赖文件</span><tt><span style="font-size: 10.5pt;">‘<span lang="EN-US">foo.h'</span></span></tt><span style="font-size: 10.5pt;">。<span lang="EN-US"><o:p></o:p></span></span></p>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">没有命令的后缀规则也没有意义。它们并不没有命令的格式规则那样移去以前的规则（参阅<b><i>删除隐含规则</i></b>）。
他们仅仅简单的在数据库中加入后缀或双后缀作为一个目标。<span lang="EN-US"><o:p></o:p></span></span></p>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">已知的后缀是特殊目标‘</span><code><span lang="EN-US" style="font-size: 10.5pt;">.SUFFIXES</span></code><span style="font-size: 10.5pt;">’简单的依赖名。通过为特殊目标‘</span><code><span lang="EN-US" style="font-size: 10.5pt;">.SUFFIXES</span></code><span style="font-size: 10.5pt;">’编写规则加入更多的依赖，您可以添加您自己的已知后缀。例如：<span lang="EN-US"><o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">.SUFFIXES: .hack .win<o:p></o:p></span></pre>

<p><span style="font-size: 10.5pt;">把</span><samp><span style="font-size: 10.5pt;">‘<span lang="EN-US">.hack'</span></span></samp><span lang="EN-US" style="font-size: 10.5pt;"> 和</span><samp><span style="font-size: 10.5pt;">‘<span lang="EN-US">.win'</span></span></samp><span style="font-size: 10.5pt;">添加到了后缀列表中。<span lang="EN-US"><o:p></o:p></span></span></p>

<p><span style="font-size: 10.5pt;">如果您希望排除缺省的已知后缀而不是仅仅的添加后缀，那么您可以为特殊目标‘</span><code><span lang="EN-US" style="font-size: 10.5pt;">.SUFFIXES</span></code><span style="font-size: 10.5pt;">’编写没有依赖的规则。通过这种方式，可以完全排除特殊目标‘</span><code><span lang="EN-US" style="font-size: 10.5pt;">.SUFFIXES</span></code><span style="font-size: 10.5pt;">’存在的依赖。接着您可以编写另外一个规则添加您要添加的后缀。例如，<span lang="EN-US"><o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">.SUFFIXES:<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span># 删除缺省后缀<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">.SUFFIXES: .c .o .h<span style="">&#160;&#160; </span># 定义自己的后缀列表<o:p></o:p></span></pre>

<p><span style="font-size: 10.5pt;">标志</span><samp><span style="font-size: 10.5pt;">‘<span lang="EN-US">-r'</span></span></samp><span style="font-size: 10.5pt;">或</span><samp><span style="font-size: 10.5pt;">‘<span lang="EN-US">--no-builtin-rules'</span></span></samp><span style="font-size: 10.5pt;">也能把缺省的后缀列表清空。<span lang="EN-US"><o:p></o:p></span></span></p>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">变量</span><code><span lang="EN-US" style="font-size: 10.5pt;">SUFFIXES</span></code><span style="font-size: 10.5pt;">在<span lang="EN-US">make读入任何makefile文件之前定义缺省的后缀列表。您可以使用特殊目标‘</span></span><code><span lang="EN-US" style="font-size: 10.5pt;">.SUFFIXES</span></code><span style="font-size: 10.5pt;">’改变后缀列表，但这不能改变变量</span><code><span lang="EN-US" style="font-size: 10.5pt;">SUFFIXES</span></code><span style="font-size: 10.5pt;">的值。<span lang="EN-US"><o:p></o:p></span></span></p>

<h2><a name="_10.8隐含规则搜寻算法"></a><span lang="EN-US" style="font-family: 宋体;">10.8隐含规则搜寻算法<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">这里是<span lang="EN-US">make为一个目标‘t’搜寻隐含规则的过程。这个过程用于任何没有命令的双冒号规则，用于任何不含命令的普通规则的目标，以及用于任何不是其它规则目标的依赖。这个过程也能用于来自隐含规则的依赖递归调用该过程搜寻规则链。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">在本算法中不提及任何后缀规则，因为后缀规则在<span lang="EN-US">makefile文件读入时转化为了格式规则。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">对于个是‘<var><span lang="EN-US">archive</span></var></span><samp><span lang="EN-US" style="font-family: 宋体;">(</span></samp><var><span lang="EN-US" style="font-family: 宋体;">member</span></var><samp><span lang="EN-US" style="font-family: 宋体;">)</span></samp><span style="font-family: 宋体;">’的档案成员目标，下述算法重复两次，第一次使用整个目标名‘<span lang="EN-US">t’，如果第一次运行没有发现规则，则第二次使用‘</span></span><samp><span lang="EN-US" style="font-family: 宋体;">(</span></samp><var><span lang="EN-US" style="font-family: 宋体;">member</span></var><samp><span lang="EN-US" style="font-family: 宋体;">)</span></samp><span style="font-family: 宋体;">’作为目标‘<span lang="EN-US">t’。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 54pt; text-indent: -33pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: 宋体;">1、<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><!--[endif]--><span style="font-family: 宋体;">在‘<span lang="EN-US">t’中分离出路径部分，称为‘d’，剩下部分称为‘n’。例如如果‘t’是‘</span></span><samp><span lang="EN-US" style="font-family: 宋体;">src/foo.o</span></samp><span style="font-family: 宋体;">’，那么‘<span lang="EN-US">d’是‘</span></span><samp><span lang="EN-US" style="font-family: 宋体;">src/</span></samp><span style="font-family: 宋体;">’；‘<span lang="EN-US">n’是‘</span></span><samp><span lang="EN-US" style="font-family: 宋体;">foo.o</span></samp><span style="font-family: 宋体;">’。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 54pt; text-indent: -33pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: 宋体;">2、<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><!--[endif]--><span style="font-family: 宋体;">建立所有目标名匹配‘<span lang="EN-US">t’和‘n’的格式规则列表。如果目标格式中含有斜杠，则匹配‘t’，否则，匹配‘n’。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 54pt; text-indent: -33pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: 宋体;">3、<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><!--[endif]--><span style="font-family: 宋体;">如果列表中有一个规则不是万用规则，则从列表中删除所有非最终万用规则。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 54pt; text-indent: -33pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: 宋体;">4、<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><!--[endif]--><span style="font-family: 宋体;">将没有命令的规则也从列表中移走。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 54pt; text-indent: -33pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: 宋体;">5、<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><!--[endif]--><span style="font-family: 宋体;">对每个列表中的格式规则：<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 60pt; text-indent: -18pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: 宋体;">1、<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160; </span></span><!--[endif]--><span style="font-family: 宋体;">寻找<span lang="EN-US">stem‘s’，也就是和目标格式中%匹配的‘t’或‘n’部分。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 60pt; text-indent: -18pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: 宋体;">2、<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160; </span></span><!--[endif]--><span style="font-family: 宋体;">使用<span lang="EN-US">stem‘s’计算依赖名。如果目标格式不包含斜杠，则将‘d’添加在每个依赖的前面。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 60pt; text-indent: -18pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: 宋体;">3、<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160; </span></span><!--[endif]--><span style="font-family: 宋体;">测试所有的依赖是否存在或能够创建。（如果任何文件在<span lang="EN-US">makefile中作为目标或依赖被提及，则我们说它应该存在。）如果所有依赖存在或能够创建，或没有依赖，则可使用该规则。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 54pt; text-indent: -33pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: 宋体;">6、<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><!--[endif]--><span style="font-family: 宋体;">如果到现在还没有发现能使用的规则，进一步试。对每一个列表中的规则：<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 60pt; text-indent: -18pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: 宋体;">1、<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160; </span></span><!--[endif]--><span style="font-family: 宋体;">如果规则是最终规则，则忽略它，继续下一条规则。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 60pt; text-indent: -18pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: 宋体;">2、<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160; </span></span><!--[endif]--><span style="font-family: 宋体;">象上述一样计算依赖名。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 60pt; text-indent: -18pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: 宋体;">3、<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160; </span></span><!--[endif]--><span style="font-family: 宋体;">测试所有的依赖是否存在或能够创建。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 60pt; text-indent: -18pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: 宋体;">4、<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160; </span></span><!--[endif]--><span style="font-family: 宋体;">对于不存在的依赖，按照该算法递归调用查找是否能够采用隐含规则创建。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 60pt; text-indent: -18pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: 宋体;">5、<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160; </span></span><!--[endif]--><span style="font-family: 宋体;">如果所有依赖存在或能使用隐含规则创建，则应用该规则。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 54pt; text-indent: -33pt;"><!--[if !supportLists]--><span lang="EN-US" style="font-family: 宋体;">7、<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-stretch: normal; font-size-adjust: none;">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><!--[endif]--><span style="font-family: 宋体;">如果没有隐含规则，则如有用于目标‘<span lang="EN-US">.DEFAULT’规则，则应用该规则。在这种情况下，将目标‘.DEFAULT’的命令给与‘t’。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">一旦找到可以应用的规则，对每一个匹配的目标格式（无论是‘<span lang="EN-US">t’或‘n’）使用stem‘s’替换%，将得到的文件名储存起来直到执行命令更新目标文件‘t’。在这些命令执行以后，把每一个储存的文件名放入数据库，并且标志已经更新，其时间戳和目标文件‘t’一样。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">如果格式规则的命令为创建‘<span lang="EN-US">t’执行，自动变量将设置为相应的目标和依赖（参阅<b><i>自动变量</i></b>）。<o:p></o:p></span></span></p>

<h1><a name="_11使用make更新档案文件"></a><span lang="EN-US" style="font-size: 18pt; font-family: 宋体;">11使用make更新档案文件<o:p></o:p></span></h1>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">档案文件是包含子文件的文件，这些子文件有各自的文件名，一般将它们称为成员；档案文件和程序<span lang="EN-US">ar一块被提及，它们的主要用途是作为连接的例程库。<o:p></o:p></span></span></p>

<h2><a name="_11.1档案成员目标"></a><span lang="EN-US" style="font-family: 宋体;">11.1档案成员目标<o:p></o:p></span></h2>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">独立的档案文件成员可以在<span lang="EN-US">make中用作目标或依赖。按照下面的方式，您可以在档案文件‘archive’中指定名为‘member’的成员： <o:p></o:p></span></span></p>

<pre><var><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">archive</span></var><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">(<var>member</var>)<o:p></o:p></span></pre>

<p><span style="font-size: 10.5pt;">这种结构仅仅在目标和依赖中使用，绝不能在命令中应用！
绝大多数程序都不在命令中支持这个语法，而且也不能对档案成员直接操作。只有程序<span lang="EN-US">ar和那些为操作档案文件设计的程序才能这样做。所以合法的更新档案成员的命令一定使用ar。例如，下述规则表明借助拷贝文件‘hack.o’在档案‘foolib’中创建成员‘hack.o’:
<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">foolib(hack.o) : hack.o<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>ar cr foolib hack.o<o:p></o:p></span></pre>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">实际上，几乎所有的档案成员目标是采用这种方式更新的，并且有一条隐含规则为您专门更新档案成员目标。<b>注意：</b>如果档案文件没有直接存在，程序<span lang="EN-US">ar的‘c’标志是需要的。<o:p></o:p></span></span></p>

<p><span style="font-size: 10.5pt;">在相同的档案中同时指定几个成员，您可以在圆括号中一起写出所有的成员名。例如：<span lang="EN-US"> <o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">foolib(hack.o kludge.o)<o:p></o:p></span></pre>

<p><span style="font-size: 10.5pt;">等同于：<span lang="EN-US"> <o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">foolib(hack.o) foolib(kludge.o)<o:p></o:p></span></pre>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">您还可以在档案成员引用中使用<span lang="EN-US">shell类型的通配符。参阅<b><i>在文件名中使用通配符</i></b>。例如，‘</span></span><samp><span lang="EN-US" style="font-size: 10.5pt;">foolib(*.o)'</span></samp><span lang="EN-US" style="font-size: 10.5pt;"> 扩展为在档案‘foolib’中所有存在以‘.o’结尾的成员。也许相当于：</span><samp><span style="font-size: 10.5pt;">‘<span lang="EN-US">foolib(hack.o)
foolib(kludge.o)'。<o:p></o:p></span></span></samp></p>

<h2><a name="_11.2_用于档案成员目标的隐含规则"></a><span lang="EN-US" style="font-family: 宋体;">11.2
档案成员目标的隐含规则<o:p></o:p></span></h2>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">对目标‘<span lang="EN-US">a(m)’表示名为‘m’的成员在档案文件‘a’中。<o:p></o:p></span></span></p>

<p style="text-indent: 21pt;"><span lang="EN-US" style="font-size: 10.5pt;">Make为这种目标搜寻隐含规则时，是用它另外一个的特殊特点：make认为匹配‘(m)’的隐含规则也同时匹配‘a(m)’。<o:p></o:p></span></p>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">该特点导致一个特殊的规则，它的目标是‘<span lang="EN-US">(%)’。该规则通过将文件‘m’拷贝到档案中更新目标‘a(m)’。例如，它通过将文件‘</span></span><tt><span lang="EN-US" style="font-size: 10pt;">bar.o</span></tt><span style="font-size: 10.5pt;">’拷贝到档案‘</span><tt><span lang="EN-US" style="font-size: 10pt;">foo.a</span></tt><span style="font-size: 10.5pt;">’中更新档案成员目标‘</span><tt><span lang="EN-US" style="font-size: 10pt;">foo.a(bar.o)</span></tt><span style="font-size: 10.5pt;">’。<span lang="EN-US"><o:p></o:p></span></span></p>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">如果该规则和其它规则组成链，功能十分强大。‘</span><samp><span lang="EN-US" style="">make "foo.a(bar.o)"'</span></samp><samp><span style="font-size: 10.5pt;">（注意使用双引号是为了保护圆括号可被<span lang="EN-US">shell解释）即使没有makefile文件仅存在文件‘bar.c’就可以保证以下命令执行：<o:p></o:p></span></span></samp></p>

<pre><span lang="EN-US" style="font-family: 宋体;">cc -c bar.c -o bar.o<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">ar r foo.a bar.o<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">rm -f bar.o<o:p></o:p></span></pre>

<p><span style="font-size: 10.5pt;">这里<span lang="EN-US">make假设文件‘bar.o’是中间文件。参阅<b><i>隐含规则链</i></b>。<o:p></o:p></span></span></p>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">诸如这样的隐含规则是使用自动变量‘<span lang="EN-US">$%’编写的，参阅<b><i>自动变量</i></b>。<o:p></o:p></span></span></p>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">档案成员名不能包含路径名，但是在<span lang="EN-US">makefile文件中路径名是有用的。如果您写一个档案成员规则‘</span></span><tt><span lang="EN-US" style="font-size: 10pt;">foo.a(dir/file.o)</span></tt><span style="font-size: 10.5pt;">’，<span lang="EN-US">make将自动使用下述命令更新：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">ar r foo.a dir/file.o<o:p></o:p></span></pre>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">它的结果是拷贝文件‘</span><tt><span lang="EN-US" style="font-size: 10pt;">dir/file.o</span></tt><span style="font-size: 10.5pt;">’进入名为‘</span><span lang="EN-US">file.a</span><span style="font-size: 10.5pt;">’的档案中。在完成这样的任务时使用自动变量<span lang="EN-US">%D和%F。<o:p></o:p></span></span></p>

<h3><a name="_11.2.1更新档案的符号索引表"></a><span lang="EN-US" style="font-size: 14pt; font-family: 宋体;">11.2.1更新档案的符号索引表<o:p></o:p></span></h3>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">用作库的档案文件通常包含一个名为‘</span><tt><span lang="EN-US" style="font-size: 10pt;">__.SYMDEF</span></tt><span style="font-size: 10.5pt;">’ 特殊的成员，成员‘</span><tt><span lang="EN-US" style="font-size: 10pt;">__.SYMDEF</span></tt><span style="font-size: 10.5pt;">’包含由所有其它成员定义的外部符号名的索引表。在您更新其它成员后，您必须更新成员‘</span><tt><span lang="EN-US" style="font-size: 10pt;">__.SYMDEF</span></tt><span style="font-size: 10.5pt;">’，从而使成员‘</span><tt><span lang="EN-US" style="font-size: 10pt;">__.SYMDEF</span></tt><span style="font-size: 10.5pt;">’可以合适的总结其它成员。要完成成员‘</span><tt><span lang="EN-US" style="font-size: 10pt;">__.SYMDEF</span></tt><span style="font-size: 10.5pt;">’的更新需要运行<span lang="EN-US">ranlib程序：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">ranlib <var>archivefile</var><o:p></o:p></span></pre>

<p><span style="font-size: 10.5pt;">正常情况下，您应该将该命令放到档案文件的规则中，把所有档案文件的成员作为该规则的依赖。例如：<span lang="EN-US"> <o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">libfoo.a: libfoo.a(x.o) libfoo.a(y.o) ...<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>ranlib libfoo.a<o:p></o:p></span></pre>

<p><span style="font-size: 10.5pt;">上述程序的结果是更新档案成员</span><tt><span style="font-size: 10.5pt;">‘<span lang="EN-US">x.o'</span></span></tt><span lang="EN-US" style="font-size: 10.5pt;">,</span><tt><span style="font-size: 10.5pt;">‘<span lang="EN-US">y.o'</span></span></tt><span lang="EN-US" style="font-size: 10.5pt;">, 等等, 然后通过运行程序ranlib更新符号索引表表成员</span><tt><span style="font-size: 10.5pt;">‘<span lang="EN-US">__.SYMDEF’。更新成员的规则这里没有列出，多数情况下，您可以省略它们，使用隐含规则把文件拷贝到档案中，具体描述见以前的内容。</span></span></tt><span lang="EN-US" style="font-size: 10.5pt;"> <o:p></o:p></span></p>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">使用<span lang="EN-US">GNU ar程序时这不是必要的，因为它自动更新成员</span></span><tt><span style="font-size: 10.5pt;">‘<span lang="EN-US">__.SYMDEF’</span></span></tt><span style="font-size: 10.5pt;">。<span lang="EN-US"><o:p></o:p></span></span></p>

<h2><a name="_11.3_使用档案的危险"></a><span lang="EN-US" style="font-family: 宋体;">11.3 使用档案的危险<o:p></o:p></span></h2>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">同时使用并行执行（<span lang="EN-US">-j开关，参阅<b><i>并行执行</i></b>）和档案应该十分小心。如果多个命令同时对相同的档案文件操作，它们相互不知道，有可能破坏文件。
将来的make版本可能针对该问题提供一个机制，即将所有操作相同档案文件的命令串行化。但是现在，您必须在编写您自己的makefile文件时避免该问题，或者采用其它方式，或者不使用选项-j。<o:p></o:p></span></span></p>

<h2><a name="_11.4_用于档案文件的后缀规则"></a><span lang="EN-US" style="font-family: 宋体;">11.4
档案文件的后缀规则<o:p></o:p></span></h2>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">为处理档案文件，您可以编写一个特殊类型的后缀规则。关于所有后缀的扩展请参阅<b><i>过时的后缀规则</i></b>。档案后缀规则在<span lang="EN-US">GNU make中已被废弃，因为用于档案的格式规则更加通用（参阅<b><i>档案成员目标的隐含规则</i></b>），但是为了和其它版本的make兼容，它们仍然被保留。<o:p></o:p></span></span></p>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">编写用于档案的后缀规则，您可以简单的编写一个用于目标后缀‘<span lang="EN-US">.a’的后缀规则即可。例如，这里有一个用于从C语言源文件更新档案库的过时后缀规则： <o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">.c.a:<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(CC) $(CFLAGS) $(CPPFLAGS) -c $&lt; -o $*.o<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(AR) r $@ $*.o<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(RM) $*.o<o:p></o:p></span></pre>

<p><span style="font-size: 10.5pt;">这和下面的格式规则工作完全一样：<span lang="EN-US"><o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">(%.o): %.c<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(CC) $(CFLAGS) $(CPPFLAGS) -c $&lt; -o $*.o<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(AR) r $@ $*.o<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(RM) $*.o<o:p></o:p></span></pre>

<p><span style="font-size: 10.5pt;">实际上，这仅仅是<span lang="EN-US">make看到一个以‘.a’作为后缀的后缀规则时，它所做的工作。任何双后缀规则<samp><span style="">‘.</span></samp><var>x</var><samp><span style="">.a'</span></samp> 被转化为一个格式规则，该格式规则的目标格式是<samp><span style="">‘(%.o)'</span></samp> ，依赖格式是<samp><span style="">‘%.</span></samp><var>x</var><samp><span style="">'</span></samp>.。<o:p></o:p></span></span></p>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">因为您可能要使用<samp><span style="">‘<span lang="EN-US">.a'</span></span></samp><span lang="EN-US"> 作为一个文件类型的后缀，make也以正常方式转换档案后缀规则为格式规则，参阅<b><i>过时的后缀规则</i>。</b>这样一个双后缀规则<samp><span style="">‘.</span></samp><var>x</var><samp><span style="">.a'</span></samp> 产生两个格式规则：‘<samp><span style="">(%.o): %.</span></samp><var>x</var><samp><span style="">'</span></samp> 和<samp><span style="">‘%.a: %.</span></samp><var>x</var><samp><span style="">'</span></samp>. <o:p></o:p></span></span></p>

<h1><a name="_12_GNU_make的特点"></a><span lang="EN-US" style="font-size: 18pt; font-family: 宋体;">12 GNU make的特点<o:p></o:p></span></h1>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">这里是<span lang="EN-US">GNU make的特点的总结，用于比较其它版本的make。我们以4.2 BSD 中的make的特点为基准。如果您要编写一个可移植的makefile文件，您不要使用这里列出的make的特点，也不要使用<b><i>不兼容性和失去的特点</i></b>中列出的内容。
<o:p></o:p></span></span></p>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">许多特点在<span lang="EN-US">System V 中的make也存在。<o:p></o:p></span></span></p>

<ul style="margin-top: 0cm;" type="disc">
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">变量</span><code><span lang="EN-US" style="font-family: 宋体;">VPATH</span></code><span lang="EN-US" style="font-family: 宋体;"> 以及它特殊的意义。参阅<b><i>在目录中搜寻依赖</i></b>。这个特点存在于System V 中的make，但没有事实证明。4.3
     BSD </span><code><span lang="EN-US" style="font-family: 宋体;">make也含有该特点（据说是模仿</span></code><span lang="EN-US" style="font-family: 宋体;">System V中变量VPATFH的特点）</span><code><span style="font-family: 宋体;">。</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">包含其它<span lang="EN-US">makefile文件。参阅<b><i>包含其它makefile文件</i>。</b>允许使用一个指令包含多个文件是GNU的扩展。<o:p></o:p></span></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">通过环境，变量可以读入和通讯，参阅<b><i>环境变量</i></b>。<span lang="EN-US"> <o:p></o:p></span></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">通过变量</span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">MAKEFLAGS</span></code><span lang="EN-US" style="font-family: 宋体;"> 在递归调用make时可以传递选项。参阅<b><i>和子make通讯选项</i></b>。 <o:p></o:p></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">在档案引用中自动变量</span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$%</span></code><span lang="EN-US" style="font-family: 宋体;"> 设置为成员名。参阅<b><i>自动变量</i></b>。 <o:p></o:p></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">自动变量</span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$@</span></code><span lang="EN-US" style="font-family: 宋体;">, </span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$*</span></code><span lang="EN-US" style="font-family: 宋体;">, </span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$&lt;</span></code><span lang="EN-US" style="font-family: 宋体;">, </span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$%</span></code><span lang="EN-US" style="font-family: 宋体;">, 和 </span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$?</span></code><span lang="EN-US" style="font-family: 宋体;"> 有变体形式如</span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(@F)</span></code><span style="font-family: 宋体;">和</span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(@D)</span></code><span style="font-family: 宋体;">。我们把此概念化，并使用它对自动变量</span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$^</span></code><span lang="EN-US" style="font-family: 宋体;"> 进行了明显扩展。参阅<b><i>自动变量</i></b>。 <o:p></o:p></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">变量引用。参阅<b><i>变量引用基础</i></b>。<span lang="EN-US"> <o:p></o:p></span></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">命令行选项</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">-b'</span></span></samp><span style="font-family: 宋体;">和</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">-m'</span></span></samp><span style="font-family: 宋体;">，接受和忽略。在<span lang="EN-US">System V </span></span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">make</span></code><span style="font-family: 宋体;">中，这些选项实际起作用。<span lang="EN-US"> <o:p></o:p></span></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">即使指定选项</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">-n'</span></span></samp><span lang="EN-US" style="font-family: 宋体;">,</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">-q'</span></span></samp><span style="font-family: 宋体;">或‘</span><samp><span lang="EN-US" style="font-family: 宋体;">-t'，也能通过变量MAKE执行地归调用make的命令。</span></samp><span style="font-family: 宋体;">参阅<b><i>递归调用<span lang="EN-US">make</span></i></b>。<span lang="EN-US"><o:p></o:p></span></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">在后缀规则中支持后缀</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">.a'</span></span></samp><span style="font-family: 宋体;">。参阅<b><i>用于档案文件的后缀规则</i></b>。这个特点在<span lang="EN-US">GNU make中几乎不用，因为规则链更加通用的特点（参阅<b><i>隐含规则链</i></b>）允许一个格式规则用于在档案中安装成员已经足够（参阅<b><i>用于档案成员目标的隐含规则</i></b>）。<o:p></o:p></span></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">在命令中行排列和反斜杠<span lang="EN-US">-新行结合依旧保留，当命令打印时，它们出现的格式和它们在makefile文件中基本一样，不同之处是去掉了初始化空白。<o:p></o:p></span></span></li>
</ul>

<p class="MsoNormal" style="margin-left: 18pt;"><span style="font-family: 宋体;">下面的特点被各种不同版本的<span lang="EN-US">make吸收，但哪些版本吸收了哪些特点并不十分清楚。<o:p></o:p></span></span></p>

<ul style="margin-top: 0cm;" type="disc">
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">在格式规则中使用‘<span lang="EN-US">%’。已经有几个不同版本的make使用了该特点。我们不能确认是谁发明了它，但它发展很快。参阅<b><i>定义与重新定义格式规则</i></b>。
     <o:p></o:p></span></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">规则链以及隐含中间文件。这个特点首先由<span lang="EN-US">Stu Feldman 在它的make版本中实现，并用于AT&amp;T
     第八版Unix研究中。后来AT&amp;T贝尔实验室的Andrew Hume 在它的mk程序中应用（这里称为“传递闭合”）。我们并不清楚是从他们那里得到这个特点或是同时我们自己开发出来的。参阅<b><i>隐含规则链</i>。</b><o:p></o:p></span></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">自动变量包含当前目标的所有依赖的列表。我们一点也不知道是谁做的。参阅<b><i>自动变量</i></b>。自动变量</span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$+</span></code><span lang="EN-US" style="font-family: 宋体;"> 是变量</span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$^</span></code><span style="font-family: 宋体;">的简单扩展。<span lang="EN-US"><o:p></o:p></span></span></li>
 <li class="MsoNormal" style=""><span lang="EN-US" style="font-family: 宋体;">"what if" 标志(GNU </span><code><span lang="EN-US" style="font-family: 宋体;">make中的</span></code><samp><span style="font-family: 宋体;">‘<span lang="EN-US">-W'</span></span></samp><span lang="EN-US" style="font-family: 宋体;">) 是Andrew Hume 在mk中发明的。参阅<b><i>代替执行命令</i></b>。
     <o:p></o:p></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">并行执行的概念在许多版本的<span lang="EN-US">make中存在，尽管System V 或BSD
     并没有实现。参阅<b><i>执行命令</i></b>。<o:p></o:p></span></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">使用格式替换改变变量引用来自于<span lang="EN-US">SunOS 4。参阅<b><i>变量引用基础</i></b>。在GNU
     make中，这个功能在变换语法和SunOS 4兼容之前由函数patsubst提供。不知道谁是权威，因为GNU </span></span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">make</span></code><span lang="EN-US" style="font-family: 宋体;"> 使用函数 </span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">patsubst</span></code><span lang="EN-US" style="font-family: 宋体;"> 在 SunOS 4 发布之前。 <o:p></o:p></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">在命令行前面的‘<span lang="EN-US">+’字符有特殊重要的意义（参阅<b><i>代替执行命令</i></b>）。这是由<cite>IEEE
     Standard 1003.2-1992</cite> (POSIX.2)定义的。 <o:p></o:p></span></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">使用</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">+=语法为变量追加值</span></span></samp><span style="font-family: 宋体;">来自于<span lang="EN-US">SunOS 4 </span></span><code><span lang="EN-US" style="font-family: 宋体;">make</span></code><span style="font-family: 宋体;">。参阅<b><i>为变量值追加文本</i></b>。<span lang="EN-US"> <o:p></o:p></span></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">语法</span><samp><span style="font-family: 宋体;">‘</span></samp><var><span lang="EN-US" style="font-family: 宋体;">archive</span></var><samp><span lang="EN-US" style="font-family: 宋体;">(</span></samp><var><span lang="EN-US" style="font-family: 宋体;">mem1</span></var><samp><span lang="EN-US" style="font-family: 宋体;"> </span></samp><var><span lang="EN-US" style="font-family: 宋体;">mem2</span></var><samp><span lang="EN-US" style="font-family: 宋体;">...)'在单一档案文件中列举多个成员</span></samp><span style="font-family: 宋体;">来自于<span lang="EN-US">SunOS 4 </span></span><code><span lang="EN-US" style="font-family: 宋体;">make</span></code><span lang="EN-US" style="font-family: 宋体;">.。参阅<b><i>档案成员目标</i></b>。 <o:p></o:p></span></li>
 <li class="MsoNormal" style=""><code><span lang="EN-US" style="font-family: 宋体;">-include</span></code><span style="font-family: 宋体;">指令包括<span lang="EN-US">makefile文件，并且对于不存在的文件也不产生错误。该特点with来自于SunOS
     4 </span></span><code><span lang="EN-US" style="font-family: 宋体;">make</span></code><span style="font-family: 宋体;">。<span lang="EN-US">(但是SunOS 4 </span></span><code><span lang="EN-US" style="font-family: 宋体;">make</span></code><span lang="EN-US" style="font-family: 宋体;"> 在单个指令中指定多个makefile文件。) 该特点和SGI </span><code><span lang="EN-US" style="font-family: 宋体;">make 的sinclude</span></code><span lang="EN-US" style="font-family: 宋体;"> 相同，<o:p></o:p></span></li>
</ul>

<p><span style="font-size: 10.5pt;">剩余的特点是由<span lang="EN-US">GNU make发明的： <o:p></o:p></span></span></p>

<ul style="margin-top: 0cm;" type="disc">
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">使用<samp><span style="">‘<span lang="EN-US">-v'或`--version'选项打印版本和拷贝权信息。</span></span></samp><span lang="EN-US"> <o:p></o:p></span></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">使用<samp><span style="">‘<span lang="EN-US">-h'</span></span></samp><span lang="EN-US"> 或<samp><span style="">‘--help'</span></samp>
     选项总结make的选项。 <o:p></o:p></span></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">简单扩展型变量。参阅<b><i>变量的两特特色</i></b>。<span lang="EN-US"> <o:p></o:p></span></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">在递归调用<span lang="EN-US">make时，通过变量MAKE自动传递命令行变量。参阅<b><i>递归调用make</i></b>。
     <o:p></o:p></span></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">使用命令选项<samp><span style="">‘<span lang="EN-US">-C'</span></span></samp><span lang="EN-US"> 或<samp><span style="">‘--directory'</span></samp>改变路径。参阅<b><i>选项概要</i></b>。
     <o:p></o:p></span></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">定义多行变量。参阅<b><i>定义多行变量</i></b>。<span lang="EN-US"><o:p></o:p></span></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">使用特殊目标<span lang="EN-US">.PHONY声明假想目标。AT&amp;T 贝尔实验室Andrew
     Hume 使用不同的语法在它的mk程序中也实现了该功能。这似乎是并行的发现。参阅<b><i>假想目标</i></b>。 <o:p></o:p></span></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">调用函数操作文本。参阅<b><i>用于转换文本的函数</i></b>。<span lang="EN-US"> <o:p></o:p></span></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">使用<samp><span style="">‘<span lang="EN-US">-o'</span></span></samp>或<samp><span style="">‘<span lang="EN-US">--old-file'</span></span></samp>选项假装文件是旧文件。参阅<b><i>避免重新编译文件</i></b>。<span lang="EN-US"> <o:p></o:p></span></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">条件执行。该特点已在不同版本<span lang="EN-US">make中已经实现很长时间了；它似乎是C与处理程序和类似的宏语言的自然扩展，而不是革命性的概念。参阅<b><i>makefile文件中的条件语句</i></b>。
     <o:p></o:p></span></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">指定包含的<span lang="EN-US">makefile文件的搜寻路径。参阅<b><i>包含其它makefile文件</i></b>。<o:p></o:p></span></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">使用环境变量指定额外的<span lang="EN-US">makefile文件。参阅<b><i>变量MAKEFILES</i></b>。<o:p></o:p></span></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">从文件名中去除前导斜杠<samp><span lang="EN-US" style="">`./'</span></samp><span lang="EN-US"> ，因此，<tt><span style="">‘./</span></tt><var>file</var><tt><span style="">'</span></tt>
     和<tt><span style="">‘</span></tt><var>file</var><tt><span style="">'</span></tt> 是指同一个文件。<o:p></o:p></span></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">使用特别搜寻方法搜寻形式如‘<samp><span lang="EN-US" style="">-l</span></samp><var><span lang="EN-US">name</span></var>’的库依赖。参阅<b><i>连接库搜寻目录</i></b>。<span lang="EN-US"><o:p></o:p></span></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">允许后缀规则中的后缀包含任何字符（参阅<b><i>过时的后缀规则</i></b>）。在其它版本的<span lang="EN-US">make中后缀必须以‘.’开始，并且不能包含‘/’字符。 <o:p></o:p></span></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">包吹跟踪当前<span lang="EN-US">make级别适用的变量MAKWFILES的值，参阅<b><i>递归调用make</i></b>。
     <o:p></o:p></span></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">将任何在命令行中给出的目标放入变量<span lang="EN-US">MAKECMDGOALS。参阅<b><i>指定最终目标的参数</i></b>。
     <o:p></o:p></span></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">指定静态格式规则。参阅<b><i>静态格式规则</i></b>。<span lang="EN-US"> <o:p></o:p></span></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">提供选择性<span lang="EN-US">vpath搜寻。参阅<b><i>在目录中搜寻依赖</i></b>。
     <o:p></o:p></span></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">提供可计算的变量引用。参阅<b>变<i>量引用基础</i></b>。<span lang="EN-US">
     <o:p></o:p></span></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">更新<span lang="EN-US">makefile文件。参阅重建makefile文件。System
     V <code><span style="">make</span></code> 中有非常非常有限的来自于该功能的形式，它用于为make检查SCCS文件。<o:p></o:p></span></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">各种新建的隐含规则。参阅<b><i>隐含规则目录</i></b>。<span lang="EN-US"> <o:p></o:p></span></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">内建变量<samp><span lang="EN-US" style="">`MAKE_VERSION'</span></samp><span lang="EN-US"> 给出make的版本号。<o:p></o:p></span></span></li>
</ul>

<h1><a name="_13_不兼容性和去掉的特点"></a><span lang="EN-US" style="font-size: 18pt; font-family: 宋体;">13 不兼容性和失去的特点<o:p></o:p></span></h1>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">其它版本的<span lang="EN-US">make程序也有部分特点在GNU </span></span><code><span lang="EN-US" style="font-size: 10.5pt;">make</span></code><span style="font-size: 10.5pt;">中没有实现。<span lang="EN-US">POSIX.2
标准 (<cite>IEEE Standard 1003.2-1992</cite>)规定不需要这些特点。<o:p></o:p></span></span></p>

<ul style="margin-top: 0cm;" type="disc">
 <li class="MsoNormal" style=""><samp><span style="font-family: 宋体;">‘</span></samp><var><span lang="EN-US" style="font-family: 宋体;">file</span></var><samp><span lang="EN-US" style="font-family: 宋体;">((</span></samp><var><span lang="EN-US" style="font-family: 宋体;">entry</span></var><samp><span lang="EN-US" style="font-family: 宋体;">))'</span></samp><span lang="EN-US" style="font-family: 宋体;"> 形式的目标代表一个档案文件的成员file。选择该成员不使用文件名，而是通过一个定义连接符号enty的OBJ文件。该特点没有被GNU
     <code><span style="">make</span></code> 吸收因为该非标准组件将为make加入档案文件符号表的内部知识。参阅<b><i>更新档案符号索引表</i>。
     <o:p></o:p></b></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">在后缀规则中以字符‘<span lang="EN-US">~’结尾的后缀在System V <code><span style="">make中有特别的含义；它们指和文件名中没有‘~’的文件通讯的</span></code>SCCS
     文件。例如，后缀规则<samp><span style="">‘.c~.o'</span></samp>将从名为<tt><span style="">‘s.</span></tt><var>n</var><tt><span style="">.c'</span></tt>的SCCS文件中抽取文件<tt><span style="">‘</span></tt><var>n</var><tt><span style="">.o'</span></tt>。为了完全覆盖，需要这种整系列的后缀规则，参阅<b><i>过时的后缀规则</i></b>。在GNU
     <code><span style="">make</span></code>中，这种整系列的后缀规则由勇于从SCCS文件抽取的两个格式规则掌管，它们可和通用的规则结合成规则链，参阅<b><i>隐含规则链</i></b>。
     <o:p></o:p></span></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">在<span lang="EN-US">System V <code><span style="">make中</span></code>,
     字符串<samp><span style="">‘$$@'</span></samp>又奇特的含义，在含有多个规则的依赖中，它代表正在处理的特殊目标。这在GNU
     <code><span style="">make没有定义，因为字符串</span></code><samp><span style="">‘$$'</span></samp>代表一个平常的字符‘<samp><span style="">$'</span></samp>。使用静态格式规则可以实现该功能的一部分（参阅<b><i>静态格式规则</i></b>）。System
     V <code><span style="">make</span></code> 中的规则： <o:p></o:p></span></span></li>
</ul>

<pre style=""><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">$(targets): $$@.o lib.a<o:p></o:p></span></pre>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">在<span lang="EN-US"> GNU <code><span style="">make</span></code> 中可以用静态格式规则代替： <o:p></o:p></span></span></p>

<pre style="margin-left: 36pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">$(targets): %: %.o lib.a<o:p></o:p></span></pre>

<ul style="margin-top: 0cm;" type="disc">
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">在<span lang="EN-US">System V 和 4.3 BSD <code><span style="">make中，</span></code>
     通过<code><span style="">VPATH</span></code>搜寻（参阅<b><i>为依赖搜寻目录</i>）</b>发现的文件，它们的文件名改变后加入到命令字符串中。我们认为使用自动变量更简单明了，所以不引进该特点。<o:p></o:p></span></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">在一些<span lang="EN-US">Unix <code><span style="">make</span></code>中，自动变量<code><span style="">$*</span></code>出现在规则的依赖中有令人惊奇的特殊特点：扩展为该规则的目标全名。我们不能明白Unix
     <code><span style="">make</span></code> 在心中对这是怎样考虑的，它和正常的变量<code><span style="">$*</span></code>定义完全不同。<o:p></o:p></span></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">在一些<span lang="EN-US">Unix <code><span style="">make</span></code>中，隐含规则搜寻（参阅<b><i>使用隐含规则</i></b>）明显是为所有目标做的，而不仅仅为那些没有命令的目标。这意味着：<o:p></o:p></span></span></li>
</ul>

<pre style=""><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">foo.o:<o:p></o:p></span></pre><pre style="margin-left: 18pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160; </span>cc -c foo.c<o:p></o:p></span></pre>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">在<span lang="EN-US">Unix <code><span style="">make</span></code> 有直觉知道<tt><span style="">‘foo.o'</span></tt> 依靠<tt><span style="">‘foo.c'</span></tt>。我们认为这样的用法易导致混乱。Make中依赖的属性已经定义好（至少对于GNU
<code><span style="">make</span></code>是这样），再做这样的事情不合规矩。
<o:p></o:p></span></span></p>

<ul style="margin-top: 0cm;" type="disc">
 <li class="MsoNormal" style=""><span lang="EN-US" style="font-family: 宋体;">GNU <code><span style="">make</span></code>不包含任何编译以及与处理EFL程序的隐含规则。如果我们听说谁使用EFL，我们乐意把它们加入。
     <o:p></o:p></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">在<span lang="EN-US"> SVR4 <code><span style="">make</span></code>中，一条后缀规则可以不含命令，它的处理方式和它含有空命令的处理方式一样（参阅<b><i>使用空命令</i></b>）。例如：<o:p></o:p></span></span></li>
</ul>

<pre style=""><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">.c.a:<o:p></o:p></span></pre>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">将重载内建的后缀规则<tt><span style="">‘<span lang="EN-US">.c.a'</span></span></tt><span lang="EN-US"> 。我们觉得对没有命令的规则简单的为目标添加依赖更为简洁。上述例子和在GNU
<code><span style="">make</span></code>中下例的行为相同。<o:p></o:p></span></span></p>

<pre style="margin-left: 36pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">.c.a: ;<o:p></o:p></span></pre>

<ul style="margin-top: 0cm;" type="disc">
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">一些版本的<code><span lang="EN-US" style="">make</span></code><span lang="EN-US"> 调用shell使用<samp><span style="">‘-e'</span></samp>标志，而不是<samp><span style="">‘-k'标志</span></samp> (参阅<b><i>测试程序编译</i></b>)。标志<samp><span style="">‘-e'</span></samp>告诉shell 一旦程序运行返回非零状态就立即退出。我们认为根据每一命令行是否需要需要特殊处理直接写入命令中更为清楚。
     <o:p></o:p></span></span></li>
</ul>

<h1><a name="_14_makefile文件惯例"></a><span lang="EN-US" style="font-size: 18pt; font-family: 宋体;">14 makefile文件惯例<o:p></o:p></span></h1>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">本章描述为<span lang="EN-US">GNU make编写makefile文件的惯例。使用Automake将帮助您按照这些惯例编写makefile文件。<o:p></o:p></span></span></p>

<h2><a name="_14.1_makefile文件的通用惯例"></a><span lang="EN-US" style="font-family: 宋体;">14.1 makefile文件的通用惯例<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">任何<span lang="EN-US">makefile文件都应该包含这行：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">SHELL = /bin/sh<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">避免在系统中变量<span lang="EN-US">SHELL可能继承环境中值的麻烦。（在GNU
make中这从来不是问题。）<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">不同的<span lang="EN-US">make程序有不同的后缀列表和隐含规则，这有可能造成混乱或错误的行为。因此最好的办法是设置后缀列表，在该列表中，仅仅包含您在特定makefile文件中使用的后缀。例如：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;">.SUFFIXES:<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">.SUFFIXES: .c .o<o:p></o:p></span></pre>

<p style="margin: 0cm 0cm 1e-04pt;"><span style="font-size: 10.5pt;">第一行清除了后缀列表，第二行定义了在该<span lang="EN-US">makefile中可能被隐含规则使用的后缀。<o:p></o:p></span></span></p>

<p style="margin: 0cm 0cm 1e-04pt; text-indent: 21pt;"><span style="font-size: 10.5pt;">不要假设</span><tt><span style="font-size: 10.5pt;">‘<span lang="EN-US">.'</span></span></tt><span lang="EN-US" style="font-size: 10.5pt;"> 是命令执行的路径。当您在创建程序过程中，需要运行仅是您程序包中一部分的程序时，请确认如果该程序是要创建程序的一部分使用‘./’，如果该程序是源代码中不变的部分使用‘</span><tt><span lang="EN-US" style="font-size: 10.5pt;">$(srcdir)</span></tt><span style="font-size: 10.5pt;">’。没有这些前缀，仅仅在当前路径下搜索。<span lang="EN-US"><o:p></o:p></span></span></p>

<p style="margin: 0cm 0cm 1e-04pt; text-indent: 21pt;"><span style="font-size: 10.5pt;">建造目录（<strong><span lang="EN-US" style="font-weight: normal;">build
directory</span></strong><span lang="EN-US"> ）‘./’和源代码目录(<strong>source directory</strong>)</span></span><span lang="EN-US"> </span><span style="font-size: 10.5pt;">‘</span><tt><span lang="EN-US" style="font-size: 10.5pt;">$(srcdir)</span></tt><span style="font-size: 10.5pt;">’的区别是很重要的，因为用户可以在‘<span lang="EN-US">configure’中使用‘<samp><span style="">--srcdir</span></samp>’选项建造一个单独的目录。下面的规则：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">foo.1 : foo.man sedscript<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>sed -e sedscript foo.man &gt; foo.1<o:p></o:p></span></pre>

<p style="margin: 0cm 0cm 1e-04pt;"><span style="font-size: 10.5pt;">如果创建的目录不是源代码目录将失败，因为文件‘</span><tt><span lang="EN-US" style="font-size: 10.5pt;">foo.man’</span></tt><span style="font-size: 10.5pt;">和‘</span><tt><span lang="EN-US" style="font-size: 10.5pt;">sedscript’</span></tt><span style="font-size: 10.5pt;">在源代码目录下。<span lang="EN-US"><o:p></o:p></span></span></p>

<p style="margin: 0cm 0cm 1e-04pt; text-indent: 21pt;"><span style="font-size: 10.5pt;">在使用<span lang="EN-US">GNU </span></span><code><span lang="EN-US" style="font-size: 10.5pt;">make时</span></code><span style="font-size: 10.5pt;">，依靠变量‘<span lang="EN-US">VPATH’搜寻源文件在单个从属性文件存在情况下可以很好地工作，因为make中自动变量‘$&lt;’中含有源文件的存在路径。（许多版本的make仅在隐含规则中设值变量‘$&lt;’。）
例如这样的makefile文件目标： <o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">foo.o : bar.c<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160; </span><span style="">&#160;</span>$(CC) -I. -I$(srcdir) $(CFLAGS) -c bar.c -o foo.o<o:p></o:p></span></pre>

<p style="margin: 0cm 0cm 1e-04pt;"><span style="font-size: 10.5pt;">将被替换为：<span lang="EN-US"> <o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">foo.o : bar.c<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(CC) -I. -I$(srcdir) $(CFLAGS) -c $&lt; -o $@<o:p></o:p></span></pre>

<p style="margin: 0cm 0cm 1e-04pt;"><span style="font-size: 10.5pt;">这是为了保证变量‘<samp><span lang="EN-US" style="">VPATH’正确的工作。目标含有多个依赖时，使用名了的‘$(srcdir)’是最容易的保证该规则很好工作的方法。例如，以上例子中的目标‘foo.l’最好写为：</span></samp><span lang="EN-US"> <o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">foo.1 : foo.man sedscript<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>sed -e $(srcdir)/sedscript $(srcdir)/foo.man &gt; $@<o:p></o:p></span></pre>

<p style="margin: 0cm 0cm 1e-04pt; text-indent: 21pt;"><span lang="EN-US" style="font-size: 10.5pt;">GNU的分类中通常包含一些不是源文件的文件――例如，‘Info’文件、从Autoconf,
Automake, Bison 或 Flex中输出的文件等。这些文件在源文件目录下，它们也应该在源文件目录下，不应该在建造目录下。因此makefile规则应在源文件目录下更新它们。
<o:p></o:p></span></p>

<p style="margin: 0cm 0cm 1e-04pt; text-indent: 21pt;"><span style="font-size: 10.5pt;">然而，如果一个文件没有在分类中出现，<span lang="EN-US">makefile文件不应把它们放到源文件目录下，因为按照通常情况创建一个程序，不应该以任何方式更改源文件目录。
<o:p></o:p></span></span></p>

<p style="margin: 0cm 0cm 1e-04pt; text-indent: 21pt;"><span style="font-size: 10.5pt;">试图建造的创建和安装目标，至少（以及它们的子目标）可在并行的<span lang="EN-US">make中正确的工作。<o:p></o:p></span></span></p>

<h2><a name="_14.2_makefile文件中的工具"></a><span lang="EN-US" style="font-family: 宋体;">14.2 makefile文件的工具<o:p></o:p></span></h2>

<p style="margin: 0cm 0cm 1e-04pt; text-indent: 21pt;"><span style="font-size: 10.5pt;">编写在<span lang="EN-US">shell sh中运行而不在csh中运行的makefile文件命令(以及shell的脚本，例如‘configure’)，不要使用任何ksh或bash的特殊特点。
<o:p></o:p></span></span></p>

<p style="margin: 0cm 0cm 1e-04pt; text-indent: 21pt;"><code><span style="font-size: 10.5pt;">用于</span></code><span style="font-size: 10.5pt;">创建和安装的</span><code><span style="font-size: 10.5pt;">‘<span lang="EN-US">configure’</span></span></code><span style="font-size: 10.5pt;">脚本和<span lang="EN-US">Makefile
规则除下面所列出工具外不应该直接使用其它的任何工具： <o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">cat cmp cp diff echo egrep expr false grep install-info<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">ln ls mkdir mv pwd rm rmdir sed sleep sort tar test touch true<o:p></o:p></span></pre>

<p style="margin: 0cm 0cm 1e-04pt; text-indent: 21pt;"><span style="font-size: 10.5pt;">压缩程序</span><code><span lang="EN-US" style="font-size: 10.5pt;">gzip</span></code><span style="font-size: 10.5pt;">可在</span><code><span lang="EN-US" style="font-size: 10.5pt;">dist</span></code><span style="font-size: 10.5pt;">规则中使用。<span lang="EN-US"><o:p></o:p></span></span></p>

<p style="margin: 0cm 0cm 1e-04pt; text-indent: 21pt;"><span style="font-size: 10.5pt;">坚持使用用于这些程序的通用选项，例如，不要使用</span><samp><span style="font-size: 10.5pt;">‘<span lang="EN-US">mkdir -p'</span></span></samp><span style="font-size: 10.5pt;">，它可能比较方便，但是其它大多数系统却不支持它。<span lang="EN-US"> <o:p></o:p></span></span></p>

<p style="margin: 0cm 0cm 1e-04pt; text-indent: 21pt;"><span style="font-size: 10.5pt;">避免在<span lang="EN-US">makefile中创造符号连接是非常不错的注意，因为一些系统不支持这种做法。<o:p></o:p></span></span></p>

<p style="margin: 0cm 0cm 1e-04pt; text-indent: 21pt;"><code><span style="font-size: 10.5pt;">用于</span></code><span style="font-size: 10.5pt;">创建和安装的<span lang="EN-US">Makefile 规则可以使用编译器以及相关的程序，但应该通过make变量使用它们，这样可以方便用户使用别的进行替换。这里有按照我们的观念编写一些程序：
<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">ar bison cc flex install ld ldconfig lex<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">make makeinfo ranlib texi2dvi yacc<o:p></o:p></span></pre>

<p style="margin: 0cm 0cm 1e-04pt;"><span style="font-size: 10.5pt;">请使用下述</span><code><span lang="EN-US" style="font-size: 10.5pt;">make</span></code><span style="font-size: 10.5pt;">变量运行这些程序<span lang="EN-US">: <o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">$(AR) $(BISON) $(CC) $(FLEX) $(INSTALL) $(LD) $(LDCONFIG) $(LEX)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">$(MAKE) $(MAKEINFO) $(RANLIB) $(TEXI2DVI) $(YACC)<o:p></o:p></span></pre>

<p style="margin: 0cm 0cm 1e-04pt; text-indent: 21pt;"><span style="font-size: 10.5pt;">使用</span><code><span lang="EN-US" style="font-size: 10.5pt;">ranlib</span></code><span style="font-size: 10.5pt;">或</span><code><span lang="EN-US" style="font-size: 10.5pt;">ldconfig</span></code><span style="font-size: 10.5pt;">，您应该确定如果系统中不存在要使用的程序不会引起任何副作用。安排忽略这些命令产生的错误，并且打印信息告诉用户该命令运行失败并不意味着存在问题。（<span lang="EN-US">Autoconf</span></span><samp><span style="font-size: 10.5pt;">‘<span lang="EN-US">AC_PROG_RANLIB'宏可在这方面帮助您。）</span></span></samp><span style="font-size: 10.5pt;">如果您使用符号连接，对于不支持符号连接的系统您应该有一个低效率运行方案。<span lang="EN-US"> <o:p></o:p></span></span></p>

<p style="margin: 0cm 0cm 1e-04pt; text-indent: 21pt;"><span style="font-size: 10.5pt;">附加的工具也可通过<span lang="EN-US">make变量使用： <o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">chgrp chmod chown mknod<o:p></o:p></span></pre>

<p style="margin: 0cm 0cm 1e-04pt; text-indent: 21pt;"><span style="font-size: 10.5pt;">它在<span lang="EN-US">makefile中（或脚本中），您知道包含这些工具的特定系统中它都可以很好的工作。<o:p></o:p></span></span></p>

<h2><a name="_14.3_指定命令的变量"></a><span lang="EN-US" style="font-family: 宋体;">14.3 指定命令的变量<o:p></o:p></span></h2>

<p style="margin: 0cm 0cm 1e-04pt; text-indent: 21pt;"><span lang="EN-US" style="font-size: 10.5pt;">Makefile文件应该为重载的特定命令、选项等提供变量。 <o:p></o:p></span></p>

<p style="margin: 0cm 0cm 1e-04pt; text-indent: 21pt;"><span style="font-size: 10.5pt;">特别在您运行大部分工具时都应该应用变量，如果您要使用程序<span lang="EN-US">Bison, 名为</span></span><code><span lang="EN-US" style="font-size: 10.5pt;">BISON</span></code><span lang="EN-US" style="font-size: 10.5pt;"> 的变量它的缺省值设置为：‘</span><samp><span lang="EN-US" style="font-size: 10.5pt;">BISON = bison’</span></samp><span style="font-size: 10.5pt;">，在您需要使用程序<span lang="EN-US">Bison时，您可以使用</span></span><code><span lang="EN-US" style="font-size: 10.5pt;">$(BISON)引用。</span></code><span lang="EN-US" style="font-size: 10.5pt;"> <o:p></o:p></span></p>

<p style="margin: 0cm 0cm 1e-04pt; text-indent: 21pt;"><span style="font-size: 10.5pt;">文件管理器工具如</span><code><span lang="EN-US" style="font-size: 10.5pt;">ln</span></code><span lang="EN-US" style="font-size: 10.5pt;">, </span><code><span lang="EN-US" style="font-size: 10.5pt;">rm</span></code><span lang="EN-US" style="font-size: 10.5pt;">, </span><code><span lang="EN-US" style="font-size: 10.5pt;">mv</span></code><span style="font-size: 10.5pt;">等等，不必要使用这种方式引用，因为用户不可能使用别的程序替换它们。<span lang="EN-US"> <o:p></o:p></span></span></p>

<p style="margin: 0cm 0cm 1e-04pt; text-indent: 21pt;"><span style="font-size: 10.5pt;">每一个程序变量应该和用于向该程序提供选项的选项变量一起提供。在程序名变量后添加</span><samp><span style="font-size: 10.5pt;">‘<span lang="EN-US">FLAGS'</span></span></samp><span style="font-size: 10.5pt;">表示向该程序提供选项的选项变量<span lang="EN-US">--例如, </span></span><code><span lang="EN-US" style="font-size: 10.5pt;">BISONFLAGS</span></code><span style="font-size: 10.5pt;">。<span lang="EN-US">(名为</span></span><code><span lang="EN-US" style="font-size: 10.5pt;">CFLAGS</span></code><span style="font-size: 10.5pt;">的变量向<span lang="EN-US">C编译器提供选项,
名为</span></span><code><span lang="EN-US" style="font-size: 10.5pt;">YFLAGS</span></code><span style="font-size: 10.5pt;">的变量向<span lang="EN-US">yacc提供选项，名为</span></span><code><span lang="EN-US" style="font-size: 10.5pt;">LFLAGS</span></code><span style="font-size: 10.5pt;">的变量向<span lang="EN-US">lex提供选项</span></span><code><span style="font-size: 10.5pt;">等是这个规则例外，但因为它们是标准所以我们保留它们。<span lang="EN-US">)</span></span></code><span lang="EN-US" style="font-size: 10.5pt;"> 在任何进行预处理的编译命令中使用变量</span><code><span lang="EN-US" style="font-size: 10.5pt;">CPPFLAGS</span></code><span lang="EN-US" style="font-size: 10.5pt;"> ，在任何进行连接的编译命令中使用变量</span><code><span lang="EN-US" style="font-size: 10.5pt;">LDFLAGS</span></code><span lang="EN-US" style="font-size: 10.5pt;"> 和直接使用程序ld一样。<o:p></o:p></span></p>

<p style="margin: 0cm 0cm 1e-04pt; text-indent: 21pt;"><span style="font-size: 10.5pt;">对于<span lang="EN-US">C编译器在编译特定文件时必须使用的选项，不应包含在变量</span></span><code><span lang="EN-US" style="font-size: 10.5pt;">CFLAGS</span></code><span style="font-size: 10.5pt;">中，因为用户希望他们能够自由的指定变量</span><code><span lang="EN-US" style="font-size: 10.5pt;">CFLAGS</span></code><span style="font-size: 10.5pt;">。 要独立于变量<span lang="EN-US">CFLAGS安排向C编译器传递这些必要的选项,
可以将这些选项写入编译命令行中或隐含规则的定义中，如下例： <o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">CFLAGS = -g<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">ALL_CFLAGS = -I. $(CFLAGS)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">.c.o:<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(CC) -c $(CPPFLAGS) $(ALL_CFLAGS) $&lt;<o:p></o:p></span></pre>

<p><span style="font-size: 10.5pt;">变量<span lang="EN-US">CFLAGS中包括选项‘-g’，因为它对于一些编译并不是必需的，您可以认为它是缺省推荐的选项。如果数据包创建使用GCC作为编译器，则变量CFLAGS中包括选项‘-o’,而且以它为缺省值。
<o:p></o:p></span></span></p>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">将变量</span><code><span lang="EN-US" style="font-size: 10.5pt;">CFLAGS</span></code><span style="font-size: 10.5pt;">放到编译命令的最后，在包含编译选项其它变量的后边，因此用户可以使用变量<span lang="EN-US">CFLAGS对其它变量进行重载。 <o:p></o:p></span></span></p>

<p style="text-indent: 21pt;"><code><span style="font-size: 10.5pt;">每次调用<span lang="EN-US">C编译器都用到变量CFLAGS</span></span></code><span lang="EN-US" style="font-size: 10.5pt;"> ，无论进行编译或连接都一样。 <o:p></o:p></span></p>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">任何<span lang="EN-US">Makefile文件都定义变量</span></span><code><span lang="EN-US" style="font-size: 10.5pt;">INSTALL</span></code><span style="font-size: 10.5pt;">，变量<span lang="EN-US">INSTALL是将文件安装到系统中的基本命令。
<o:p></o:p></span></span></p>

<p><span style="font-size: 10.5pt;">任何<span lang="EN-US">Makefile文件都定义变量</span></span><code><span lang="EN-US" style="font-size: 10.5pt;">INSTALL_PROGRAM</span></code><span lang="EN-US" style="font-size: 10.5pt;"> 和</span><code><span lang="EN-US" style="font-size: 10.5pt;">INSTALL_DATA</span></code><span style="font-size: 10.5pt;">，<span lang="EN-US">(它们的缺省值都是</span></span><code><span lang="EN-US" style="font-size: 10.5pt;">$(INSTALL)</span></code><span style="font-size: 10.5pt;">。<span lang="EN-US">) 在实际安装程序时，不论可执行程序或非可执行程序，一般都使用它们作为命令。下面是使用这些变量的例子：<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">$(INSTALL_PROGRAM) foo $(bindir)/foo<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">$(INSTALL_DATA) libfoo.a $(libdir)/libfoo.a<o:p></o:p></span></pre>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">您可以随意将变量<span lang="EN-US">DESTDIR预先设置为目标文件名。这样做允许安装程序创建随后在实际目标文件系统中安装文件的快照。不要再makefile文件中设置变量DESTDIR，也不要包含在安装文件中。用变量DERSTDIR改变上述例子：
<o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">$(INSTALL_PROGRAM) foo $(DESTDIR)$(bindir)/foo<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">$(INSTALL_DATA) libfoo.a $(DESTDIR)$(libdir)/libfoo.a<o:p></o:p></span></pre>

<p style="margin: 0cm 0cm 1e-04pt; text-indent: 21pt;"><span style="font-size: 10.5pt;">在安装命令中一般使用文件名而不是路径名作为第二个参数。对每一个安装文件都使用单独的命令。<span lang="EN-US"><o:p></o:p></span></span></p>

<h2><a name="_14.4_用于安装路径的变量"></a><span lang="EN-US" style="font-family: 宋体;">14.4安装路径变量<o:p></o:p></span></h2>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">安装目录经常以变量命名，所以在非标准地方安装也很容易，这些变量的标准名字将在下面介绍。安装目录依据标准文件系统布局，变量的变体已经在<span lang="EN-US">SVR4, 4.4BSD, Linux, Ultrix v4, 以及其它现代操作系统中使用。 <o:p></o:p></span></span></p>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">以下两个变量设置安装文件的根目录，所有的其它安装目录都是它们其中一个的子目录，没有任何文件可以直接安装在这两个根目录下。<span lang="EN-US"> <o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`prefix'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p style="margin-top: 0cm; margin-right: 0cm; margin-bottom: 1e-04pt; text-indent: 21pt;"><span style="font-size: 10.5pt;">前缀是用于构造以下列举变量的缺省值。变量<span lang="EN-US">prefix缺省值是</span></span><tt><span style="font-size: 10.5pt;">‘<span lang="EN-US">/usr/local'</span></span></tt><span style="font-size: 10.5pt;">。建造完整的<span lang="EN-US">GNU系统时，变量prefix的缺省值是空值，</span></span><tt><span style="font-size: 10.5pt;">‘<span lang="EN-US">/usr'</span></span></tt><span lang="EN-US" style="font-size: 10.5pt;"> 是符号连接符</span><tt><span style="font-size: 10.5pt;">‘<span lang="EN-US">/'</span></span></tt><span style="font-size: 10.5pt;">。<span lang="EN-US">(如果您使用Autoconf，应将它写为</span></span><samp><span style="font-size: 10.5pt;">‘<span lang="EN-US">@prefix@'</span></span></samp><span style="font-size: 10.5pt;">。<span lang="EN-US">)</span></span><samp><span style="font-size: 10.5pt;">使用</span></samp><span style="font-size: 10.5pt;">不同于创建程序时变量<span lang="EN-US">prefix的值运行</span></span><samp><span style="font-size: 10.5pt;">‘<span lang="EN-US">make
install'</span></span></samp><span style="font-size: 10.5pt;">，不会重新编译程序。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`exec_prefix'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">前缀是用于构造以下列举变量的缺省值。变量<span lang="EN-US">exec_prefix缺省值是</span></span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(prefix)</span></code><span lang="EN-US" style="font-family: 宋体;">. (如果您使用Autoconf，应将它写为</span><samp><span lang="EN-US" style="font-family: 宋体;">`@exec_prefix@'</span></samp><span style="font-family: 宋体;">。<span lang="EN-US">) 一般情况下。变量</span></span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(exec_prefix)</span></code><span lang="EN-US" style="font-family: 宋体;"> 用于存放包含机器特定文件的目录，（例如可执行文件和例程库），变量</span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(prefix)</span></code><span lang="EN-US" style="font-family: 宋体;"> 直接存放其它目录。</span><samp><span style="font-family: 宋体;">使用</span></samp><span style="font-family: 宋体;">不同于创建程序时变量<span lang="EN-US">exec_prefix的值运行</span></span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">make install'</span></span></samp><span style="font-family: 宋体;">，不会重新编译程序。<span lang="EN-US"><o:p></o:p></span></span></p>

<p style="margin: 0cm 0cm 1e-04pt; text-indent: 21pt;"><span style="font-size: 10.5pt;">可执行程序安装在以下目录中：<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`bindir'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">这个目录下用于安装用户可以运行的可执行程序。其正常的值是</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">/usr/local/bin'</span></span></tt><span style="font-family: 宋体;">，但是使用时应将它写为</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">$(exec_prefix)/bin'</span></span></tt><span style="font-family: 宋体;">。<span lang="EN-US"> (如果您使用Autoconf, 应将它写为</span></span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">@bindir@'</span></span></samp><span style="font-family: 宋体;">。<span lang="EN-US">) <o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`sbindir'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">这个目录下用于安装从<span lang="EN-US">shell中调用执行的可执行程序。它仅仅对系统管理员有作用。它的正常的值是</span></span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">/usr/local/sbin'</span></span></tt><span style="font-family: 宋体;">，但是使用时应将它写为</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">$(exec_prefix)/sbin'</span></span></tt><span style="font-family: 宋体;">。<span lang="EN-US"> (如果您使用Autoconf, 应将它写为</span></span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">@sbindir@'</span></span></samp><span style="font-family: 宋体;">。<span lang="EN-US">) <o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`libexecdir'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">这个目录下用于安装其它程序调用的可执行程序。其正常的值是</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">/usr/local/libexec'</span></span></tt><span style="font-family: 宋体;">，但是使用时应将它写为</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">$(exec_prefix)/libexec'</span></span></tt><span style="font-family: 宋体;">。<span lang="EN-US">(如果您使用Autoconf, 应将它写为</span></span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">@libexecdir@'。</span></span></samp><span lang="EN-US" style="font-family: 宋体;">) <o:p></o:p></span></p>

<p style="margin: 0cm 0cm 1e-04pt; text-indent: 21pt;"><span style="font-size: 10.5pt;">程序执行时使用的数据文件可分为两类：<span lang="EN-US"><o:p></o:p></span></span></p>

<ul style="margin-top: 0cm;" type="disc">
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">程序可以正常更改的文件和不能正常更改的文件（虽然用户可以编辑其中的一部分文件）。<span lang="EN-US"> <o:p></o:p></span></span></li>
 <li class="MsoNormal" style=""><span style="font-family: 宋体;">体系结构无关文件，指这些文件可被所有机器共享；体系相关文件，指仅仅可以被相同类型机器、操作系统共享的文件；其它是永远不能被两个机器共享的文件。<span lang="EN-US"><o:p></o:p></span></span></li>
</ul>

<p><span style="font-size: 10.5pt;">这可产生六种不同的可能性。我们极力反对使用体系相关的文件，当然<span lang="EN-US">OBJ文件和库文件除外。使用其它体系无关的数据文件更加简洁，并且，这样做也不是很难。<o:p></o:p></span></span></p>

<p><span style="font-size: 10.5pt;">所以，这里有<span lang="EN-US"> Makefile变量用于指定路径： <o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`datadir'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">这个目录下用于安装只读型体系无关数据文件。其正常的值是</span><tt><span style="font-family: 宋体;">‘<span lang="EN-US">/usr/local/share'，</span></span></tt><span style="font-family: 宋体;">但是使用时应将它写为</span><tt><span style="font-family: 宋体;">‘<span lang="EN-US">$(prefix)/share'</span></span></tt><span style="font-family: 宋体;">。<span lang="EN-US">(如果您使用Autoconf, 应将它写为</span></span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">@datadir@'</span></span></samp><span style="font-family: 宋体;">。<span lang="EN-US">) 作为例外，参阅下述的变量</span></span><tt><span style="font-family: 宋体;">‘<span lang="EN-US">$(infodir)'</span></span></tt><span style="font-family: 宋体;">和</span><tt><span style="font-family: 宋体;">‘<span lang="EN-US">$(includedir)'</span></span></tt><span style="font-family: 宋体;">。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`sysconfdir'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">这个目录下用于安装从属于单个机器的只读数据文件，这些文件是：用于配置主机的文件。邮件服务、网络配置文件，</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">/etc/passwd'</span></span></tt><span style="font-family: 宋体;">，等等都属于这里的文件。所有该目录下的文件都是平常的<span lang="EN-US">ASCII文本文件。其正常的值是</span></span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">/usr/local/etc'</span></span></tt><span lang="EN-US" style="font-family: 宋体;">, 但是使用时应将它写为</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">$(prefix)/etc'</span></span></tt><span lang="EN-US" style="font-family: 宋体;">. (如果您使用Autoconf, 应将它写为</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">@sysconfdir@'</span></span></samp><span lang="EN-US" style="font-family: 宋体;">.) 不要在这里安装可执行文件（它们可能属于</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">$(libexecdir)'</span></span></tt><span style="font-family: 宋体;">或</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">$(sbindir)'</span></span></tt><span style="font-family: 宋体;">）。也不要在这里安装那些在使用时要更改的文件（这些程序用于改变系统拒绝的配置）。它们可能属于</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">$(localstatedir)'</span></span></tt><span style="font-family: 宋体;">。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`sharedstatedir'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">这个目录下用于安装程序运行中要发生变化的体系无关数据文件。其正常的值是</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">/usr/local/com'</span></span></tt><span style="font-family: 宋体;">，但是使用时应将它写为</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">$(prefix)/com'</span></span></tt><span style="font-family: 宋体;">。<span lang="EN-US"> (如果您使用Autoconf, 应将它写为</span></span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">@sharedstatedir@'。</span></span></samp><span lang="EN-US" style="font-family: 宋体;">) <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`localstatedir'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">这个目录下用于安装程序运行中要发生变化的数据文件。但他们属于特定的机器。用户永远不需要在该目录下更改文件配置程序包选项；将这些配置信息放在分离的文件中，这些文件将放入</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">$(datadir)'</span></span></tt><span style="font-family: 宋体;">或</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">$(sysconfdir)'</span></span></tt><span style="font-family: 宋体;">中，</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">$(localstatedir)'</span></span></tt><span style="font-family: 宋体;">正常的值是</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">/usr/local/var'</span></span></tt><tt><span style="font-family: 宋体;">，</span></tt><span style="font-family: 宋体;">但是使用时应将它写为</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">$(prefix)/var'</span></span></tt><span style="font-family: 宋体;">。<span lang="EN-US"> (如果您使用Autoconf, 应将它写为</span></span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">@localstatedir@'。</span></span></samp><span lang="EN-US" style="font-family: 宋体;">) <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`libdir'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">这个目录下用于存放<span lang="EN-US">OBJ文件和库的OBJ代码。不要在这里安装可执行文件，它们可能应属于</span></span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">$(libexecdir)'</span></span></tt><span style="font-family: 宋体;">。变量</span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">libdir</span></code><span style="font-family: 宋体;">正常的值是</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">/usr/local/lib'</span></span></tt><span style="font-family: 宋体;">，但是使用时应将它写为</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">$(exec_prefix)/lib'</span></span></tt><span style="font-family: 宋体;">。<span lang="EN-US">(如果您使用Autoconf, 应将它写为 </span></span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">@libdir@'</span></span></samp><span style="font-family: 宋体;">。<span lang="EN-US">) <o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`infodir'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">这个目录下用于安装软件包的<span lang="EN-US"> Info 文件。缺省情况下其值是</span></span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">/usr/local/info'</span></span></tt><span style="font-family: 宋体;">，但是使用时应将它写为</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">$(prefix)/info'</span></span></tt><span lang="EN-US" style="font-family: 宋体;">. (如果您使用Autoconf, 应将它写为</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">@infodir@'</span></span></samp><span lang="EN-US" style="font-family: 宋体;">.) <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`lispdir'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">这个目录下用于安装软件包的<span lang="EN-US">Emacs Lisp 文件。缺省情况下其值是 </span></span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">/usr/local/share/emacs/site-lisp'</span></span></tt><span style="font-family: 宋体;">，但是使用时应将它写为</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">$(prefix)/share/emacs/site-lisp'</span></span></tt><span style="font-family: 宋体;">。如果您使用<span lang="EN-US">Autoconf, 应将它写为</span></span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">@lispdir@'</span></span></samp><span style="font-family: 宋体;">。为了保证</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">@lispdir@'</span></span></samp><span style="font-family: 宋体;">工作，您需要将以下几行加入到您的</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">configure.in'</span></span></tt><span style="font-family: 宋体;">文件中：<span lang="EN-US"> <o:p></o:p></span></span></p>

<pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">lispdir='${datadir}/emacs/site-lisp'<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">AC_SUBST(lispdir)<o:p></o:p></span></pre>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`includedir'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">这个目录下用于安装用户程序中<span lang="EN-US">C</span></span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">#include'</span></span></samp><span style="font-family: 宋体;">预处理指令包含的头文件。其正常的值是</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">/usr/local/include'</span></span></tt><span style="font-family: 宋体;">，但是使用时应将它写为</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">$(prefix)/include'</span></span></tt><span style="font-family: 宋体;">。<span lang="EN-US"> (如果您使用Autoconf, 应将它写为</span></span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">@includedir@'。</span></span></samp><span lang="EN-US" style="font-family: 宋体;">) 除GCC外的大多数编译器不在目录</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">/usr/local/include'</span></span></tt><span style="font-family: 宋体;">搜寻头文件，因此这种安装方式仅仅适用于<span lang="EN-US">GCC。有时，这也不是问题，因为一部分库文件仅仅依靠GCC才能工作。但也有一部分库文件依靠其他编译器，它们将它们的头文件安装到两个地方，一个由变量
</span></span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">includedir</span></code><span lang="EN-US" style="font-family: 宋体;"> 指定，另一个由变量</span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">oldincludedir</span></code><span style="font-family: 宋体;">指定。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`oldincludedir'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">这个目录下用于安装</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">#include'的头文件，这些头文件用于</span></span></samp><span style="font-family: 宋体;">除<span lang="EN-US">GCC外的其它C语言编译器。其正常的值是</span></span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">/usr/include'</span></span></tt><span style="font-family: 宋体;">。<span lang="EN-US">(如果您使用Autoconf, 应将它写为 </span></span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">@oldincludedir@'</span></span></samp><span style="font-family: 宋体;">。<span lang="EN-US">) Makefile命令变量</span></span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">oldincludedir</span></code><span lang="EN-US" style="font-family: 宋体;"> 的值是否为空，如果是空值，它们不在试图使用它，它们还删除第二次安装的头文件。一个软件包在该目录下替换已经存在的头文件，除非头文件来源于同一个软件包。例如，如果您的软件包Foo
提供一个头文件</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">foo.h'</span></span></tt><span style="font-family: 宋体;">，则它在变量</span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">oldincludedir</span></code><span style="font-family: 宋体;">指定的目录下安装的条件是<span lang="EN-US"> (1) 这里没有投文件</span></span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">foo.h'</span></span></tt><span lang="EN-US" style="font-family: 宋体;"> 或 (2) 来源于软件包Foo的头文件</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">foo.h'</span></span></tt><span style="font-family: 宋体;">已经在该目录下存在。要检查头文件</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">foo.h'</span></span></tt><span style="font-family: 宋体;">是否来自于软件包<span lang="EN-US">Foo，将一个magic字符串放到文件中--作为命令的一部分--然后使用正则规则（grep）查找该字符串。<o:p></o:p></span></span></p>

<p class="MsoNormal" style="margin-left: 18pt;"><span lang="EN-US" style="font-family: 宋体;">Unix风格的帮助文件安装在以下目录中：<o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`mandir'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">安装该软件包的顶层帮助（如果有）目录。其正常的值是</span><tt><span style="font-family: 宋体;">‘<span lang="EN-US">/usr/local/man'</span></span></tt><span style="font-family: 宋体;">，但是使用时应将它写为</span><tt><span style="font-family: 宋体;">‘<span lang="EN-US">$(prefix)/man'</span></span></tt><span style="font-family: 宋体;">。<span lang="EN-US"> (如果您使用Autoconf, 应将它写为</span></span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">@mandir@'。</span></span></samp><span lang="EN-US" style="font-family: 宋体;">) <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`man1dir'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">这个目录下用于安装第一层帮助。其正常的值是</span><tt><span style="font-family: 宋体;">‘<span lang="EN-US">$(mandir)/man1'</span></span></tt><span style="font-family: 宋体;">。<span lang="EN-US"> <o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`man2dir'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">这个目录下用于安装第一层帮助。其正常的值是</span><tt><span style="font-family: 宋体;">‘<span lang="EN-US">$(mandir)/man2'</span></span></tt><span style="font-family: 宋体;">。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`...'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><strong><span style="font-family: 宋体;">不要将任何<span lang="EN-US">GNU 软件的主要文档作为帮助页。应该编写使用手册。帮助页仅仅是为了人们在Unix上方便运行GNU软件，它是附属的运行程序。</span></span></strong><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`manext'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">文件名表示对已安装的帮助页的扩展。它包含一定的周期，后跟适当的数字，正常为‘<span lang="EN-US">1’。 <o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`man1ext'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">文件名表示对已安装的帮助页第一部分的扩展。<span lang="EN-US"> <o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`man2ext'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">文件名表示对已安装的帮助页第二部分的扩展。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`...'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">使用这些文件名代替</span><samp><span lang="EN-US" style="font-family: 宋体;">`manext'。如果该软件包的帮助页需要安装使用手册的多个章节。</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p><span style="font-size: 10.5pt;">最后您应该设置一下变量：<span lang="EN-US"> <o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`srcdir'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">这个目录下用于安装要编译的原文件。该变量正常的值由<span lang="EN-US">shell脚本</span></span><code><span lang="EN-US" style="font-family: 宋体;">configure</span></code><span style="font-family: 宋体;">插入。<span lang="EN-US">(如果您使用Autoconf, 应将它写为</span></span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">srcdir = @srcdir@'</span></span></samp><span lang="EN-US" style="font-family: 宋体;">.) <o:p></o:p></span></p>

<p><span style="font-size: 10.5pt;">例如：<span lang="EN-US"> <o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"># 用于安装路径的普通前缀。<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"># 注意：该路经在您开始安装时必须存在<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">prefix = /usr/local<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">exec_prefix = $(prefix)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"># 这里放置`gcc'命令调用的可执行文件。<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">bindir = $(exec_prefix)/bin<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"># 这里放置编译器使用的目录。<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">libexecdir = $(exec_prefix)/libexec<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">#这里放置Info文件。<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">infodir = $(prefix)/info<o:p></o:p></span></pre>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">如果您的程序要在标准用户指定的目录中安装大量的文件，将该程序的文件放入到特意指定的子目录中是很有必要的。如果您要这样做，您应该写安装规则创建这些子目录。<span lang="EN-US"> <o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">不要期望用户在上述列举的变量值中包括这些子目录，对于安装目录使用一套变量名的办法使用户能够对于不同的<span lang="EN-US">GNU软件包指定精确的值，为了使这种做法有用，所有的软件包必须设计为当用户使用时它们能够聪明的工作。<o:p></o:p></span></span></p>

<h2><a name="_14.5用户标准目标"></a><span lang="EN-US" style="font-family: 宋体;">14.5用户标准目标<o:p></o:p></span></h2>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">所有的<span lang="EN-US">GNU程序中，在makefile中都有下列目标：<o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`all'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">编译整个程序。这应该是缺省的目标。该目标不必重建文档文件，<span lang="EN-US">Info文件已正常情况下应该包括在各个发布的文件中，DVI文件只有在明确请求情况下才重建。缺省时，make规则编译和连接使用选项</span></span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">-g'</span></span></samp><span style="font-family: 宋体;">，所以程序调试只是象征性的。对于不介意缺少帮助的用户如果他们希望将可执行程序和帮助分开，可以从中剥离出可执行程序。<span lang="EN-US"> <o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`install'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">编译程序并将可执行程序、库文件等拷贝到为实际使用保留的文件名下。如果是证实程序是否适合安装的简单测试，则该目标应该运行该测试程序。不要在安装时剥离可执行程序，魔鬼很可能关心那些使用</span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">install-strip</span></code><span style="font-family: 宋体;">目标来剥离可执行程序的人。如果这是可行的，编写的</span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">install</span></code><span style="font-family: 宋体;">目标规则不应该更改程序建造的目录下的任何东西，仅仅提供</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">make all'</span></span></samp><span style="font-family: 宋体;">一切都能完成。这是为了方便用户命名和在其它系统安装建造程序，如果要安装程序的目录不存在，该命令应能创建所有这些目录，这包括变量<span lang="EN-US">prefix和exec_prefix特别指定的目录和所有必要的子目录。完成该任务的方法是借助下面描述的目标</span></span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">installdirs</span></code><span style="font-family: 宋体;">。在所有安装帮助页的命令前使用</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">-'使</span></span></samp><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">make</span></code><span lang="EN-US" style="font-family: 宋体;"> 能够忽略这些命令产生的错误，这可以确保在没有Unix帮助页的系统上安装该软件包时能够顺利进行。安装Info文件的方法是使用变量</span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(INSTALL_DATA)将</span></code><span lang="EN-US" style="font-family: 宋体;">Info文件拷贝到变量</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">$(infodir)'</span></span></tt><span style="font-family: 宋体;">中（参阅<b><i>指定命令的变量</i>），</b>如果 </span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">install-info</span></code><span style="font-family: 宋体;">程序存在则运行它。 </span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">install-info</span></code><span style="font-family: 宋体;">是一个编辑<span lang="EN-US">Info</span></span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">dir'</span></span></tt><span style="font-family: 宋体;">文件的程序，它可以为<span lang="EN-US">Info文件添加或更新菜单；它是Texinfo软件包的一部分。这里有一个安装Info文件的例子：
<o:p></o:p></span></span></p>

<pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">$(DESTDIR)$(infodir)/foo.info: foo.info<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(POST_INSTALL)<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;"># 可能在‘.’下有新的文件，在srcdir中没有。<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>-if test -f foo.info; then d=.; \<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>else d=$(srcdir); fi; \<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(INSTALL_DATA) $$d/foo.info $(DESTDIR)$@; \<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">#如果 </span><code><span lang="EN-US" style="font-family: 宋体;">install-info</span></code><span style="font-family: 宋体;">程序存在则运行它。<span lang="EN-US"><o:p></o:p></span></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;"># 使用‘if'代替在命令行前的‘-' <o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;"># 这样，我们可以注意到运行install-info产生的真正错误。<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;"># 我们使用‘$(SHELL) -c' 是因为在一些shell中<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;"># 遇到未知的命令不会运行失败。<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>if $(SHELL) -c 'install-info --version' \<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>&gt;/dev/null 2&gt;&amp;1; then \<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span><span style="">&#160;&#160;</span>install-info --dir-file=$(DESTDIR)$(infodir)/dir \<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(DESTDIR)$(infodir)/foo.info; \<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>else true; fi<o:p></o:p></span></pre>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">在编写</span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">install</span></code><span style="font-family: 宋体;">目标时，您必须把所有的命令归位三类：正常的命令、 安装前命令和安装后命令。参阅<b><i>安装命令分类</i></b>。<span lang="EN-US"> <o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`uninstall'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">删除所有安装的文件<span lang="EN-US">--有‘install’目标拷贝的文件。该规则不应更改编译产生的目录，仅仅删除安装文件的目录。反安装命令象安装命令一样分为三类，参阅<b><i>安装命令分类</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`install-strip'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">和目标</span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">install</span></code><span style="font-family: 宋体;">类似，但在安装时仅仅剥离出可执行文件。 在许多情况下，该目标的定义非常简单：<span lang="EN-US"><o:p></o:p></span></span></p>

<pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">install-strip:<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(MAKE) INSTALL_PROGRAM='$(INSTALL_PROGRAM) -s' \<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>install<o:p></o:p></span></pre>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">正常情况下我们不推荐剥离可执行程序进行安装，只有您确信这些程序不会产生问题时才能这样。剥离安装一个实际执行的可执行文件同时保存那些在这种场合存在<span lang="EN-US">BUG的可执行文件是显而易见的。<o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`clean'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">删除所有当前目录下的文件，这些文件正常情况下是那些‘建立程序’创建的文件。不要删除那些记录配置的文件，同时也应该保留那些‘建立程序’能够修改的文件，正常情况下要删除的那些文件不包括这些文件，因为发布文件是和这些文件一起创建的。如果</span><tt><span style="font-family: 宋体;">‘<span lang="EN-US">.dvi'文件不是文件发布文件的一部分，则使用目标‘clean’将同时</span></span></tt><span style="font-family: 宋体;">删除</span><tt><span style="font-family: 宋体;">‘<span lang="EN-US">.dvi'</span></span></tt><span style="font-family: 宋体;">文件。<span lang="EN-US"> <o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`distclean'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">删除所有当前目录下的文件，这些文件正常情况下是那些‘建立程序’或‘配置程序’创建的文件。如果您不解包源程序，‘建立程序’不会创建任何其它文件，</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">make distclean'</span></span></samp><span style="font-family: 宋体;">将仅在文件发布文件中留下原有的文件。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`mostlyclean'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">和目标</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">clean'</span></span></samp><span style="font-family: 宋体;">类似，但是避免删除人们正常情况下不编译的文件。例如，用于<span lang="EN-US">GCC的目标</span></span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">mostlyclean不删除文件</span></span></samp><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">libgcc.a'</span></span></tt><span style="font-family: 宋体;">，因为在绝大多数情况下它都不需要重新编译。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`maintainer-clean'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">几乎在当前目录下删除所有能够使用该<span lang="EN-US">makefile文件可以重建的文件。使用该目标删除的文件包括使用目标</span></span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">distclean</span></code><span lang="EN-US" style="font-family: 宋体;">,删除的文件加上从Bison产生的C语言源文件和标志列表、 Info文件等等。我们说“几乎所有文件”的原因是运行命令</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">make maintainer-clean'</span></span></samp><span style="font-family: 宋体;">不删除脚本</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">configure'，</span></span></tt><span style="font-family: 宋体;">即使脚本</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">configure'</span></span></tt><span style="font-family: 宋体;">可以使用<span lang="EN-US">Makefile文件创建。更确切地说，运行</span></span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">make maintainer-clean'</span></span></samp><span style="font-family: 宋体;">不删除为了运行脚本</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">configure'</span></span></tt><span style="font-family: 宋体;">以及开始建立程序的涉及的所有文件。这是运行</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">make maintainer-clean'</span></span></samp><span style="font-family: 宋体;">删除所有能够重新创建文件时唯一不能删除的一类文件。目标</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">maintainer-clean'</span></span></samp><span style="font-family: 宋体;">由该软件包的养护程序使用，不能被普通用户使用。您可以使用特殊的工具重建被目标</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">make maintainer-clean'</span></span></samp><span style="font-family: 宋体;">删除的文件。因为这些文件正常情况下包含在发布的文件中，我们并不关心它们是否容易重建。如果您发现您需要对全部发布的文件重新解包，您不能责怪我们。要帮助<span lang="EN-US">make 的用户意识到这一点，用于目标</span></span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">maintainer-clean</span></code><span lang="EN-US" style="font-family: 宋体;"> 应以以下两行为开始：<o:p></o:p></span></p>

<pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">@echo‘该命令仅仅用于养护程序；’<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">@echo‘它删除的所有文件都能使用特殊工具重建。’<o:p></o:p></span></pre>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`TAGS'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;</span>更新该程序的标志表。<o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`info'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">产生必要的<span lang="EN-US">Info文件。最好的方法是编写象下面规则： <o:p></o:p></span></span></p>

<pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">info: foo.info<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">foo.info: foo.texi chap1.texi chap2.texi<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(MAKEINFO) $(srcdir)/foo.texi<o:p></o:p></span></pre>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">您必须在<span lang="EN-US">makefile文件中定以变量</span></span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">MAKEINFO</span></code><span style="font-family: 宋体;">。它将运行</span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">makeinfo</span></code><span style="font-family: 宋体;">程序，该程序是发布程序中<span lang="EN-US">Texinfo的一部分。正常情况下，一个GNU发布程序和Info文件一起创建，这意味着Info文件存在于源文件的目录下。当用户建造一个软件包，一般情况下，make不更新Info文件，因为它们已经更新到最新了。
<o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`dvi'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">创建<span lang="EN-US">DVI文件用于更新Texinfo文档。例如：<o:p></o:p></span></span></p>

<pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">dvi: foo.dvi<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">foo.dvi: foo.texi chap1.texi chap2.texi<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(TEXI2DVI) $(srcdir)/foo.texi<o:p></o:p></span></pre>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">您必须在<span lang="EN-US">makefile文件中定义变量</span></span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">TEXI2DVI</span></code><span style="font-family: 宋体;">。它将运行程序</span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">texi2dvi</span></code><span style="font-family: 宋体;">，该程序是发布的<span lang="EN-US">Texinfo一部分。要么仅仅编写依靠文件，要么允许GNU make提供命令，二者必选其一。<o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`dist'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">为程序创建一个<span lang="EN-US">tar文件。创建tar文件可以将其中的文件名以子目录名开始，这些子目录名可以是用于发布的软件包名。另外，这些文件名中也可以包含版本号，例如，发布的GCC
1.40版的tar文件解包的子目录为</span></span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">gcc-1.40'</span></span></tt><span style="font-family: 宋体;">。最方便的方法是创建合适的子目录名，如使用<span lang="EN-US">in或cp等作为子目录，在它们的下面安装适当的文件，然后把tar文件解包到这些子目录中。使用gzip压缩这些tar文件，例如，实际的GCC
1.40版的发布文件叫</span></span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">gcc-1.40.tar.gz'</span></span></tt><span style="font-family: 宋体;">。目标</span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">dist</span></code><span style="font-family: 宋体;">明显的依靠所有的发布文件中不是源文件的文件，所以你应确保发布中的这些文件已经更新。参阅<b><i><span lang="EN-US">GNU标准编码</span></i></b>中<b><i>创建发布文件</i></b>。<span lang="EN-US"> <o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`check'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">执行自我检查。用户应该在运行测试之前，应该先建立程序，但不必安装这些程序；您应该编写一个自我测试程序，在程序已建立但没有安装时执行。<span lang="EN-US"> <o:p></o:p></span></span></p>

<p style="margin: 0cm 0cm 1e-04pt;">以下目标建议使用习惯名，对于各种程序它们很有用：<span lang="EN-US"> </span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">installcheck</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">执行自我检查。用户应该在运行测试之前，应该先建立、安装这些程序。您不因该假设</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">$(bindir)'</span></span></tt><span style="font-family: 宋体;">在搜寻路径中。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">installdirs</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">添加名为</span><samp><span style="font-family: 宋体;">‘<span lang="EN-US">installdirs'目标对于创建文件要安装的目录以及它们的父目录十分有用。</span></span></samp><span style="font-family: 宋体;">脚本</span><tt><span style="font-size: 10pt; font-family: 宋体;">‘<span lang="EN-US">mkinstalldirs'</span></span></tt><span style="font-family: 宋体;">是专为这样处理方便而编写的；您可以在<span lang="EN-US">Texinfo软件包中找到它，您可以象这样使用规则： <o:p></o:p></span></span></p>

<pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;"># 确保所有安装目录(例如 $(bindir))<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;"># 都实际存在，如果没有则创建它们。<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">installdirs: mkinstalldirs<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(srcdir)/mkinstalldirs $(bindir) $(datadir) \<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(libdir) $(infodir) \<o:p></o:p></span></pre><pre style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(mandir)<o:p></o:p></span></pre>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">该规则并不更改编译时创建的目录，它仅仅创建安装目录。<span lang="EN-US"> <o:p></o:p></span></span></p>

<h2><a name="_14.6_安装命令分类"></a><span lang="EN-US" style="font-family: 宋体;">14.6 安装命令分类<o:p></o:p></span></h2>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">编写已安装目标，您必须将所有命令分为三类：正常的命令、安装前命令和安装后命令。<span lang="EN-US"><o:p></o:p></span></span></p>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">正常情况下，命令把文件移动到合适的地方，并设置它们的模式。它们不会改变任何文件，仅仅把它们从软件包中完整地抽取出来。<span lang="EN-US"> <o:p></o:p></span></span></p>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">安装前命令和安装后命令可能更改一些文件，如，它们编辑配置文件后数据库文件。<span lang="EN-US"> <o:p></o:p></span></span></p>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">安装前命令在正常命令之前执行，安装后命令在正常命令执行后执行。</span><span lang="EN-US"> </span></p>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">安装后命令最普通的用途是运行</span><code><span lang="EN-US" style="font-size: 10.5pt;">install-info程序。</span></code><span style="font-size: 10.5pt;"> 这种工作不能由正常命令完成，因为它更改了一个文件（<span lang="EN-US">Info 目录），该文件不能全部、单独从软件包中安装。它是一个安装后命令，因为它需要在正常命令安装软件包中的Info文件后才能执行。 <o:p></o:p></span></span></p>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">许多程序不需要安装前命令，但是我们提供这个特点，以便在需要时可以使用。<span lang="EN-US"> <o:p></o:p></span></span></p>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">要将安装规则的命令分为这三类，应在命令中间插入<strong><span lang="EN-US">category lines（分类行）</span></strong>。 分类行指定了下面叙述的命令的类别。<span lang="EN-US"><o:p></o:p></span></span></p>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">分类行包含一个<span lang="EN-US">Tab、一个特殊的make变量引用，以及行结尾的随机注释。您可以使用三个变量，每一个变量对应一个类别；变量名指定了类别。分类行不能出现在普通的执行文件中，因为这些make变量被由正常的定义（您也不应在makefile文件中定义）。
<o:p></o:p></span></span></p>

<p><span style="font-size: 10.5pt;">这里有三种分类行，后面的注释解释了它的含义：<span lang="EN-US"><o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(PRE_INSTALL)<span style="">&#160;&#160;&#160;&#160; </span># 以下是安装前命令<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(POST_INSTALL)<span style="">&#160;&#160;&#160; </span># 以下是安装后命令<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(NORMAL_INSTALL)<span style="">&#160; </span># 以下是正常命令<o:p></o:p></span></pre>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">如果在安装规则开始您没有使用分类行，则在第一个分类行出现之前的所有命令都是正常命令。如果您没有使用任何分类行，则所有命令都是正常命令。<span lang="EN-US"><o:p></o:p></span></span></p>

<p><span style="font-size: 10.5pt;">这是反安装的分类行<span lang="EN-US"> <o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(PRE_UNINSTALL)<span style="">&#160;&#160;&#160;&#160; </span>#以下是反安装前命令<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(POST_UNINSTALL)<span style="">&#160;&#160;&#160; </span>#以下是反安装后命令<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(NORMAL_UNINSTALL)<span style="">&#160; </span>#以下是正常命令<o:p></o:p></span></pre>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">反安装前命令的典型用法是从<span lang="EN-US">Info目录删除全部内容。 <o:p></o:p></span></span></p>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">如果目标</span><code><span lang="EN-US" style="font-size: 10.5pt;">install</span></code><span style="font-size: 10.5pt;">或 </span><code><span lang="EN-US" style="font-size: 10.5pt;">uninstall</span></code><span lang="EN-US" style="font-size: 10.5pt;"> 有依赖作为安装程序的子程序，那么您应该使用分类行先启动每一个依赖的命令，再使用分类行启动主目标的命令。无论哪一个依赖实际执行，这种方式都能保证每一条命令都放置到了正确的分类中。
<o:p></o:p></span></p>

<p><span style="font-size: 10.5pt;">安装前命令和安装后命令除了对于下述命令外，不能运行其它程序：<span lang="EN-US"> <o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">basename bash cat chgrp chmod chown cmp cp dd diff echo<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">egrep expand expr false fgrep find getopt grep gunzip gzip<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">hostname install install-info kill ldconfig ln ls md5sum<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">mkdir mkfifo mknod mv printenv pwd rm rmdir sed sort tee<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">test touch true uname xargs yes<o:p></o:p></span></pre>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">按照这种方式区分命令的原因是为了创建二进制软件包。典型的二进制软件包包括所有可执行文件、必须安装的其它文件以及它自己的安装文件――所以二进制软件包不需要运行任何正常命令。但是安装二进制软件包需要执行安装前命令和安装后命令。<span lang="EN-US"> <o:p></o:p></span></span></p>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">建造二进制软件包的程序通过抽取安装前命令和安装后命令工作。这里有一个抽取安装前命令的方法：<span lang="EN-US"> <o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">make -n install -o all \<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160; </span>PRE_INSTALL=pre-install \<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160; </span>POST_INSTALL=post-install \<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160; </span>NORMAL_INSTALL=normal-install \<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;"><span style="">&#160; </span>| gawk -f pre-install.awk<o:p></o:p></span></pre>

<p><span style="font-size: 10.5pt;">这里文件</span><tt><span style="font-size: 10.5pt;">‘<span lang="EN-US">pre-install.awk'</span></span></tt><span style="font-size: 10.5pt;">可能包括：<span lang="EN-US"> <o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">$0 ~ /^\t[ \t]*(normal_install|post_install)[ \t]*$/ {on = 0}<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">on {print $0}<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">$0 ~ /^\t[ \t]*pre_install[ \t]*$/ {on = 1}<o:p></o:p></span></pre>

<p class="MsoNormal"><span style="font-family: 宋体;">安装前命令的结果文件是象安装二进制软件包的一部分<span lang="EN-US">shell脚本一样执行。<o:p></o:p></span></span></p>

<h1><a name="_15_快速参考"></a><span lang="EN-US" style="font-size: 18pt; font-family: 宋体;">15 快速参考<o:p></o:p></span></h1>

<p style="text-indent: 21pt;"><span style="font-size: 10.5pt;">这是对指令、文本操作函数以及<span lang="EN-US">GNU make能够理解的变量等的汇总。对于其他方面的总结参阅<b><i>特殊的内建目标名</i></b>，<b><i>隐含规则目录</i></b>，<b><i>选项概要</i></b>。
<o:p></o:p></span></span></p>

<p><span style="font-size: 10.5pt;">这里是<span lang="EN-US">GNU make是别的指令的总结：<o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">define </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">variable</span></var><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">endef</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">定义多行递归调用扩展型变量。参阅<b><i>定义固定次序的命令</i></b>。<span lang="EN-US"> <o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">ifdef </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">variable</span></var><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">ifndef </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">variable</span></var><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">ifeq (</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">a</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">,</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">b</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">ifeq "</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">a</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">" "</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">b</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">"</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">ifeq '</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">a</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">' '</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">b</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">'</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">ifneq (</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">a</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">,</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">b</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">ifneq "</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">a</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">" "</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">b</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">"</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">ifneq '</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">a</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">' '</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">b</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">'</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">else</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">endif</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">makefile文件中的条件扩展，参阅<b><i>makefile文件中的条件语句</i></b>。 <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">include </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">file</span></var><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">-include </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">file</span></var><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">sinclude </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">file</span></var><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">包含其它<span lang="EN-US">makefile文件，参阅<i>包含其它makefile文件</i>。 <o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">override </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">variable</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;"> = </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">value</span></var><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">override </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">variable</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;"> := </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">value</span></var><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">override </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">variable</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;"> += </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">value</span></var><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">override </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">variable</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;"> ?= </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">value</span></var><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">override define </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">variable</span></var><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">endef</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">定义变量、对以前的定义重载、以及对在命令行中定义的变量重载。参阅<b><i><span lang="EN-US">override指令</span></i></b>。<span lang="EN-US"> <o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">export</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">告诉<span lang="EN-US">make缺省向子过程输出所有变量，参阅<b><i>与子make通讯的变量</i></b>。 <o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">export </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">variable</span></var><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">export </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">variable</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;"> = </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">value</span></var><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">export </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">variable</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;"> := </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">value</span></var><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">export </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">variable</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;"> += </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">value</span></var><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">export </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">variable</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;"> ?= </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">value</span></var><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">unexport </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">variable</span></var><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">告诉<span lang="EN-US">make是否向子过程输出一个特殊的变量。参业<b><i>与子make通讯的变量</i></b>。 <o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">vpath </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">pattern</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;"> </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">path</span></var><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">制定搜寻匹配‘<span lang="EN-US">%’格式的文件的路径。参阅<b><i>vpath指令</i></b>。 <o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">vpath </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">pattern</span></var><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">去除以前为‘</span><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">pattern</span></var><span style="font-family: 宋体;">’指定的所有搜寻路径。<span lang="EN-US"> <o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">vpath</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">去除以前用<span lang="EN-US">vpath指令指定的所有搜寻路径。<o:p></o:p></span></span></p>

<p><span style="font-size: 10.5pt;">这里是操作文本函数的总结，参阅<b><i>文本转换函数</i></b>：<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(subst </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">from</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">,</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">to</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">,</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">text</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">在‘<span lang="EN-US">text’中用‘to’代替‘from’，参阅<b><i>字符串替换与分析函数</i></b>。 <o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(patsubst </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">pattern</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">,</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">replacement</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">,</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">text</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">在‘<span lang="EN-US">text’中用‘<var>replacement</var>’代替匹配‘<var>pattern</var>’字，参阅<b><i>字符串替换与分析函数</i></b>。
<o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(strip </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">string</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">从字符串中移去多余的空格。参阅<b><i>字符串替换与分析函数</i></b>。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(findstring </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">find</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">,</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">text</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">确定‘<var><span lang="EN-US">find</span></var>’在‘<var><span lang="EN-US">text</span></var>’中的位置。参阅<b><i>字符串替换与分析函数</i></b>。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(filter </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">pattern</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">...,</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">text</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">在‘<span lang="EN-US">text’中选择匹配‘<var>pattern</var>’的字。参阅<b><i>字符串替换与分析函数</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(filter-out </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">pattern</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">...,</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">text</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">在‘<span lang="EN-US">text’中选择不匹配‘<var>pattern</var>’的字。参阅<b><i>字符串替换与分析函数</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(sort </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">list</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">将‘<span lang="EN-US">list’中的字按字母顺序排序，并删除重复的字。参阅<b><i>字符串替换与分析函数</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(dir </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">names</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">...)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">从文件名中抽取路径名。参阅<b><i>文件名函数</i></b>。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(notdir </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">names</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">...)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">从文件名中抽取路径部分。参阅<b><i>文件名函数</i></b>。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(suffix </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">names</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">...)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">从文件名中抽取非路径部分。参阅<b><i>文件名函数</i></b>。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(basename </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">names</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">...)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">从文件名中抽取基本文件名。参阅<b><i>文件名函数</i></b>。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(addsuffix </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">suffix</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">,</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">names</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">...)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">为‘<span lang="EN-US">names’中的每个字添加后缀。参阅<b><i>文件名函数</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(addprefix </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">prefix</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">,</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">names</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">...)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">为‘<span lang="EN-US">names’中的每个字添加前缀。参阅<b><i>文件名函数</i></b>。 <o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(join </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">list1</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">,</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">list2</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">连接两个并行的字列表。参阅<b><i>文件名函数</i></b>。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(word </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">n</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">,</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">text</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">从‘<span lang="EN-US">text’中抽取第n个字。参阅<b><i>文件名函数</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(words </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">text</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">计算‘<span lang="EN-US">text’中字的数目。参阅<b><i>文件名函数</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(wordlist </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">s</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">,</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">e</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">,</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">text</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">返回‘<span lang="EN-US">text’中s到e之间的字。参阅<b><i>文件名函数</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(firstword </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">names</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">...)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">在‘<span lang="EN-US">names…’中的第一个字。参阅<b><i>文件名函数</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(wildcard </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">pattern</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">...)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">寻找匹配<span lang="EN-US">shell文件名格式的文件名。参阅<b><i>wildcard函数</i></b>。 <o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(error </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">text</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">...)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">该函数执行时，</span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">make</span></code><span style="font-family: 宋体;">产生信息为‘<span lang="EN-US">text’的致命错误。参阅<b><i>控制make的函数</i></b>。
<o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(warning </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">text</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">...)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">该函数执行时，</span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">make</span></code><span style="font-family: 宋体;">产生信息为‘<span lang="EN-US">text’的警告。参阅<b><i>控制make的函数</i></b>。
<o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(shell </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">command</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">执行<span lang="EN-US">shell命令并返回它的输出。参阅<b><i>函数shell</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(origin </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">variable</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">返回<span lang="EN-US">make变量‘<var>variable</var><var><span style="font-style: normal;">’的定义信息。参阅</span><b>函数origin</b></var><var><span style="font-style: normal;">。</span></var> <o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(foreach </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">var</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">,</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">words</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">,</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">text</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">将列表列表<span lang="EN-US">words中的每一个字对应后接var中的每一个字，将结果放在text中。参阅<b><i>函数foreach</i></b>。 <o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(call </span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">var</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">,</span></code><var><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">param</span></var><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">,...)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">使用对</span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(1)</span></code><span lang="EN-US" style="font-family: 宋体;">, </span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(2)...</span></code><span style="font-family: 宋体;">对变量计算变量 <var><span lang="EN-US">var</span></var><span lang="EN-US"> ，变量</span></span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(1)</span></code><span lang="EN-US" style="font-family: 宋体;">, </span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">$(2)...</span></code><span style="font-family: 宋体;">分别代替参数 <var><span lang="EN-US">param</span></var><span lang="EN-US"> 第一个、第二个…的值。参阅<b><i>函数call</i></b>。 <o:p></o:p></span></span></p>

<p><span style="font-size: 10.5pt;">这里是对自动变量的总结，完整的描述参阅<b><i>自动变量</i></b>。<span lang="EN-US"> <o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-family: 宋体;">$@</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">目标文件名。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-family: 宋体;">$%</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">当目标是档案成员时，表示目标成员名。<span lang="EN-US"> <o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-family: 宋体;">$&lt;</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">第一个依赖名。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-family: 宋体;">$?</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">所有比目标‘新’的依赖的名字，名字之间用空格隔开。对于为档案成员的依赖，只能使用命名的成员。参阅<b><i>使用<span lang="EN-US">make更新档案文件</span></i></b>。<span lang="EN-US"> <o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-family: 宋体;">$^</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-family: 宋体;">$+</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">所有依赖的名字，名字之间用空格隔开。对于为档案成员的依赖，只能使用命名的成员。参阅<b><i>使用<span lang="EN-US">make更新档案文件</span></i></b>。变量 </span><code><span lang="EN-US" style="font-family: 宋体;">$^</span></code><span lang="EN-US" style="font-family: 宋体;"> 省略了重复的依赖，而变量 </span><code><span lang="EN-US" style="font-family: 宋体;">$+</span></code><span lang="EN-US" style="font-family: 宋体;"> 则按照原来次序保留重复项，<o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-family: 宋体;">$*</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">和隐含规则匹配的<span lang="EN-US">stem(径)。参阅<b><i>格式匹配</i></b>。 <o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-family: 宋体;">$(@D)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-family: 宋体;">$(@F)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">变量</span><span lang="EN-US" style="font-family: 宋体;">$@</span><span lang="EN-US" style="font-family: 宋体;">.中的路径部分和文件名部分。<o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-family: 宋体;">$(*D)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-family: 宋体;">$(*F)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">变量</span><span lang="EN-US" style="font-family: 宋体;">$*</span><span style="font-family: 宋体;">中的路径部分和文件名部分。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-family: 宋体;">$(%D)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-family: 宋体;">$(%F)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">变量</span><span lang="EN-US" style="font-family: 宋体;">$%</span><span style="font-family: 宋体;">中的路径部分和文件名部分。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-family: 宋体;">$(&lt;D)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-family: 宋体;">$(&lt;F)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">变量</span><span lang="EN-US" style="font-family: 宋体;">$&lt;</span><span style="font-family: 宋体;">中的路径部分和文件名部分。<span lang="EN-US"> <o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-family: 宋体;">$(^D)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-family: 宋体;">$(^F)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">变量</span><span lang="EN-US" style="font-family: 宋体;">$^</span><span style="font-family: 宋体;">中的路径部分和文件名部分。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-family: 宋体;">$(+D)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-family: 宋体;">$(+F)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">变量</span><span lang="EN-US" style="font-family: 宋体;">$+</span><span style="font-family: 宋体;">中的路径部分和文件名部分。<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-family: 宋体;">$(?D)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-family: 宋体;">$(?F)</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">变量</span><span lang="EN-US" style="font-family: 宋体;">$?</span><span style="font-family: 宋体;">中的路径部分和文件名部分。<span lang="EN-US"><o:p></o:p></span></span></p>

<p><span style="font-size: 10.5pt;">以下是<span lang="EN-US">GNU </span></span><code><span lang="EN-US" style="font-size: 10.5pt;">make</span></code><span style="font-size: 10.5pt;">使用变量：<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-family: 宋体;">MAKEFILES</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">每次调用<span lang="EN-US">make要读入的Makefiles文件。参阅<b><i>变量MAKEFILES</i></b>。 <o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-family: 宋体;">VPATH</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">对在当前目录下不能找到的文件搜索的路径。参阅</span><code><b><i><span lang="EN-US" style="font-family: 宋体;">VPATH</span></i></b></code><b><i><span lang="EN-US" style="font-family: 宋体;">: 所有依赖的搜寻路径</span></i></b><b><span style="font-family: 宋体;">。</span></b><span lang="EN-US" style="font-family: 宋体;"><o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-family: 宋体;">SHELL</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">系统缺省命令解释程序名，通常是</span><tt><span lang="EN-US" style="font-family: 宋体;">`/bin/sh'</span></tt><span style="font-family: 宋体;">。您可以在<span lang="EN-US">makefile文件中设值变量</span></span><code><span lang="EN-US" style="font-family: 宋体;">SHELL</span></code><span style="font-family: 宋体;">改变运行程序使用的<span lang="EN-US">shell。参阅<b><i>执行命令</i></b>。 <o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-family: 宋体;">MAKESHELL</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">改变量仅用于<span lang="EN-US">MS-DOS，make使用的命令解释程序名，该变量的值比变量SHELL的值优先。参阅<b><i>执行命令</i></b>。<o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-family: 宋体;">MAKE</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">调用的<span lang="EN-US">make名。在命令行中使用该变量有特殊的意义。参阅变量MAKE的工作方式。 <o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-family: 宋体;">MAKELEVEL</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">递归调用的层数<span lang="EN-US">(子</span></span><code><span lang="EN-US" style="font-family: 宋体;">make</span></code><span lang="EN-US" style="font-family: 宋体;">s)。参阅<b><i>与子make通讯的变量</i></b>。 <o:p></o:p></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-family: 宋体;">MAKEFLAGS</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">向<span lang="EN-US">make提供标志。您可以在环境或makefile文件中使用该变量设置标志。参阅<b><i>与子make通讯的变量</i></b>。在命令行中不能直接使用该变量，应为它的内容不能在shell中正确引用，但总是允许递归调用make时通过环境传递给子make。<o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-family: 宋体;">MAKECMDGOALS</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">该目标是在命令行中提供给<span lang="EN-US">make的。设置该变量对make的行为没有任何影响。参阅<b><i>特别目标的参数</i></b>。 <o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-family: 宋体;">CURDIR</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">设置当前工作目录的路径名，参阅<b><i>递归调用<span lang="EN-US">make</span></i></b>。<span lang="EN-US"> <o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-family: 宋体;">SUFFIXES</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">在读入任何<span lang="EN-US">makefile文件之前的后缀列表。 <o:p></o:p></span></span></p>

<p class="MsoNormal"><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">.LIBPATTERNS</span></code><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">定义<span lang="EN-US">make搜寻的库文件名，以及搜寻次序。参阅<b><i>连接库搜寻目录</i></b>。 <o:p></o:p></span></span></p>

<h1><a name="_16_make产生的错误"></a><span lang="EN-US" style="font-size: 18pt; font-family: 宋体;">16 make产生的错误<o:p></o:p></span></h1>

<p style="margin: 0cm 0cm 1e-04pt; text-indent: 21pt;"><span style="font-size: 10.5pt;">这里是您可以看到的由<span lang="EN-US">make产生绝大多数普通错误列表，以及它们的含义和修正它们信息。 <o:p></o:p></span></span></p>

<p style="margin: 0cm 0cm 1e-04pt; text-indent: 21pt;"><span style="font-size: 10.5pt;">有时<span lang="EN-US">make产生的错误不是致命的，如一般在命令脚本行前面存在前缀的情况下，和在命令行使用选向‘-k’的情况下产生的错误几乎都不是致命错误。使用字符串***作前缀将产生致命的错误。
<o:p></o:p></span></span></p>

<p style="margin: 0cm 0cm 1e-04pt; text-indent: 21pt;"><span style="font-size: 10.5pt;">错误信息前面都使用前缀，前缀的内容是产生错误的程序名或<span lang="EN-US">makefile文件中存在错误的文件名和包含该错误的行的行号和。
<o:p></o:p></span></span></p>

<p class="MsoNormal" style="text-indent: 21pt;"><span style="font-family: 宋体;">在下述的错误列表中，省略了普通的前缀：<span lang="EN-US"><o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`[</span></samp><var><span lang="EN-US" style="font-family: 宋体;">foo</span></var><samp><span lang="EN-US" style="font-family: 宋体;">] Error </span></samp><var><span lang="EN-US" style="font-family: 宋体;">NN</span></var><samp><span lang="EN-US" style="font-family: 宋体;">'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`[</span></samp><var><span lang="EN-US" style="font-family: 宋体;">foo</span></var><samp><span lang="EN-US" style="font-family: 宋体;">] </span></samp><var><span lang="EN-US" style="font-family: 宋体;">signal description</span></var><samp><span lang="EN-US" style="font-family: 宋体;">'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">这些错误并不是真的<span lang="EN-US">make的错误。它们意味着make调用的程序返回非零状态值，错误码（</span></span><samp><span lang="EN-US" style="font-family: 宋体;">Error </span></samp><var><span lang="EN-US" style="font-family: 宋体;">NN</span></var><span style="font-family: 宋体;">），这种情况<span lang="EN-US">make解释为失败，或非正常方式退出（一些类型信号），参阅<b><i>命令错误</i></b>。
如果信息中没有附加***，则是子过程失败，但在makefile文件中的这条规则有特殊前缀，因此make忽略该错误。 <o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`missing
separator. Stop.'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`missing
separator (did you mean TAB instead of 8 spaces?). Stop.'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">这意味着<span lang="EN-US">make在读取命令行时遇到不能理解的内容。GNU </span></span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">make</span></code><span lang="EN-US" style="font-family: 宋体;"> 检查各种分隔符(</span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">:</span></code><span lang="EN-US" style="font-family: 宋体;">,
</span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">=</span></code><span lang="EN-US" style="font-family: 宋体;">,
字符TAB，等)
从而帮助确定它在命令行中遇到了什么类型的错误。这意味着，make不能发现一个合法的分隔符。出现该信息的最可能的原因是您（或许您的编辑器，绝大部分是ms-windows的编辑器）在命令行缩进使用了空格代替了字符Tab。这种情况下，make将使用上述的第二种形式产生错误信息。<b>一定切记，任何命令行都以字符Tab开始，八个空格也不算数</b>。参阅<b><i>规则的语法</i></b>。
<o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`commands commence
before first target. Stop.'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`missing rule
before commands. Stop.'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">这意味着在<span lang="EN-US">makefile中似乎以命令行开始：以Tab字符开始，但不是一个合法的命令行（例如，一个变量的赋值）。任何命令行必须和一定的目标相联系。产生第二种的错误信息是一行的第一个非空白字符为分号，make对此的解释是您遗漏了规则中的"target:
prerequisite" 部分，参阅<b><i>规则的语法</i>。</b><o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`No rule to
make target `</span></samp><var><span lang="EN-US" style="font-family: 宋体;">xxx</span></var><samp><span lang="EN-US" style="font-family: 宋体;">'.'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`No rule to
make target `</span></samp><var><span lang="EN-US" style="font-family: 宋体;">xxx</span></var><samp><span lang="EN-US" style="font-family: 宋体;">', needed by `</span></samp><var><span lang="EN-US" style="font-family: 宋体;">yyy</span></var><samp><span lang="EN-US" style="font-family: 宋体;">'.'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">这意味着<span lang="EN-US">make决定必须建立一个目标，但却不能在makefile文件中发现任何用于创建该目标的指令，包括具体规则和隐含规则。如果您希望创建该目标，您需要另外为改目标编写规则。其它关于该问题产生原因可能是makefile文件是草稿（如文件名错）或破坏了源文件树（一个文件不能按照计划重建，仅仅由于一个依赖的问题）。<o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`No targets
specified and no makefile found. Stop.'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`No targets.
Stop.'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">前者意味着您没有为命令行提供要创建的目标，<span lang="EN-US">make不能读入任何makefile文件。后者意味着一些makefile文件被找到，但没有包含缺省目标以及命令行等。GNU make在这种情况下无事可做。参阅<b><i>指定makefile文件的参数</i></b>。
<o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`Makefile `</span></samp><var><span lang="EN-US" style="font-family: 宋体;">xxx</span></var><samp><span lang="EN-US" style="font-family: 宋体;">' was not found.'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`Included
makefile `</span></samp><var><span lang="EN-US" style="font-family: 宋体;">xxx</span></var><samp><span lang="EN-US" style="font-family: 宋体;">'
was not found.'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">在命令行中指定一个<span lang="EN-US">makefile文件（前者）或包含的makefile 文件（后者）没有找到。 <o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`warning:
overriding commands for target `</span></samp><var><span lang="EN-US" style="font-family: 宋体;">xxx</span></var><samp><span lang="EN-US" style="font-family: 宋体;">''</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`warning:
ignoring old commands for target `</span></samp><var><span lang="EN-US" style="font-family: 宋体;">xxx</span></var><samp><span lang="EN-US" style="font-family: 宋体;">''</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span lang="EN-US" style="font-family: 宋体;">GNU </span><code><span lang="EN-US" style="font-size: 10pt; font-family: 宋体;">make</span></code><span style="font-family: 宋体;">允许命令在一个规则中只能对一个命令使用一次<span lang="EN-US">(双冒号规则除外)。如果您为一个目标指定一个命令，而该命令在目标定义是已经定义过，这种警告就会产生；第二个信息表明后来设置的命令将改写以前对该命令的设置。参阅<b><i>具有多条规则的目标</i></b>。
<o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`Circular </span></samp><var><span lang="EN-US" style="font-family: 宋体;">xxx</span></var><samp><span lang="EN-US" style="font-family: 宋体;"> &lt;- </span></samp><var><span lang="EN-US" style="font-family: 宋体;">yyy</span></var><samp><span lang="EN-US" style="font-family: 宋体;"> dependency dropped.'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">这意味着<span lang="EN-US">make检测到一个相互依靠一个循环：在跟踪目标xxx的依赖yyy 时发现，依赖yyy的依赖中一个又以xxx为依赖。<o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`Recursive
variable `</span></samp><var><span lang="EN-US" style="font-family: 宋体;">xxx</span></var><samp><span lang="EN-US" style="font-family: 宋体;">'
references itself (eventually). Stop.'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">这意味着您定义一个正常（递归调用性）<span lang="EN-US">make变量xxx，当它扩展时，它将引用它自身。无论对于简单扩展型变量(:=)或追加定义（+=），这也都是不能允许的，参阅<b><i>使用变量</i></b>。
<o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`Unterminated
variable reference. Stop.'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">这意味着您在变量引用或函数调用时忘记写右括号。<span lang="EN-US"> <o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`insufficient
arguments to function `</span></samp><var><span lang="EN-US" style="font-family: 宋体;">xxx</span></var><samp><span lang="EN-US" style="font-family: 宋体;">'. Stop.'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">这意味着您在调用函数是您密友提供需要数目的参数。关于函数参数的详细描述参阅<b><i>文本转换函数</i></b>。<span lang="EN-US"> <o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`missing
target pattern. Stop.'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`multiple
target patterns. Stop.'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`target
pattern contains no `%'. Stop.'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">这些错误信息是畸形的静态格式规则引起的。第一条意味着在规则的目标部分没有规则，第二条意味着在目标部分有多个规则，第三条意味着没有包含格式符<span lang="EN-US">%。参阅<b><i>静态格式规则语法</i></b>。 <o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`warning: -jN
forced in submake: disabling jobserver mode.'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">该条警告和下条警告是在<span lang="EN-US">make检测到在能与子make通讯的系统中包含并行处理的错误（参阅<b><i>与子make通讯选项</i></b>）。该警告信息是如果递归调用一个make过程，而且还使用了‘-jn’选项（这里n大于1）。这种情况很可能发生，例如，如果您设置环境变量MAKE为‘make
Cj2’。这种情况下，子make不能与其它make过程通讯， 而且还简单假装它由两个任务。 <o:p></o:p></span></span></p>

<p class="MsoNormal"><samp><span lang="EN-US" style="font-family: 宋体;">`warning:
jobserver unavailable: using -j1. Add `+' to parent make rule.'</span></samp><span lang="EN-US" style="font-family: 宋体;"> <o:p></o:p></span></p>

<p class="MsoNormal" style="margin-left: 36pt;"><span style="font-family: 宋体;">为了保证<span lang="EN-US">make过程之间通讯，父层make将传递信息给子make。这可能导致问题，因为子过程有可能不是实际的一个make，而父过程仅仅认为子过程是一个make而将所有信息传递给子过程。父过程是采用正常的算法决定这些的（参阅<b><i>变量MAKE的工作方式</i></b>）。如果makefile文件构建了这样的父过程，它并不知道子过程是否为make，那么，子过程将拒收那些没有用的信息。这种情况下，子过程就会产生该警告信息，然后按照它内建的次序方式进行处理。
<o:p></o:p></span></span></p>

<h1 style="margin: 0cm 0cm 1e-04pt;"><a name="_17_复杂的makfile文件例子"></a><span lang="EN-US" style="font-size: 18pt; font-family: 宋体;">17
复杂的makfile文件例子<o:p></o:p></span></h1>

<p style="margin: 0cm 0cm 1e-04pt; text-indent: 21pt;"><span style="font-size: 10.5pt;">这是一个用于<span lang="EN-US">GNU tar程序的makefile文件；这是一个中等复杂的makefile文件。 <o:p></o:p></span></span></p>

<p style="margin: 0cm 0cm 1e-04pt; text-indent: 21pt;"><span style="font-size: 10.5pt;">因为‘<span lang="EN-US">all’是第一个目标，所以它是缺省目标。该makefile文件一个有趣的地方是</span></span><tt><span style="font-size: 10.5pt;">‘<span lang="EN-US">testpad.h'</span></span></tt><span style="font-size: 10.5pt;">是由</span><code><span lang="EN-US" style="font-size: 10.5pt;">testpad</span></code><span style="font-size: 10.5pt;">程序创建的源文件，而且该程序自身由</span><tt><span style="font-size: 10.5pt;">‘<span lang="EN-US">testpad.c'</span></span></tt><span style="font-size: 10.5pt;">编译得到的。<span lang="EN-US"> <o:p></o:p></span></span></p>

<p style="margin: 0cm 0cm 1e-04pt; text-indent: 21pt;"><span style="font-size: 10.5pt;">如果您键入</span><samp><span style="font-size: 10.5pt;">‘<span lang="EN-US">make'</span></span></samp><span style="font-size: 10.5pt;">或</span><samp><span lang="EN-US" style="font-size: 10.5pt;">`make all'</span></samp><span style="font-size: 10.5pt;">，则<span lang="EN-US">make创建名为</span></span><tt><span style="font-size: 10.5pt;">‘<span lang="EN-US">tar'</span></span></tt><span style="font-size: 10.5pt;">可执行文件<span lang="EN-US">, 提供远程访问磁带的进程</span></span><tt><span style="font-size: 10.5pt;">‘<span lang="EN-US">rmt'</span></span></tt><span style="font-size: 10.5pt;">，和名为</span><tt><span style="font-size: 10.5pt;">‘<span lang="EN-US">tar.info'的</span></span></tt><span lang="EN-US" style="font-size: 10.5pt;">Info文件。 <o:p></o:p></span></p>

<p style="margin: 0cm 0cm 1e-04pt; text-indent: 21pt;"><span style="font-size: 10.5pt;">如果您键入</span><samp><span style="font-size: 10.5pt;">‘<span lang="EN-US">make install'</span></span></samp><span style="font-size: 10.5pt;">，则<span lang="EN-US">make不但创建</span></span><tt><span style="font-size: 10.5pt;">‘<span lang="EN-US">tar'</span></span></tt><span lang="EN-US" style="font-size: 10.5pt;">,</span><tt><span style="font-size: 10.5pt;">‘<span lang="EN-US">rmt'</span></span></tt><span lang="EN-US" style="font-size: 10.5pt;">,和‘</span><tt><span lang="EN-US" style="font-size: 10.5pt;">tar.info'</span></tt><span style="font-size: 10.5pt;">，而且安装它们。<span lang="EN-US"> <o:p></o:p></span></span></p>

<p style="margin: 0cm 0cm 1e-04pt; text-indent: 21pt;"><span style="font-size: 10.5pt;">如果您键入</span><samp><span style="font-size: 10.5pt;">‘<span lang="EN-US">make clean'</span></span></samp><span lang="EN-US" style="font-size: 10.5pt;">, 则make删除所有</span><samp><span style="font-size: 10.5pt;">‘<span lang="EN-US">.o'</span></span></samp><span style="font-size: 10.5pt;">文件，以及</span><tt><span style="font-size: 10.5pt;">‘<span lang="EN-US">tar'</span></span></tt><span lang="EN-US" style="font-size: 10.5pt;">,</span><tt><span style="font-size: 10.5pt;">‘<span lang="EN-US">rmt'</span></span></tt><span lang="EN-US" style="font-size: 10.5pt;">,</span><tt><span style="font-size: 10.5pt;">‘<span lang="EN-US">testpad'</span></span></tt><span lang="EN-US" style="font-size: 10.5pt;">, </span><tt><span style="font-size: 10.5pt;">‘<span lang="EN-US">testpad.h'</span></span></tt><span lang="EN-US" style="font-size: 10.5pt;">,和</span><tt><span style="font-size: 10.5pt;">‘<span lang="EN-US">core’文件。</span></span></tt><span lang="EN-US" style="font-size: 10.5pt;"> <o:p></o:p></span></p>

<p style="margin: 0cm 0cm 1e-04pt; text-indent: 21pt;"><span style="font-size: 10.5pt;">如果您键入</span><samp><span style="font-size: 10.5pt;">‘<span lang="EN-US">make distclean'</span></span></samp><span lang="EN-US" style="font-size: 10.5pt;">, 则make不仅删除</span><samp><span style="font-size: 10.5pt;">‘<span lang="EN-US">make
clean'删除的所有文件，而且包括文件</span></span></samp><tt><span style="font-size: 10.5pt;">‘<span lang="EN-US">TAGS'</span></span></tt><span lang="EN-US" style="font-size: 10.5pt;">, </span><tt><span style="font-size: 10.5pt;">‘<span lang="EN-US">Makefile'</span></span></tt><span lang="EN-US" style="font-size: 10.5pt;">, 和‘</span><tt><span lang="EN-US" style="font-size: 10.5pt;">config.status'</span></tt><span lang="EN-US" style="font-size: 10.5pt;"> 文件。(虽然不明显，但该
makefile (和</span><tt><span style="font-size: 10.5pt;">‘<span lang="EN-US">config.status'</span></span></tt><span lang="EN-US" style="font-size: 10.5pt;">)是用户用</span><code><span lang="EN-US" style="font-size: 10.5pt;">configure</span></code><span style="font-size: 10.5pt;">程序产生的，该程序是由发布的</span><code><span lang="EN-US" style="font-size: 10.5pt;">tar</span></code><span style="font-size: 10.5pt;">文件提供，但这里不进行说明。<span lang="EN-US">) <o:p></o:p></span></span></p>

<p style="margin: 0cm 0cm 1e-04pt; text-indent: 21pt;"><span style="font-size: 10.5pt;">如果您键入</span><samp><span style="font-size: 10.5pt;">‘<span lang="EN-US">make realclean'</span></span></samp><span lang="EN-US" style="font-size: 10.5pt;">, 则make删除</span><samp><span style="font-size: 10.5pt;">‘<span lang="EN-US">make
distclean '删除的所有文件，而且包括由</span></span></samp><tt><span style="font-size: 10.5pt;">‘<span lang="EN-US">tar.texinfo'产生的</span></span></tt><span lang="EN-US" style="font-size: 10.5pt;">Info文件。<o:p></o:p></span></p>

<p style="margin: 0cm 0cm 1e-04pt;"><span style="font-size: 10.5pt;">另外，目标</span><code><span lang="EN-US" style="font-size: 10.5pt;">shar</span></code><span style="font-size: 10.5pt;">和</span><code><span lang="EN-US" style="font-size: 10.5pt;">dist</span></code><span style="font-size: 10.5pt;">创造了发布文件的核心。<span lang="EN-US"> <o:p></o:p></span></span></p>

<pre><span lang="EN-US" style="font-family: 宋体;"># 自动从makefile.in产生<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"># 用于GNU tar 程序的Unix Makefile <o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"># Copyright (C) 1991 Free Software Foundation, Inc.<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"># 本程序是自由软件；在遵照GNU条款的情况下<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"># 您可以重新发布它或更改它<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"># 普通公众许可证 ...<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">...<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">...<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">SHELL = /bin/sh<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">#### 启动系统配置部分 ####<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">srcdir = .<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"># 如果您使用gcc, 您应该在运行<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"># 和它一起创建的固定包含的脚本程序以及 <o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"># 使用-traditional选项运行gcc中间选择其一。<span style="">&#160; </span><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"># 另外的ioctl调用在一些系统上不能正确编译<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">CC = gcc -O<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">YACC = bison -y<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">INSTALL = /usr/local/bin/install -c<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">INSTALLDATA = /usr/local/bin/install -c -m 644<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"># 您应该在DEFS中添加的内容：<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"># -DSTDC_HEADERS<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>如果您有标准C的头文件和<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">#<span style="">&#160;&#160;&#160;&#160;&#160;&#160; </span><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span>库文件。<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"># -DPOSIX<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>如果您有POSIX.1的头文件和<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">#<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>库文件。<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"># -DBSD42<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>如果您有sys/dir.h (除非<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">#<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>您使用-DPOSIX), sys/file.h,<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">#<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>和st_blocks在`struct stat'中。<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"># -DUSG<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span><span style="">&#160;</span>如果您有System V/ANSI C<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">#<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span><span style="">&#160;</span><span style="">&#160;</span>字符串和内存控制函数<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">#<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>和头文件， sys/sysmacros.h,<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">#<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>fcntl.h, getcwd, no valloc,<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">#<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>和 ndir.h (除非<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">#<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>您使用-DDIRENT)。<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"># -DNO_MEMORY_H<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>如果USG或STDC_HEADERS 但是不<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">#<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>包括memory.h.<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"># -DDIRENT<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>如果USG而且您又用dirent.h<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">#<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span><span style="">&#160;</span>代替ndir.h。<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"># -DSIGTYPE=int<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>如果您的信号控制器<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">#<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>返回int,非void.<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"># -DNO_MTIO<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span><span style="">&#160;</span>如果您缺少sys/mtio.h<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">#<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span>(magtape ioctls).<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"># -DNO_REMOTE<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>如果您没有一个远程shell<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">#<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>或rexec.<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"># -DUSE_REXEC<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>对远程磁带使用rexec<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">#<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>操作代替<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">#<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span><span style="">&#160;</span>分支rsh或remsh.<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"># -DVPRINTF_MISSING<span style="">&#160;&#160;&#160;&#160; </span>如果您缺少函数vprintf<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">#<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span>(但是有_doprnt).<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"># -DDOPRNT_MISSING<span style="">&#160;&#160;&#160;&#160;&#160; </span>如果您缺少函数 _doprnt.<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">#<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>同样需要定义<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">#<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>-DVPRINTF_MISSING.<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"># -DFTIME_MISSING<span style="">&#160;&#160;&#160;&#160;&#160;&#160; </span>如果您缺少系统调用ftime<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"># -DSTRSTR_MISSING<span style="">&#160;&#160;&#160;&#160;&#160; </span>如果您缺少函数strstr。<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"># -DVALLOC_MISSING<span style="">&#160;&#160;&#160;&#160;&#160; </span>如果您缺少函数valloc。<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"># -DMKDIR_MISSING<span style="">&#160;&#160;&#160;&#160;&#160;&#160; </span>如果您缺少系统调用mkdir和<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">#<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>rmdir。<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"># -DRENAME_MISSING<span style="">&#160;&#160;&#160;&#160;&#160; </span>如果您缺少系统调用rename。<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"># -DFTRUNCATE_MISSING<span style="">&#160;&#160; </span>如果您缺少系统调用ftruncate。<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">#<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"># -DV7<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>在Unix版本7 (没有<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">#<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>进行长期测试).<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"># -DEMUL_OPEN3<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>如果您缺少3-参数版本<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">#<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>的open, 并想通过您有的系统调用<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">#<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span><span style="">&#160;</span>仿真它。<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"># -DNO_OPEN3<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>如果您缺少3-参数版本的open<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">#<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>并要禁止tar Ck选项<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">#<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>代替仿真open.<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"># -DXENIX<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>如果您有sys/inode.h<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">#<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>并需要它包含94<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">DEFS =<span style="">&#160; </span>-DSIGTYPE=int -DDIRENT -DSTRSTR_MISSING \<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>-DVPRINTF_MISSING -DBSD42<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"># 设置为rtapelib.o ，除非使它为空时<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"># 您定义了NO_REMOTE,<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">RTAPELIB = rtapelib.o<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">LIBS =<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">DEF_AR_FILE = /dev/rmt8<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">DEFBLOCKING = 20<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">CDEBUG = -g<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">CFLAGS = $(CDEBUG) -I. -I$(srcdir) $(DEFS) \<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>-DDEF_AR_FILE=\"$(DEF_AR_FILE)\" \<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>-DDEFBLOCKING=$(DEFBLOCKING)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">LDFLAGS = -g<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">prefix = /usr/local<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"># 每一个安装程序的前缀。<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">#正常为空或`g'。<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">binprefix =<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"># 安装tar的路径<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">bindir = $(prefix)/bin<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"># 安装info文件的路径.<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">infodir = $(prefix)/info<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">#### 系统配置结束部分 ####<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">SRC1 =<span style="">&#160; </span>tar.c create.c extract.c buffer.c \<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>getoldopt.c update.c gnu.c mangle.c<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">SRC2 =<span style="">&#160; </span>version.c list.c names.c diffarch.c \<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>port.c wildmat.c getopt.c<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">SRC3 =<span style="">&#160; </span>getopt1.c regex.c getdate.y<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">SRCS =<span style="">&#160; </span>$(SRC1) $(SRC2) $(SRC3)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">OBJ1 =<span style="">&#160; </span>tar.o create.o extract.o buffer.o \<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>getoldopt.o update.o gnu.o mangle.o<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">OBJ2 =<span style="">&#160; </span>version.o list.o names.o diffarch.o \<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>port.o wildmat.o getopt.o<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">OBJ3 =<span style="">&#160; </span>getopt1.o regex.o getdate.o $(RTAPELIB)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">OBJS =<span style="">&#160; </span>$(OBJ1) $(OBJ2) $(OBJ3)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">AUX =<span style="">&#160;&#160; </span>README COPYING ChangeLog Makefile.in<span style="">&#160; </span>\<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>makefile.pc configure configure.in \<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>tar.texinfo tar.info* texinfo.tex \<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>tar.h port.h open3.h getopt.h regex.h \<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>rmt.h rmt.c rtapelib.c alloca.c \<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>msd_dir.h msd_dir.c tcexparg.c \<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>level-0 level-1 backup-specs testpad.c<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">all:<span style="">&#160;&#160;&#160; </span>tar rmt tar.info<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">tar:<span style="">&#160;&#160;&#160; </span>$(OBJS)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(CC) $(LDFLAGS) -o $@ $(OBJS) $(LIBS)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">rmt:<span style="">&#160;&#160;&#160; </span>rmt.c<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(CC) $(CFLAGS) $(LDFLAGS) -o $@ rmt.c<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">tar.info: tar.texinfo<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>makeinfo tar.texinfo<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">install: all<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(INSTALL) tar $(bindir)/$(binprefix)tar<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>-test ! -f rmt || $(INSTALL) rmt /etc/rmt<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(INSTALLDATA) $(srcdir)/tar.info* $(infodir)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">$(OBJS): tar.h port.h testpad.h<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">regex.o buffer.o tar.o: regex.h<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"># getdate.y 有8个变换/减少冲突。<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">testpad.h: testpad<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>./testpad<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">testpad: testpad.o<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>$(CC) -o $@ testpad.o<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">TAGS:<span style="">&#160;&#160; </span>$(SRCS)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>etags $(SRCS)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">clean:<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>rm -f *.o tar rmt testpad testpad.h core<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">distclean: clean<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>rm -f TAGS Makefile config.status<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">realclean: distclean<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>rm -f tar.info*<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">shar: $(SRCS) $(AUX)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>shar $(SRCS) $(AUX) | compress \<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>&gt; tar-`sed -e '/version_string/!d' \<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>-e 's/[^0-9.]*\([0-9.]*\).*/\1/' \<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>-e q<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span><span style="">&#160;&#160;&#160;</span>version.c`.shar.Z<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">dist: $(SRCS) $(AUX)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>echo tar-`sed \<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>-e '/version_string/!d' \<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>-e 's/[^0-9.]*\([0-9.]*\).*/\1/' \<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>-e q<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>version.c` &gt; .fname<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>-rm -rf `cat .fname`<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>mkdir `cat .fname`<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>ln $(SRCS) $(AUX) `cat .fname`<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>tar chZf `cat .fname`.tar.Z `cat .fname`<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>-rm -rf `cat .fname` .fname<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;">tar.zoo: $(SRCS) $(AUX)<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>-rm -rf tmp.dir<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>-mkdir tmp.dir<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>-rm tar.zoo<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>for X in $(SRCS) $(AUX) ; do \<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>echo $$X ; \<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>sed 's/$$/^M/' $$X \<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>&gt; tmp.dir/$$X ; done<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>cd tmp.dir ; zoo aM ../tar.zoo *<o:p></o:p></span></pre><pre><span lang="EN-US" style="font-family: 宋体;"><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>-rm -rf tmp.dir<o:p></o:p></span></pre>

<h1 style="margin: 0cm 0cm 1e-04pt;"><a name="_脚注"></a><span style="font-family: 宋体;">脚注<span lang="EN-US"><o:p></o:p></span></span></h1>

<h3 style="margin: 0cm 0cm 1e-04pt;"><span lang="EN-US" style="font-family: 宋体;"><a href="http://www.gnu.org/manual/make-3.79.1/html_mono/make.html#DOCF1">(1)</a><o:p></o:p></span></h3>

<p style="margin: 0cm 0cm 1e-04pt;">为<span lang="EN-US"> MS-DOS 和
MS-Windows编译的GNU Make和将前缀定义为DJGPP树体系的根的行为相同。 </span></p>

<h3 style="margin: 0cm 0cm 1e-04pt;"><span lang="EN-US" style="font-family: 宋体;"><a href="http://www.gnu.org/manual/make-3.79.1/html_mono/make.html#DOCF2">(2)</a><o:p></o:p></span></h3>

<p style="margin: 0cm 0cm 1e-04pt;">在<span lang="EN-US">MS-DOS上, 当前工作目录的值是<strong>global</strong>,
因此改变它将影响这些系统中随后的命令行。 </span></p>

<h3 style="margin: 0cm 0cm 1e-04pt;"><span lang="EN-US" style="font-family: 宋体;"><a href="http://www.gnu.org/manual/make-3.79.1/html_mono/make.html#DOCF3">(3)</a><o:p></o:p></span></h3>

<p style="margin: 0cm 0cm 1e-04pt;"><code><span lang="EN-US" style="font-size: 10pt;">texi2dvi</span></code><span lang="EN-US"> 使用TeX 进行真正的格式化工作.
TeX没有和 Texinfo一块发布。</span></p>


<div class="MsoNormal" align="center" style="text-align: center;"><span lang="EN-US" style="font-family: 宋体;">

<hr size="2" width="100%" align="center">

</span></div>


<p style="margin: 0cm 0cm 1e-04pt;">本文档使用版本<span lang="EN-US">1.54的texi2html
翻译器于2000年7月19日产生。</span></p>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></p>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></p>

<p class="MsoNormal"><span lang="EN-US" style="font-family: 宋体;"><!--[if !supportEmptyParas]-->&#160;<!--[endif]--><o:p></o:p></span></p>

<p class="MsoNormal"><span style="font-family: 宋体;">本文档的版权所有，不允许用于任何商业行为。<span lang="EN-US"><o:p></o:p></span></span></p>

<h1><a name="_名词翻译对照表"></a><span style="font-family: 宋体;">名词翻译对照表</span></h1>

<p class="MsoNormal" style=""><span lang="EN-US">archive <span style="">&#160;&#160;&#160;&#160;&#160;&#160;</span><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span></span><span style="font-family: 宋体;">档案</span></p>

<p class="MsoNormal" style=""><span lang="EN-US">archive member

targets <span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span></span><span style="font-family: 宋体;">档案成员目标</span></p>

<p class="MsoNormal" style=""><span lang="EN-US">arguments of
functions <span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span></span><span style="font-family: 宋体;">函数参数</span></p>

<p class="MsoNormal" style=""><span lang="EN-US">automatic
variables <span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span></span><span style="font-family: 宋体;">自动变量</span></p>

<p class="MsoNormal" style=""><span lang="EN-US">backslash
(\)<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span></span><span style="font-family: 宋体;">反斜杠</span><span lang="EN-US"> </span></p>

<p class="MsoNormal" style=""><span lang="EN-US">basename <span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span></span><span style="font-family: 宋体;">基本文件名</span></p>

<p class="MsoNormal" style=""><span lang="EN-US">binary packages <span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span></span><span style="font-family: 宋体;">二进制包</span></p>

<p class="MsoNormal" style=""><span lang="EN-US">compatibility <span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span></span><span style="font-family: 宋体;">兼容性</span></p>

<p class="MsoNormal" style=""><span lang="EN-US">data base <span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span></span><span style="font-family: 宋体;">数据库</span></p>

<p class="MsoNormal" style=""><span lang="EN-US">default
directries<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span></span><span style="font-family: 宋体;">缺省目录</span><span lang="EN-US"> </span></p>

<p class="MsoNormal" style=""><span lang="EN-US">default goal<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><span style="font-family: 宋体;">缺省最终目标</span><span lang="EN-US"> </span></p>

<p class="MsoNormal" style=""><span lang="EN-US">defining
variables verbatim <span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span></span><span style="font-family: 宋体;">定义多行变量</span></p>

<p class="MsoNormal" style=""><span lang="EN-US">directive <span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span></span><span style="font-family: 宋体;">指令</span></p>

<p class="MsoNormal" style=""><span lang="EN-US">dummy pattern
rule<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><span style="font-family: 宋体;">伪格式规则</span></p>

<p class="MsoNormal" style=""><span lang="EN-US"><a href="http://blog.chinaunix.net/DOWNinterruptmakefilemake_5.html#IDX270"><span style="color: windowtext; text-decoration: none;">echoing of commands</span></a> <span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span></span><span style="font-family: 宋体;">命令回显</span></p>

<p class="MsoNormal" style=""><span lang="EN-US">editor <span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span></span><span style="font-family: 宋体;">编辑器</span></p>

<p class="MsoNormal" style=""><span lang="EN-US">empty commands <span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span></span><span style="font-family: 宋体;">空命令</span></p>

<p class="MsoNormal" style=""><span lang="EN-US">empty targets <span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span></span><span style="font-family: 宋体;">空目标</span></p>

<p class="MsoNormal" style=""><span lang="EN-US">environment <span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span></span><span style="font-family: 宋体;">环境</span></p>

<p class="MsoNormal" style=""><span lang="EN-US">explicit rule<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><span style="font-family: 宋体;">具体规则</span><span lang="EN-US"> </span></p>

<p class="MsoNormal" style=""><span lang="EN-US">file name
functions <span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span></span><span style="font-family: 宋体;">文件名函数</span></p>

<p class="MsoNormal" style=""><span lang="EN-US">file name suffix
<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span></span><span style="font-family: 宋体;">文件名后缀</span></p>

<p class="MsoNormal" style=""><span lang="EN-US">flags <span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span></span><span style="font-family: 宋体;">标志</span></p>

<p class="MsoNormal" style=""><span lang="EN-US">flavors of
variables <span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span></span><span style="font-family: 宋体;">变量的特色</span></p>

<p class="MsoNormal" style=""><span lang="EN-US">functions <span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span></span><span style="font-family: 宋体;">函数</span></p>

<p class="MsoNormal" style=""><span lang="EN-US">goal <span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span></span><span style="font-family: 宋体;">最终目标</span></p>

<p class="MsoNormal" style=""><span lang="EN-US">implicit rule <span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span></span><span style="font-family: 宋体;">隐含规则</span></p>

<p class="MsoNormal" style=""><span lang="EN-US">incompatibilities
<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span></span><span style="font-family: 宋体;">不兼容性</span></p>

<p class="MsoNormal" style=""><span lang="EN-US">intermediate
files <span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span></span><span style="font-family: 宋体;">中间文件</span></p>

<p class="MsoNormal" style=""><span lang="EN-US">match-anything
rule <span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span></span><span style="font-family: 宋体;">万用规则</span></p>

<p class="MsoNormal" style=""><span lang="EN-US">options <span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span></span><span style="font-family: 宋体;">选项</span></p>

<p class="MsoNormal" style=""><span lang="EN-US">parallel
execution <span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span></span><span style="font-family: 宋体;">并行执行</span></p>

<p class="MsoNormal" style=""><span lang="EN-US">pattern rule <span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span></span><span style="font-family: 宋体;">格式规则</span></p>

<p class="MsoNormal" style=""><span lang="EN-US">phony targets <span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span></span><span style="font-family: 宋体;">假想目标</span></p>

<p class="MsoNormal" style=""><span lang="EN-US">prefix<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span><span style="">&#160;</span><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span></span><span style="font-family: 宋体;">前缀</span></p>

<p class="MsoNormal" style=""><span lang="EN-US">prerequisite <span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span></span><span style="font-family: 宋体;">依赖</span></p>

<p class="MsoNormal" style=""><span lang="EN-US">recompilation <span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span></span><span style="font-family: 宋体;">重新编译</span></p>

<p class="MsoNormal" style=""><span lang="EN-US">rule<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><span style="font-family: 宋体;">规则</span><span lang="EN-US"> </span></p>

<p class="MsoNormal" style=""><span lang="EN-US">shell command <span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span>shell</span><span style="font-family: 宋体;">命令</span></p>

<p class="MsoNormal" style=""><span lang="EN-US">static pattern
rule <span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span></span><span style="font-family: 宋体;">静态格式规则</span></p>

<p class="MsoNormal" style=""><span lang="EN-US">stem<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><span style="font-family: 宋体;">径</span><span lang="EN-US"> </span></p>

<p class="MsoNormal" style=""><span lang="EN-US">sub-make <span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span></span><span style="font-family: 宋体;">子</span><span lang="EN-US">make</span></p>

<p class="MsoNormal" style=""><span lang="EN-US">subdirectories<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><span style="font-family: 宋体;">子目录</span><span lang="EN-US"> </span></p>

<p class="MsoNormal" style=""><span lang="EN-US">suffix<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><span style="font-family: 宋体;">后缀</span></p>

<p class="MsoNormal" style=""><span lang="EN-US">suffix rule<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><span style="font-family: 宋体;">后缀规则</span><span lang="EN-US"> </span></p>

<p class="MsoNormal" style=""><span lang="EN-US">switches<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><span style="font-family: 宋体;">开关</span><span lang="EN-US"> </span></p>

<p class="MsoNormal" style=""><span lang="EN-US">target<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span><span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span><span style="">&#160;</span></span><span style="font-family: 宋体;">目标</span><span lang="EN-US"> </span></p>

<p class="MsoNormal" style=""><span lang="EN-US">value <span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span></span><span style="font-family: 宋体;">值</span></p>

<p class="MsoNormal" style=""><span lang="EN-US">variable <span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span></span><span style="font-family: 宋体;">变量</span></p>

<p class="MsoNormal" style=""><span lang="EN-US">wildcard <span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</span></span><span style="font-family: 宋体;">通配符</span></p>

<p class="MsoNormal" style=""><span lang="EN-US">word<span style="">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;
</span></span><span style="font-family: 宋体;">字</span></p>

</div>

</body></html>
#include "interrupt.h"#include "gic.h"#include "my_printf.h"#include "led.h"static volatile unsigned int *GPIO5_IMR 							 ;static volatile unsigned int *GPIO5_EDGE_SEL						 ;static volatile unsigned int *GPIO5_ISR    							 ;static volatile unsigned int *GPIO5_DR								 ;static volatile unsigned int *GPIO4_IMR 							 ;static volatile unsigned int *GPIO4_EDGE_SEL						 ;static volatile unsigned int *GPIO4_ISR    							 ;static volatile unsigned int *GPIO4_DR								 ;		  			 		  						  					  				 	   		  	  	 	  /********************************************************************** * 函数名称： key_exit_init * 功能描述： 初始化GIC中断控制器，设置按键中断相关寄存器 * 输入参数： 无 * 输出参数： 无 * 返 回 值： 无 * 修改日期        版本号     修改人	      修改内容 * ----------------------------------------------- * 2020/03/10	     V1.0	  来木	      创建 ***********************************************************************/void key_exit_init(void){	GPIO5_IMR								= (volatile unsigned int *)(0x20AC014);	GPIO5_EDGE_SEL							= (volatile unsigned int *)(0x20AC01C);	GPIO5_ISR								= (volatile unsigned int *)(0x20AC018);	GPIO5_DR                                = (volatile unsigned int *)(0x20AC000);		GPIO4_IMR								= (volatile unsigned int *)(0x20A8014);	GPIO4_EDGE_SEL							= (volatile unsigned int *)(0x20A801C);	GPIO4_ISR								= (volatile unsigned int *)(0x20A8018);	GPIO4_DR								= (volatile unsigned int *)(0x20A8000);	gic_init();	gic_enable_irq(GPIO5_Combined_0_15_IRQn);	gic_enable_irq(GPIO4_Combined_0_15_IRQn);	/* 设置GPIOx_EDGE_SEL寄存器	 * GPIO_EDGE_SEL bit is set, then a rising edge or falling edge in the corresponding	 *      signal generates an interrupt.	 * GPIO5_EDGE_SEL  0x20AC01C	 * bit[1] = 0b1	 * GPIO4_EDGE_SEL  0x20A801C	 * bit[14] = 0b1	 */	*GPIO5_EDGE_SEL |= (1<<1);	*GPIO4_EDGE_SEL |= (1<<14);	/* 设置GPIOx_IMR寄存器	 * GPIO_IMR contains masking bits for each interrupt line.	 * GPIO5_IMR  0x20AC014	 * bit[1] = 0b1	 * GPIO4_IMR  0x20A8014	 * bit[14] = 0b1	 */	*GPIO5_IMR |= (1<<1);	*GPIO4_IMR |= (1<<14);}/********************************************************************** * 函数名称： handle_irq_c * 功能描述： IRQ中断服务函数 * 输入参数： 无 * 输出参数： 无 * 返 回 值： 无 * 修改日期        版本号     修改人	      修改内容 * ----------------------------------------------- * 2020/03/10	     V1.0	  来木	      创建 ***********************************************************************/void handle_irq_c(void){	int nr;	GIC_Type *gic = get_gic_base();	/* The processor reads GICC_IAR to obtain the interrupt ID of the	 * signaled interrupt. This read acts as an acknowledge for the interrupt	 */	nr = gic->C_IAR;	printf("irq %d is happened\r\n", nr);	switch(nr)	{		case GPIO5_Combined_0_15_IRQn:		{			/* read GPIO5_DR to get GPIO5_IO01 status*/			if((*GPIO5_DR >> 1 ) & 0x1) {				printf("key 1 is release\r\n");				/* led off, set GPIO5_DR to configure GPIO5_IO03 output 1 */				led_ctl(0);			} else {				printf("key 1 is press\r\n");				/* led on, set GPIO5_DR to configure GPIO5_IO03 output 0 */				led_ctl(1);			}			/* write 1 to clear GPIO5_IO03 interrput status*/			*GPIO5_ISR |= (1 << 1);			break;		}				case GPIO4_Combined_0_15_IRQn:		{			/* read GPIO4_DR to get GPIO4_IO014 status*/			if((*GPIO4_DR >> 14 ) & 0x1)			{				printf("key 2 is release\r\n");				led_ctl(0);			}			else			{				printf("key 2 is press\r\n");				led_ctl(1);			}			/* write 1 to clear GPIO4_IO014 interrput status*/			*GPIO4_ISR |= (1 << 14);			break;		}		default:			break;	}	/* write GICC_EOIR inform the CPU interface that it has completed 	 * the processing of the specified interrupt 	 */	gic->C_EOIR = nr;}